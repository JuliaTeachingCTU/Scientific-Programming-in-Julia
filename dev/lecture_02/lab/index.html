<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lab Â· Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_02/lab/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/onlinestats.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture/">Lecture</a></li><li class="is-active"><a class="tocitem" href>Lab</a><ul class="internal"><li><a class="tocitem" href="#The-Grass-Agent"><span>The <code>Grass</code> Agent</span></a></li><li><a class="tocitem" href="#Sheep-and-Wolf-Agents"><span><code>Sheep</code> and <code>Wolf</code> Agents</span></a></li><li><a class="tocitem" href="#The-World"><span>The <code>World</code></span></a></li><li><a class="tocitem" href="#Sheep-eats-Grass"><span><code>Sheep</code> eats <code>Grass</code></span></a></li><li><a class="tocitem" href="#Wolf-eats-Sheep"><span><code>Wolf</code> eats <code>Sheep</code></span></a></li><li><a class="tocitem" href="#Reproduction"><span>Reproduction</span></a></li></ul></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design Patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Package development, Unit test &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Performance Benchmarking</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Language introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_06/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_06/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_07/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_07/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Automatic differentiation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_08/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_08/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Intermediate representation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_09/lab/">Lab</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Parallel programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_10/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_10/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">12: Uncertainty propagation in ODE</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_12/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_12/hw/">Homework</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">2: The power of Type System &amp; multiple dispatch</a></li><li class="is-active"><a href>Lab</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lab</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/2022W/docs/src/lecture_02/lab.md#" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="lab02"><a class="docs-heading-anchor" href="#lab02">Lab 2: Predator-Prey Agents</a><a id="lab02-1"></a><a class="docs-heading-anchor-permalink" href="#lab02" title="Permalink"></a></h1><p>In the next labs you will implement your own <em>predator-prey model</em>.  The model will contain wolves, sheep, and - to feed your sheep - some grass.  The final simulation will be turn-based and the agents will be able to eat each other, reproduce, and die in every iteration.  At every iteration of the simulation each agent will step forward in time via the <code>agent_step!</code> function. The steps for the <code>agent_step!</code> methods of animals and plants are written below in pseudocode.</p><pre><code class="nohighlight hljs"># for animals:
agent_step!(animal, world)
    decrement energy by 1
    find &amp; eat food (with probability pf)
    die if no more energy
    reproduce (with probability pr)

# for plants:
agent_step!(plant, world)
    grow if not at maximum size</code></pre><p>The <code>world</code> in which the agents live will be the simplest possible world with zero dimensions (i.e. a <code>Dict</code> of <code>ID=&gt;Agent</code>). Running and plotting your final result could look something like the plot below.</p><p><img src="../pred-prey.png" alt="img"/></p><p>We will start implementing the basic functionality for each <code>Agent</code> like <code>eat!</code>ing, <code>reproduce!</code>ing, and a very simplistic <code>World</code> for your agents to live in. In the next lab you will refine both the type hierarchy of your <code>Agent</code>s, as well as the design of the <code>World</code> in order to leverage the power of Julia&#39;s type system and compiler.</p><p>We start with a very basic type hierarchy:</p><pre><code class="language-julia hljs">abstract type Agent end
abstract type Animal &lt;: Agent end
abstract type Plant &lt;: Agent end</code></pre><p>We will implement the <code>World</code> for our <code>Agent</code>s later, but it will essentially be implemented by a <code>Dict</code> which maps unique IDs to an <code>Agent</code>. Hence, every agent will need an ID.</p><h2 id="The-Grass-Agent"><a class="docs-heading-anchor" href="#The-Grass-Agent">The <code>Grass</code> Agent</a><a id="The-Grass-Agent-1"></a><a class="docs-heading-anchor-permalink" href="#The-Grass-Agent" title="Permalink"></a></h2><p>Let&#39;s start by implementing some <code>Grass</code> which will later be able to grow during each iteration of our simulation.</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise:</header>
<div class="admonition-body"><ol><li>Define a mutable <code>struct</code> called <code>Grass</code> which is a subtype of <code>Plant</code> has the fields <code>id</code> (the unique identifier of this <code>Agent</code> - every agent needs one!), <code>size</code> (the current size of the <code>Grass</code>), and <code>max_size</code>. All fields should be integers.</li><li>Define a constructor for <code>Grass</code> which, given only an ID and a maximum size <span>$m$</span>, will create an instance of <code>Grass</code> that has a randomly initialized size in the range <span>$[1,m]$</span>. It should also be possible to create <code>Grass</code>, just with an ID and a default <code>max_size</code> of <code>10</code>.</li><li>Implement <code>Base.show(io::IO, g::Grass)</code> to get custom printing of your <code>Grass</code> such that the <code>Grass</code> is displayed with its size in percent of its <code>max_size</code>.</li></ol><p><em>Hint:</em> You can implement a custom <code>show</code> method for a new type <code>MyType</code> like this:</p><pre><code class="language-julia hljs">struct MyType
    x::Bool
end
Base.show(io::IO, a::MyType) = print(io, &quot;MyType $(a.x)&quot;)</code></pre></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Since Julia 1.8 we can also declare some fields of <code>mutable</code> structs as <code>const</code>, which can be used both to prevent us from mutating immutable fields (such as the ID) but can also be used by the compiler in certain cases.</p><pre><code class="language-julia hljs">mutable struct Grass &lt;: Plant
    const id::Int
    size::Int
    const max_size::Int
end

Grass(id,m=10) = Grass(id, rand(1:m), m)

function Base.show(io::IO, g::Grass)
    x = g.size/g.max_size * 100
    # hint: to type the leaf in the julia REPL you can do:
    # \:herb:&lt;tab&gt;
    print(io,&quot;ğŸŒ¿ #$(g.id) $(round(Int,x))% grown&quot;)
end</code></pre></p></details><p>Creating a few <code>Grass</code> agents can then look like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Grass(1,5)</code><code class="nohighlight hljs ansi" style="display:block;">ğŸŒ¿ #1 40% grown</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = Grass(2)</code><code class="nohighlight hljs ansi" style="display:block;">ğŸŒ¿ #2 60% grown</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; g.id = 5</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: setfield!: const field .id of type Grass cannot be changed</code></pre><h2 id="Sheep-and-Wolf-Agents"><a class="docs-heading-anchor" href="#Sheep-and-Wolf-Agents"><code>Sheep</code> and <code>Wolf</code> Agents</a><a id="Sheep-and-Wolf-Agents-1"></a><a class="docs-heading-anchor-permalink" href="#Sheep-and-Wolf-Agents" title="Permalink"></a></h2><p>Animals are slightly different from plants. They will have an energy <span>$E$</span>, which will be increase (or decrease) if the agent eats (or reproduces) by a certain amount <span>$\Delta E$</span>.  Later we will also need a probability to find food <span>$p_f$</span> and a probability to reproduce <span>$p_r$</span>.c</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise:</header>
<div class="admonition-body"><ol><li>Define two mutable structs <code>Sheep</code> and <code>Wolf</code> that are subtypes of <code>Animal</code> and have the fields <code>id</code>, <code>energy</code>, <code>Î”energy</code>, <code>reprprob</code>, and <code>foodprob</code>.</li><li>Define constructors with the following default values:<ul><li>For ğŸ‘: <span>$E=4$</span>, <span>$\Delta E=0.2$</span>, <span>$p_r=0.8$</span>, and <span>$p_f=0.6$</span>.</li><li>For ğŸº: <span>$E=10$</span>, <span>$\Delta E=8$</span>, <span>$p_r=0.1$</span>, and <span>$p_f=0.2$</span>.</li></ul></li><li>Overload <code>Base.show</code> to get pretty printing for your two new animals.</li></ol></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>Solution for <code>Sheep</code></p><pre><code class="language-julia hljs">mutable struct Sheep &lt;: Animal
    id::Int
    energy::Float64
    Î”energy::Float64
    reprprob::Float64
    foodprob::Float64
end

Sheep(id, e=4.0, Î”e=0.2, pr=0.8, pf=0.6) = Sheep(id,e,Î”e,pr,pf)

function Base.show(io::IO, s::Sheep)
    e = s.energy
    d = s.Î”energy
    pr = s.reprprob
    pf = s.foodprob
    print(io,&quot;ğŸ‘ #$(s.id) E=$e Î”E=$d pr=$pr pf=$pf&quot;)
end</code></pre><p>Solution for <code>Wolf</code>:</p><pre><code class="language-julia hljs">mutable struct Wolf &lt;: Animal
    const id::Int
    energy::Float64
    const Î”energy::Float64
    const reprprob::Float64
    const foodprob::Float64
end

Wolf(id, e=10.0, Î”e=8.0, pr=0.1, pf=0.2) = Wolf(id,e,Î”e,pr,pf)

function Base.show(io::IO, w::Wolf)
    e = w.energy
    d = w.Î”energy
    pr = w.reprprob
    pf = w.foodprob
    print(io,&quot;ğŸº #$(w.id) E=$e Î”E=$d pr=$pr pf=$pf&quot;)
end</code></pre></p></details><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sheep(4)</code><code class="nohighlight hljs ansi" style="display:block;">ğŸ‘ #4 E=4.0 Î”E=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Wolf(5)</code><code class="nohighlight hljs ansi" style="display:block;">ğŸº #5 E=10.0 Î”E=8.0 pr=0.1 pf=0.2</code></pre><h2 id="The-World"><a class="docs-heading-anchor" href="#The-World">The <code>World</code></a><a id="The-World-1"></a><a class="docs-heading-anchor-permalink" href="#The-World" title="Permalink"></a></h2><p>Before our agents can eat or reproduce we need to build them a <code>World</code>. The simplest (and as you will later see, somewhat suboptimal) world is essentially a <code>Dict</code> from IDs to agents. Later we will also need the maximum ID, lets define a world with two fields:</p><pre><code class="language-julia hljs">mutable struct World{A&lt;:Agent}
    agents::Dict{Int,A}
    max_id::Int
end</code></pre><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise:</header>
<div class="admonition-body"><p>Implement a constructor for the <code>World</code> which accepts a vector of <code>Agent</code>s.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function World(agents::Vector{&lt;:Agent})
    max_id = maximum(a.id for a in agents)
    World(Dict(a.id=&gt;a for a in agents), max_id)
end

# optional: overload Base.show
function Base.show(io::IO, w::World)
    println(io, typeof(w))
    for (_,a) in w.agents
        println(io,&quot;  $a&quot;)
    end
end</code></pre></p></details><h2 id="Sheep-eats-Grass"><a class="docs-heading-anchor" href="#Sheep-eats-Grass"><code>Sheep</code> eats <code>Grass</code></a><a id="Sheep-eats-Grass-1"></a><a class="docs-heading-anchor-permalink" href="#Sheep-eats-Grass" title="Permalink"></a></h2><p>We can implement the behaviour of our various agents with respect to each other by leveraging Julia&#39;s multiple dispatch.</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Implement a function <code>eat!(::Sheep, ::Grass, ::World)</code> which increases the sheep&#39;s energy by <span>$\Delta E$</span> multiplied by the size of the grass.</p><p>After the sheep&#39;s energy is updated the grass is eaten and its size counter has to be set to zero.</p><p>Note that you do not yet need the world in this function. It is needed later for the case of wolves eating sheep.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function eat!(sheep::Sheep, grass::Grass, w::World)
    sheep.energy += grass.size * sheep.Î”energy
    grass.size = 0
end</code></pre></p></details><p>Below you can see how a fully grown grass is eaten by a sheep.  The sheep&#39;s energy changes <code>size</code> of the grass is set to zero.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; grass = Grass(1)</code><code class="nohighlight hljs ansi" style="display:block;">ğŸŒ¿ #1 40% grown</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep = Sheep(2)</code><code class="nohighlight hljs ansi" style="display:block;">ğŸ‘ #2 E=4.0 Î”E=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; world = World([grass, sheep])</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Agent}
  ğŸ‘ #2 E=4.0 Î”E=0.2 pr=0.8 pf=0.6
  ğŸŒ¿ #1 40% grown</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eat!(sheep,grass,world);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; world</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Agent}
  ğŸ‘ #2 E=4.8 Î”E=0.2 pr=0.8 pf=0.6
  ğŸŒ¿ #1 0% grown</code></pre><p>Note that the order of the arguments has a meaning here. Calling <code>eat!(grass,sheep,world)</code> results in a <code>MethodError</code> which is great, because <code>Grass</code> cannot eat <code>Sheep</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; eat!(grass,sheep,world);</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching eat!(::Main.Grass, ::Main.Sheep, ::Main.World{Main.Agent})
Closest candidates are:
  eat!(<span class="sgr91">::Main.Sheep</span>, <span class="sgr91">::Main.Grass</span>, ::Main.World) at lab.md:249</code></pre><h2 id="Wolf-eats-Sheep"><a class="docs-heading-anchor" href="#Wolf-eats-Sheep"><code>Wolf</code> eats <code>Sheep</code></a><a id="Wolf-eats-Sheep-1"></a><a class="docs-heading-anchor-permalink" href="#Wolf-eats-Sheep" title="Permalink"></a></h2><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>The <code>eat!</code> method for wolves increases the wolf&#39;s energy by <code>sheep.energy * wolf.Î”energy</code> and kills the sheep (i.e.  removes the sheep from the world). There are other situationsin which agents die , so it makes sense to implement another function <code>kill_agent!(::Animal,::World)</code>.</p><p>Hint: You can use <code>delete!</code> to remove agents from the dictionary in your world.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function eat!(wolf::Wolf, sheep::Sheep, w::World)
    wolf.energy += sheep.energy * wolf.Î”energy
    kill_agent!(sheep,w)
end

kill_agent!(a::Agent, w::World) = delete!(w.agents, a.id)</code></pre></p></details><p>With a correct <code>eat!</code> method you should get results like this:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; grass = Grass(1);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep = Sheep(2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; wolf  = Wolf(3);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; world = World([grass, sheep, wolf])</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Agent}
  ğŸ‘ #2 E=4.0 Î”E=0.2 pr=0.8 pf=0.6
  ğŸº #3 E=10.0 Î”E=8.0 pr=0.1 pf=0.2
  ğŸŒ¿ #1 100% grown</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eat!(wolf,sheep,world);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; world</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Agent}
  ğŸº #3 E=42.0 Î”E=8.0 pr=0.1 pf=0.2
  ğŸŒ¿ #1 100% grown</code></pre><p>The sheep is removed from the world and the wolf&#39;s energy increased by <span>$\Delta E$</span>.</p><h2 id="Reproduction"><a class="docs-heading-anchor" href="#Reproduction">Reproduction</a><a id="Reproduction-1"></a><a class="docs-heading-anchor-permalink" href="#Reproduction" title="Permalink"></a></h2><p>Currently our animals can only eat. In our simulation we also want them to reproduce. We will do this by adding a <code>reproduce!</code> method to <code>Animal</code>.</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Write a function <code>reproduce!</code> that takes an <code>Animal</code> and a <code>World</code>. Reproducing will cost an animal half of its energy and then add an almost identical copy of the given animal to the world.  The only thing that is different from parent to child is the ID. You can simply increase the <code>max_id</code> of the world by one and use that as the new ID for the child.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function reproduce!(a::Animal, w::World)
    a.energy = a.energy/2
    new_id = w.max_id + 1
    Ã¢ = deepcopy(a)
    Ã¢.id = new_id
    w.agents[Ã¢.id] = Ã¢
    w.max_id = new_id
end</code></pre><p>You can avoid mutating the <code>id</code> field (which could be considered bad practice) by reconstructing the child from scratch:</p><pre><code class="language-julia hljs">function reproduce!(a::A, w::World) where A&lt;:Animal
    a.energy = a.energy/2
    a_vals = [getproperty(a,n) for n in fieldnames(A) if n!=:id]
    new_id = w.max_id + 1
    Ã¢ = A(new_id, a_vals...)
    w.agents[Ã¢.id] = Ã¢
    w.max_id = new_id
end</code></pre></p></details><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1, s2 = Sheep(1), Sheep(2)</code><code class="nohighlight hljs ansi" style="display:block;">(ğŸ‘ #1 E=4.0 Î”E=0.2 pr=0.8 pf=0.6, ğŸ‘ #2 E=4.0 Î”E=0.2 pr=0.8 pf=0.6)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; w = World([s1, s2])</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Sheep}
  ğŸ‘ #2 E=4.0 Î”E=0.2 pr=0.8 pf=0.6
  ğŸ‘ #1 E=4.0 Î”E=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reproduce!(s1, w);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; w</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Sheep}
  ğŸ‘ #2 E=4.0 Î”E=0.2 pr=0.8 pf=0.6
  ğŸ‘ #3 E=2.0 Î”E=0.2 pr=0.8 pf=0.6
  ğŸ‘ #1 E=2.0 Î”E=0.2 pr=0.8 pf=0.6</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture/">Â« Lecture</a><a class="docs-footer-nextpage" href="../hw/">Homework Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 23 December 2022 21:09">Friday 23 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
