<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_02/lecture/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a><ul class="internal"><li><a class="tocitem" href="#Structuring-the-code-/-enforcing-the-categories"><span>Structuring the code / enforcing the categories</span></a></li><li><a class="tocitem" href="#Intention-of-use-and-restrictions-on-compilers"><span>Intention of use and restrictions on compilers</span></a></li><li class="toplevel"><a class="tocitem" href="#type_system"><span>Julia&#39;s type system</span></a></li><li><a class="tocitem" href="#Julia-is-dynamicaly-typed"><span>Julia is dynamicaly typed</span></a></li><li><a class="tocitem" href="#Classes-of-types"><span>Classes of types</span></a></li><li><a class="tocitem" href="#More-on-the-use-of-types-in-function-definitions"><span>More on the use of types in function definitions</span></a></li><li><a class="tocitem" href="#Intermezzo:-How-does-the-Julia-compiler-work?"><span>Intermezzo: How does the Julia compiler work?</span></a></li></ul></li><li><a class="tocitem" href="../lab/">Lab</a></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">4: Packages development, Unit Tests &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">5: Benchmarking, profiling, and performance gotchas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">6: Language introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_06/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_06/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_07/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_07/hw/">Homework</a></li></ul></li><li><span class="tocitem">8: Introduction to automatic differentiation</span></li><li><span class="tocitem">9: Manipulating intermediate representation</span></li><li><span class="tocitem">10: Different levels of parallel programming</span></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><span class="tocitem">12: Uncertainty propagation in ODE</span></li><li><span class="tocitem">13: Learning ODE from data</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">2: The power of Type System &amp; multiple dispatch</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h1><p>Before going into the details of Julia&#39;s type system, we will spend a few minutes motivating the two main roles of a type system, which are:</p><ol><li>Structuring code</li><li>Communicating to the compiler how a type will be used</li></ol><p>The first aspect is important for the convenience of the programmer and enables abstractions in the language, the latter aspect is important for the speed of the generated code.</p><p>Type systems according to <a href="https://en.wikipedia.org/wiki/Data_type">Wikipedia</a>:</p><ul><li>In computer science and computer programming, a <strong>data type</strong> or simply <strong>type</strong> is an attribute of data which tells the compiler or interpreter how the programmer intends to use the data.</li><li>A <strong>type system</strong> is a logical system comprising a set of rules that assigns a property called a type to the various constructs of a computer program, such as variables, expressions, functions or modules. These types formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other components.</li></ul><h2 id="Structuring-the-code-/-enforcing-the-categories"><a class="docs-heading-anchor" href="#Structuring-the-code-/-enforcing-the-categories">Structuring the code / enforcing the categories</a><a id="Structuring-the-code-/-enforcing-the-categories-1"></a><a class="docs-heading-anchor-permalink" href="#Structuring-the-code-/-enforcing-the-categories" title="Permalink"></a></h2><p>The role of <strong>structuring</strong> the code and imposing semantic restriction means that the type system allows you to logically divide your program, and to prevent certain types of errors. Consider for example two types, <code>Wolf</code> and <code>Sheep</code> which share the same definition but the types have different names.</p><pre><code class="language-julia hljs">struct Wolf
  name::String
  energy::Int
end

struct Sheep
  name::String
  energy::Int
end</code></pre><p>This allows us to define functions applicable only to the corresponding type</p><pre><code class="language-julia hljs">howl(wolf::Wolf) = println(wolf.name, &quot; has howled.&quot;)
baa(sheep::Sheep) = println(sheep.name, &quot; has baaed.&quot;)</code></pre><p>Therefore the compiler (or interpreter) <strong>enforces</strong> that a wolf can only <code>howl</code> and never <code>baa</code> and vice versa a sheep can only <code>baa</code>. In this sense, it ensures that <code>howl(sheep)</code> and <code>baa(wolf)</code> never happen. For comparison, consider an alternative definition as follows</p><pre><code class="language-julia hljs">bark(animal) = println(animal.name, &quot; has howled.&quot;)
baa(animal)  = println(animal.name, &quot; has baaed.&quot;)</code></pre><p>in which case the burden of ensuring that a wolf will never baa rests upon the programmer which inevitably leads to errors (note that severely constrained type systems are difficult to use).</p><h2 id="Intention-of-use-and-restrictions-on-compilers"><a class="docs-heading-anchor" href="#Intention-of-use-and-restrictions-on-compilers">Intention of use and restrictions on compilers</a><a id="Intention-of-use-and-restrictions-on-compilers-1"></a><a class="docs-heading-anchor-permalink" href="#Intention-of-use-and-restrictions-on-compilers" title="Permalink"></a></h2><p>Additionally, types are used to generate efficient code. As an example, consider the following two alternatives to represent a set of animals:</p><pre><code class="language-julia hljs">a = [Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Sheep(&quot;3&quot;, 3)]
b = (Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Sheep(&quot;3&quot;, 3))</code></pre><p>where <code>a</code> is an array which can contain arbitrary types and have arbitrary length whereas <code>b</code> is a <code>Tuple</code> which has fixed length in which the first two items are of type <code>Wolf</code> and the third item is of type <code>Sheep</code>. Moreover, consider a function which calculates the energy of all animals as</p><pre><code class="language-julia hljs">energy(animals) = mapreduce(x -&gt; x.energy, +, animals)</code></pre><p>A good compiler makes use of the information provided by the type system to generate effiecint code which we can verify by inspecting the compiled code using <code>@code_native</code> macro</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_native energy(a)</code><code class="nohighlight hljs ansi" style="display:block;">	.text
<span class="sgr90">; ┌ @ lecture.md:83 within `energy&#39;</span>
	<span class="sgr96"><span class="sgr1">subq</span></span>	<span class="sgr33">$40</span>, %rsp
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rsi, <span class="sgr33">32(</span>%rsp<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">movq</span></span>	<span class="sgr33">(</span>%rsi<span class="sgr33">)</span>, %rax
	<span class="sgr96"><span class="sgr1">movabsq</span></span>	<span class="sgr33">$140587741867088</span>, %rcx          <span class="sgr90"># imm = 0x7FDD2269EC50</span>
<span class="sgr90">; │┌ @ reducedim.jl:310 within `mapreduce&#39;</span>
<span class="sgr90">; ││┌ @ reducedim.jl:310 within `#mapreduce#672&#39;</span>
<span class="sgr90">; │││┌ @ reducedim.jl:318 within `_mapreduce_dim&#39;</span>
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rcx, <span class="sgr33">(</span>%rsp<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">movabsq</span></span>	<span class="sgr93">$jl_system_image_data</span>, %rcx
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rcx, <span class="sgr33">8(</span>%rsp<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">movabsq</span></span>	<span class="sgr93">$jl_system_image_data</span>, %rcx
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rcx, <span class="sgr33">16(</span>%rsp<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rax, <span class="sgr33">24(</span>%rsp<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">movabsq</span></span>	<span class="sgr93">$_mapreduce</span>, %rax
	<span class="sgr96"><span class="sgr1">movabsq</span></span>	<span class="sgr93">$jl_system_image_data</span>, %rdi
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rsp, %rsi
	<span class="sgr96"><span class="sgr1">movl</span></span>	<span class="sgr33">$4</span>, %edx
	<span class="sgr96"><span class="sgr1">callq</span></span>	*%rax
<span class="sgr90">; │└└└</span>
	<span class="sgr96"><span class="sgr1">addq</span></span>	<span class="sgr33">$40</span>, %rsp
	<span class="sgr96"><span class="sgr1">retq</span></span>
<span class="sgr90">; └</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_native energy(b)</code><code class="nohighlight hljs ansi" style="display:block;">	.text
<span class="sgr90">; ┌ @ lecture.md:83 within `energy&#39;</span>
<span class="sgr90">; │┌ @ reduce.jl:287 within `mapreduce&#39;</span>
<span class="sgr90">; ││┌ @ reduce.jl:287 within `#mapreduce#218&#39;</span>
<span class="sgr90">; │││┌ @ reduce.jl:160 within `mapfoldl&#39;</span>
<span class="sgr90">; ││││┌ @ reduce.jl:160 within `#mapfoldl#214&#39;</span>
<span class="sgr90">; │││││┌ @ reduce.jl:44 within `mapfoldl_impl&#39;</span>
<span class="sgr90">; ││││││┌ @ reduce.jl:48 within `foldl_impl&#39;</span>
<span class="sgr90">; │││││││┌ @ tuple.jl:263 within `_foldl_impl&#39;</span>
<span class="sgr90">; ││││││││┌ @ operators.jl:534 within `afoldl&#39;</span>
<span class="sgr90">; │││││││││┌ @ reduce.jl:93 within `MappingRF&#39;</span>
<span class="sgr90">; ││││││││││┌ @ reduce.jl:81 within `BottomRF&#39;</span>
<span class="sgr90">; │││││││││││┌ @ int.jl:87 within `+&#39;</span>
	<span class="sgr96"><span class="sgr1">movq</span></span>	<span class="sgr33">24(</span>%rdi<span class="sgr33">)</span>, %rax
	<span class="sgr96"><span class="sgr1">addq</span></span>	<span class="sgr33">8(</span>%rdi<span class="sgr33">)</span>, %rax
<span class="sgr90">; ││││││││└└└└</span>
<span class="sgr90">; ││││││││┌ @ operators.jl:535 within `afoldl&#39;</span>
<span class="sgr90">; │││││││││┌ @ reduce.jl:93 within `MappingRF&#39;</span>
<span class="sgr90">; ││││││││││┌ @ reduce.jl:81 within `BottomRF&#39;</span>
<span class="sgr90">; │││││││││││┌ @ int.jl:87 within `+&#39;</span>
	<span class="sgr96"><span class="sgr1">addq</span></span>	<span class="sgr33">40(</span>%rdi<span class="sgr33">)</span>, %rax
<span class="sgr90">; │└└└└└└└└└└└</span>
	<span class="sgr96"><span class="sgr1">retq</span></span>
	<span class="sgr96"><span class="sgr1">nopl</span></span>	<span class="sgr33">(</span>%rax<span class="sgr33">)</span>
<span class="sgr90">; └</span></code></pre><p>one observes the second version produces more optimal code. Why is that?</p><ul><li>In the first representation, <code>a</code>, the animals are stored in an <code>Array</code> which can have arbitrary size and can contain arbitrary animals. This means that the compiler has to compile <code>energy(a)</code> such that it works on such arrays.</li><li>In the second representation, <code>b</code>, the animals are stored in a <code>Tuple</code>, which specializes for lengths and types of items. This means that the compiler knows the number of animals and the type of each animal on each position within the tuple, which allows it to specialize.</li></ul><p>This difference will indeed have an impact on the time of code execution. On my i5-8279U CPU, the difference (as measured by BenchmarkTools) is</p><pre><code class="language-julia hljs">using BenchmarkTools
@btime energy(a);
@btime energy(b);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  90.601 ns (0 allocations: 0 bytes)
  15.833 ns (0 allocations: 0 bytes)</code></pre><p>Which nicely demonstrates that the choice of types affects performance. Does it mean that we should always use <code>Tuples</code> instead of <code>Arrays</code>? Surely not, it is  just that each is better for different use-cases. Using Tuples means that the compiler will compile a special function for each length of tuple and each combination of types of items it contains, which is clearly wasteful.</p><h1 id="type_system"><a class="docs-heading-anchor" href="#type_system">Julia&#39;s type system</a><a id="type_system-1"></a><a class="docs-heading-anchor-permalink" href="#type_system" title="Permalink"></a></h1><h2 id="Julia-is-dynamicaly-typed"><a class="docs-heading-anchor" href="#Julia-is-dynamicaly-typed">Julia is dynamicaly typed</a><a id="Julia-is-dynamicaly-typed-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-is-dynamicaly-typed" title="Permalink"></a></h2><p>Julia&#39;s type system is dynamic, which means that all types are resolved during runtime. <strong>But</strong>, if the compiler can infer types of all variables of the called function, it can specialize the function for that given type of variables which leads to efficient code. Consider a modified example where we represent two wolfpacks:</p><pre><code class="language-julia hljs">wolfpack_a =  [Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Wolf(&quot;3&quot;, 3)]
wolfpack_b =  Any[Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Wolf(&quot;3&quot;, 3)]</code></pre><p><code>wolfpack_a</code> carries a type <code>Vector{Wolf}</code> while <code>wolfpack_b</code> has the type <code>Vector{Any}</code>. This means that in the first case, the compiler knows that all items are of the type <code>Wolf</code>and it can specialize functions using this information. In case of <code>wolfpack_b</code>, it does not know which animal it will encounter (although all are of the same type), and therefore it needs to dynamically resolve the type of each item upon its use. This ultimately leads to less performant code.</p><pre><code class="language-julia hljs">@btime energy(wolfpack_a)
@btime energy(wolfpack_b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  16.250 ns (0 allocations: 0 bytes)
  89.953 ns (0 allocations: 0 bytes)</code></pre><p>To conclude, julia is indeed a dynamically typed language, <strong>but</strong> if the compiler can infer all types in a called function in advance, it does not have to perform the type resolution during execution, which produces performant code.</p><h2 id="Classes-of-types"><a class="docs-heading-anchor" href="#Classes-of-types">Classes of types</a><a id="Classes-of-types-1"></a><a class="docs-heading-anchor-permalink" href="#Classes-of-types" title="Permalink"></a></h2><p>Julia divides types into three classes: primitive, composite, and abstract.</p><h3 id="Primitive-types"><a class="docs-heading-anchor" href="#Primitive-types">Primitive types</a><a id="Primitive-types-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-types" title="Permalink"></a></h3><p>Citing the <a href="https://docs.julialang.org/en/v1/manual/types/#Primitive-Types">documentation</a>:  <em>A primitive type is a concrete type whose data consists of plain old bits. Classic examples  of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself.</em></p><p>The definition of primitive types look as follows</p><pre><code class="language-julia hljs">primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end</code></pre><p>and they are mainly used to jump-start julia&#39;s type system. It is rarely needed to define a special primitive type, as it makes sense only if you define special functions operating on its bits. This is almost excusively used for exposing special operations provided by the underlying CPU / LLVM compiler. For example <code>+</code> for <code>Int32</code> is different from <code>+</code> for <code>Float32</code> as they call a different intrinsic operations. You can inspect this jump-starting of the type system yourself by looking at Julia&#39;s source.</p><pre><code class="language-julia hljs">julia&gt; @which +(1,2)
+(x::T, y::T) where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at int.jl:87</code></pre><p>At <code>int.jl:87</code></p><pre><code class="language-julia hljs">(+)(x::T, y::T) where {T&lt;:BitInteger} = add_int(x, y)</code></pre><p>we see that <code>+</code> of integers is calling the function <code>add_int(x, y)</code>, which is defined in the core part of the compiler in <code>Intrinsics.cpp</code> (yes, in C++).</p><p>From Julia docs: <em>Core is the module that contains all identifiers considered &quot;built in&quot; to the language, i.e. part of the core language and not libraries. Every module implicitly specifies using Core, since you can&#39;t do anything without those definitions.</em></p><p>Primitive types are rarely used, and they will not be used in this course. We mention them for the sake of completeness and refer the reader to the official Documentation (and source code of Julia).</p><h3 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h3><p>An abstract type can be viewed as a set of concrete types. For example, an <code>AbstractFloat</code> represents the set of concrete types <code>(BigFloat,Float64,Float32,Float16)</code>. This is used mainly to define general methods for sets of types for which we expect the same behavior (recall the Julia design motivation: <em>if it quacks like a duck, waddles like a duck and looks like a duck, chances are it&#39;s a duck</em>). Abstract types are defined with <code>abstract type TypeName end</code>. For example the following set of abstract types defines part of julia&#39;s number system.</p><pre><code class="language-julia hljs">abstract type Number end
abstract type Real          &lt;: Number end
abstract type Complex       &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer       &lt;: Real end
abstract type Signed        &lt;: Integer end
abstract type Unsigned      &lt;: Integer end</code></pre><p>where <code>&lt;:</code> means &quot;is a subtype of&quot; and it is used in declarations where the right-hand is an immediate sypertype of a given type (<code>Integer</code> has the immediate supertype <code>Real</code>.) If the supertype is not supplied, it is considered to be Any, therefore in the above defition <code>Number</code> has the supertype <code>Any</code>. Children of a particular type can be viewed as</p><pre><code class="language-julia hljs">using AbstractTrees
function AbstractTrees.children(t::Type)
    t === Function ? Vector{Type}() : filter!(x -&gt; x !== Any,subtypes(t))
end
AbstractTrees.printnode(io::IO,t::Type) = print(io,t)
print_tree(Number)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Number
├─ Complex
└─ Real
   ├─ AbstractFloat
   │  ├─ BigFloat
   │  ├─ Float16
   │  ├─ Float32
   │  └─ Float64
   ├─ AbstractIrrational
   │  └─ Irrational
   ├─ FixedPointNumbers.FixedPoint
   │  ├─ FixedPointNumbers.Fixed
   │  └─ FixedPointNumbers.Normed
   ├─ Integer
   │  ├─ Bool
   │  ├─ GeometryBasics.OffsetInteger
   │  ├─ GeometryTypes.OffsetInteger
   │  ├─ Signed
   │  │  ├─ BigInt
   │  │  ├─ Int128
   │  │  ├─ Int16
   │  │  ├─ Int32
   │  │  ├─ Int64
   │  │  └─ Int8
   │  └─ Unsigned
   │     ├─ UInt128
   │     ├─ UInt16
   │     ├─ UInt32
   │     ├─ UInt64
   │     └─ UInt8
   ├─ Rational
   ├─ Ratios.SimpleRatio
   ├─ StatsBase.PValue
   └─ StatsBase.TestStat</code></pre><p>As was mentioned, abstract types allows as to define functions that can be applied variebles of types with a given abstract type as a supertype. For example we can define a <code>sgn</code> function for <strong>all</strong> real numbers as</p><pre><code class="language-julia hljs">sgn(x::Real) = x &gt; 0 ? 1 : x &lt; 0 ? -1 : 0</code></pre><p>and we know it would be correct for all real numbers. This means that if anyone creates a new subtype of <code>Real</code>, the above function can be used. This also means that <strong>it is expected</strong> that comparison operations are defined for any real number. Also notice that <code>Complex</code> numbers are excluded, since they do not have a total order.</p><p>For unsigned numbers, the <code>sgn</code> can be simplified, as it is sufficient to verify if they are different (greater) than zero, therefore the function can read</p><pre><code class="language-julia hljs">sgn(x::Unsigned) = x &gt; 0 ? 1 : 0</code></pre><p>and again, it applies to all numbers derived from <code>Unsigned</code>. Recall that <code>Unsigned &lt;: Integer &lt;: Real,</code> how does Julia decide, which version of the function <code>sgn</code> to use for <code>UInt8(0)</code>? It chooses the most specific version, and thus for <code>sgn(UInt8(0))</code> it will use <code>sgn(x::Unsinged)</code>. If the compiler cannot decide, typically it encounters an ambiguity, it throws an error and recommends which function you should define to resolve it.</p><p>The above behavior allows to define default &quot;fallback&quot; implementations and while allowing to specialize for sub-types. A great example is matrix multiplication, which has a generic (and slow) implementation with many specializations, which can take advantage of structure (sparse, banded), or use optimized implementations (e.g. blas implementation for dense matrices with eltype <code>Float32</code> and <code>Float64</code>).</p><p>Again, Julia does not make a difference between abstract types defined in <code>Base</code> libraries shipped with the language and those defined by you (the user). All are treated the same.</p><p><a href="https://docs.julialang.org/en/v1/manual/types/#man-abstract-types">From Julia documentation</a>: Abstract types cannot be instantiated, which means that we cannot create a variable that would have an abstract type (try <code>typeof(Number(1f0))</code>). Also, abstract types cannot have any fields, therefore there is no composition (there are lengty discussions of why this is so, one of the most definite arguments of creators is that abstract types with fields frequently lead to children types not using some fields (consider circle vs. ellipse)).</p><h3 id="composite_types"><a class="docs-heading-anchor" href="#composite_types">Composite types</a><a id="composite_types-1"></a><a class="docs-heading-anchor-permalink" href="#composite_types" title="Permalink"></a></h3><p>Composite types are similar to <code>struct</code> in C (they even have the same memory layout) as they logically join together other types. It is not a great idea to think about them as objects (in OOP sense), because objects tie together <em>data</em> and <em>functions</em> on owned data. Contrary in Julia (as in C), functions operate on data of structures, but are not tied to them and they are defined outside them. Composite types are workhorses of Julia&#39;s type system, as user-defined types are mostly composite (or abstract).</p><p>Composite types are defined using <code>struct TypeName [fields] end</code>. To define a position of an animal on the Euclidean plane as a type, we would write</p><pre><code class="language-julia hljs">struct PositionF64
  x::Float64
  y::Float64
end</code></pre><p>which defines a structure with two fields <code>x</code> and <code>y</code> of type <code>Float64</code>. Julia&#39;s compiler creates a default constructor, where both (but generally all) arguments are converted using <code>(convert(Float64, x), convert(Float64, y)</code> to the correct type. This means that we can construct a PositionF64 with numbers of different type that are convertable to Float64, e.g. <code>PositionF64(1,1//2)</code> but we cannot construct <code>PositionF64</code> where the fields would be of different type (e.g. <code>Int</code>, <code>Float32</code>, etc.) or they are not trivially convertable (e.g. <code>String</code>).</p><p>Fields in composite types do not have to have a specified type.  We can define a <code>VaguePosition</code> without specifying the type</p><pre><code class="language-julia hljs">struct VaguePosition
  x
  y
end</code></pre><p>This works as the definition above except that the arguments are not converted to <code>Float64</code> now. One can store different values in <code>x</code> and <code>y</code>, for example <code>String</code> (e.g. VaguePosition(&quot;Hello&quot;,&quot;world&quot;)). Although the above definition might be convenient, it limits the compiler&#39;s ability to specialize, as the type  <code>VaguePosition</code> does not carry information about type of <code>x</code> and <code>y</code>, which has a negative impact on the performance. For example</p><pre><code class="language-julia hljs">using BenchmarkTools
move(a,b) = typeof(a)(a.x+b.x, a.y+b.y)
x = [PositionF64(rand(), rand()) for _ in 1:100]
y = [VaguePosition(rand(), rand()) for _ in 1:100]
@benchmark reduce(move, x)
@benchmark reduce(move, y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 8 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">3.513 μs</span></span> … <span class="sgr35">494.704 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 98.06%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">4.900 μs               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">5.181 μs</span></span> ± <span class="sgr32"> 10.524 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>4.50% ±  2.20%

    ▁▆      ▅▂█     ▁<span class="sgr34">▁</span>▅▆ <span class="sgr32"> </span>▁ ▆                                  
  ▃▇██▄▁▁▁▃▆███▁▁▁▂▆█<span class="sgr34">█</span>██▄<span class="sgr32">▅</span>█▅█▃▂▁▁▂▂▃▃▂▂▂▂▂▁▁▂▂▃▂▂▂▂▂▃▂▂▂▂▂▁▂▁ ▃
  3.51 μs<span class="sgr90">         Histogram: frequency by time</span>        7.75 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">3.12 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">199</span>.</code></pre><p>Giving fields of a composite type an abstract type does not really solve the problem of the compiler not knowing the type. In this example, it still does not know, if it should use instructions for <code>Float64</code> or <code>Int8</code>.</p><pre><code class="language-julia hljs">struct LessVaguePosition
  x::Real
  y::Real
end
z = [LessVaguePosition(rand(), rand()) for _ in 1:100];
@benchmark reduce(move, z)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">18.901 μs</span></span> … <span class="sgr35"> 7.079 ms</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 99.46%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">25.301 μs              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">27.366 μs</span></span> ± <span class="sgr32">70.617 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>2.57% ±  0.99%

                 █▆<span class="sgr34"> </span>    <span class="sgr32"> </span>                                      
  ▁▁▁▁▁▁▁▁▁▁▆▇▂▂▂██<span class="sgr34">█</span>▄▃▂▂<span class="sgr32">▅</span>▅▃▂▂▃▅▃▃▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  18.9 μs<span class="sgr90">         Histogram: frequency by time</span>        41.1 μs <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">9.31 KiB</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">496</span>.</code></pre><p>From the perspective of generating optimal code, both definitions are equally uninformative to the compiler as it cannot assume anything about the code. However, the  <code>LessVaguePosition</code> will ensure that the position will contain only numbers, hence catching trivial errors like instantiating <code>VaguePosition</code> with non-numeric types for which arithmetic operators will not be defined (recall the discussion on the  beginning of the lecture).</p><p>All structs defined above are immutable (as we have seen above in the case of <code>Tuple</code>), which means that one cannot change a field (unless the struct wraps a container, like and array, which allows that). For example this raises an error</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = LessVaguePosition(1,2)</code><code class="nohighlight hljs ansi" style="display:block;">Main.LessVaguePosition(1, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a.x = 2</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: setfield! immutable struct of type LessVaguePosition cannot be changed</code></pre><p>If one needs to make a struct mutable, use the keyword <code>mutable</code> before the keyword <code>struct</code> as</p><pre><code class="language-julia hljs">mutable struct MutablePosition
  x::Float64
  y::Float64
end</code></pre><p>In mutable structures, we can change the values of fields.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = MutablePosition(1e0, 2e0)</code><code class="nohighlight hljs ansi" style="display:block;">Main.MutablePosition(1.0, 2.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a.x = 2;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a</code><code class="nohighlight hljs ansi" style="display:block;">Main.MutablePosition(2.0, 2.0)</code></pre><p>Note, that the memory layout of mutable structures is different, as fields now contain references to memory locations, where the actual values are stored.</p><h3 id="Parametric-types"><a class="docs-heading-anchor" href="#Parametric-types">Parametric types</a><a id="Parametric-types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-types" title="Permalink"></a></h3><p>So far, we had to trade-off flexibility for generality in type definitions. Can we have both? The answer is affirmative. The way to achieve this  <strong>flexibility</strong> in definitions of the type while being  able to generate optimal code is to  <strong>parametrize</strong> the type definition. This is achieved by replacing types with a parameter (typically a single uppercase character) and decorating in definition by specifying different type in curly brackets. For example</p><pre><code class="language-julia hljs">struct PositionT{T}
  x::T
  y::T
end
u = [PositionT(rand(), rand()) for _ in 1:100]
@btime reduce(move, u)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  116.214 ns (1 allocation: 32 bytes)</code></pre><p>Notice that the compiler can take advantage of specializing for different types (which does not have an effect here as in modern processors addition of <code>Float</code> and <code>Int</code> takes the same time).</p><pre><code class="language-julia hljs">v = [PositionT(rand(1:100), rand(1:100)) for _ in 1:100]
@btime reduce(move, v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">  101.493 ns (1 allocation: 32 bytes)</code></pre><p>The above definition suffers the same problem as <code>VaguePosition</code>, which is that it allows us to instantiate the <code>PositionT</code> with non-numeric types, e.g. <code>String</code>. We solve this by restricting the types <code>T</code> to be children of some supertype, in this case <code>Real</code></p><pre><code class="language-julia hljs">struct Position{T&lt;:Real}
  x::T
  y::T
end</code></pre><p>which will throw an error if we try to initialize it with <code>Position(&quot;1.0&quot;, &quot;2.0&quot;)</code>.</p><p>Naturally, fields in structures can be of different types, as is in the below pointless example.</p><pre><code class="language-julia hljs">struct PositionXY{X&lt;:Real, Y&lt;:Real}
  x::X
  y::Y
end</code></pre><h3 id="Abstract-parametric-types"><a class="docs-heading-anchor" href="#Abstract-parametric-types">Abstract parametric types</a><a id="Abstract-parametric-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-parametric-types" title="Permalink"></a></h3><p>Like Composite types, Abstract types can also have parameters. These parameters define types that are common for all child types. A very good example is Julia&#39;s definition of arrays of arbitrary dimension <code>N</code> and type <code>T</code> of its items as</p><pre><code class="language-julia hljs">abstract type AbstractArray{T,N} end</code></pre><p>Different <code>T</code> and <code>N</code> give rise to different variants of <code>AbstractArrays</code>, therefore <code>AbstractArray{Float32,2}</code> is different from <code>AbstractArray{Float64,2}</code> and from <code>AbstractArray{Float64,1}.</code> Note that these are still <code>Abstract</code> types, which means you cannot instantiate them. Their purpose is</p><ul><li>to allow to define operations for broad class of concrete types</li><li>to inform the compiler about constant values, which can be used</li></ul><p>Notice in the above example that parameters of types do not have to be types, but can also be values of primitive types, as in the above example of <code>AbstractArray</code> <code>N</code> is the number of dimensions which is an integer value.</p><p>For convenience, it is common to give some important partially instantiated Abstract types an <strong>alias</strong>, for example <code>AbstractVector</code> as</p><pre><code class="language-julia hljs">const AbstractVector{T} = AbstractArray{T,1}</code></pre><p>is defined in <code>array.jl:23</code> (in Julia 1.6.2), which allows us to define for example general prescription for the <code>dot</code> product of two abstract vectors as</p><pre><code class="language-julia hljs">function dot(a::AbstractVector, b::AbstractVector)
  @assert length(a) == length(b)
  mapreduce(*, +, a, b)
end</code></pre><p>You can verify that the above general function can be compiled to performant code if specialized for particular arguments.</p><pre><code class="language-julia hljs">@code_native mapreduce(*,+, [1,2,3], [1,2,3])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">	.text
<span class="sgr90">; ┌ @ reducedim.jl:312 within `mapreduce&#39;</span>
	<span class="sgr96"><span class="sgr1">subq</span></span>	<span class="sgr33">$56</span>, %rsp
	<span class="sgr96"><span class="sgr1">movabsq</span></span>	<span class="sgr93">$.rodata.cst32</span>, %rax
	<span class="sgr96"><span class="sgr1">vmovaps</span></span>	<span class="sgr33">(</span>%rax<span class="sgr33">)</span>, %ymm0
	<span class="sgr96"><span class="sgr1">vmovups</span></span>	%ymm0, <span class="sgr33">8(</span>%rsp<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rdi, <span class="sgr33">40(</span>%rsp<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rsi, <span class="sgr33">48(</span>%rsp<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">movabsq</span></span>	<span class="sgr93">$jl_invoke</span>, %rax
	<span class="sgr96"><span class="sgr1">movabsq</span></span>	<span class="sgr93">$jl_system_image_data</span>, %rdi
	<span class="sgr96"><span class="sgr1">leaq</span></span>	<span class="sgr33">8(</span>%rsp<span class="sgr33">)</span>, %rsi
	<span class="sgr96"><span class="sgr1">movabsq</span></span>	<span class="sgr33">$140587733554672</span>, %rcx          <span class="sgr90"># imm = 0x7FDD21EB15F0</span>
	<span class="sgr96"><span class="sgr1">movl</span></span>	<span class="sgr33">$6</span>, %edx
	<span class="sgr96"><span class="sgr1">vzeroupper</span></span>
	<span class="sgr96"><span class="sgr1">callq</span></span>	*%rax
	<span class="sgr96"><span class="sgr1">movq</span></span>	<span class="sgr33">(</span>%rax<span class="sgr33">)</span>, %rax
	<span class="sgr96"><span class="sgr1">addq</span></span>	<span class="sgr33">$56</span>, %rsp
	<span class="sgr96"><span class="sgr1">retq</span></span>
	<span class="sgr96"><span class="sgr1">nopw</span></span>	<span class="sgr33">(</span>%rax,%rax<span class="sgr33">)</span>
<span class="sgr90">; └</span></code></pre><h2 id="More-on-the-use-of-types-in-function-definitions"><a class="docs-heading-anchor" href="#More-on-the-use-of-types-in-function-definitions">More on the use of types in function definitions</a><a id="More-on-the-use-of-types-in-function-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#More-on-the-use-of-types-in-function-definitions" title="Permalink"></a></h2><h3 id="Terminology"><a class="docs-heading-anchor" href="#Terminology">Terminology</a><a id="Terminology-1"></a><a class="docs-heading-anchor-permalink" href="#Terminology" title="Permalink"></a></h3><p>A <em>function</em> refers to a set of &quot;methods&quot; for a different combination of type parameters (the term function can be therefore considered as refering to a mere <strong>name</strong>). <em>Methods</em> define different behavior for different types of arguments for a given function. For example</p><pre><code class="language-julia hljs">move(a::Position, b::Position) = Position(a.x + b.x, a.y + b.y)
move(a::Vector{&lt;:Position}, b::Vector{&lt;:Position}) = move.(a,b)</code></pre><p><code>move</code> refers to a function with methods <code>move(a::Position, b::Position)</code> and <code>move(a::Vector{&lt;:Position}, b::Vector{&lt;:Position})</code>. When different behavior on different types is defined by a programmer, as shown above, it is also called <em>implementation specialization</em>. There is another type of specialization, called <em>compiler specialization</em>, which occurs when the compiler generates different functions for you from a single method. For example for</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; move(Position(1,1), Position(2,2))</code><code class="nohighlight hljs ansi" style="display:block;">Main.Position{Int64}(3, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; move(Position(1.0,1.0), Position(2.0,2.0))</code><code class="nohighlight hljs ansi" style="display:block;">Main.Position{Float64}(3.0, 3.0)</code></pre><p>the compiler generates two methods, one for <code>Position{Int64}</code> and the other for <code>Position{Float64}</code>. Notice that inside generated functions, the compiler needs to use different intrinsic operations, which can be viewed from</p><pre><code class="language-julia hljs">@code_native move(Position(1,1), Position(2,2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">	.text
<span class="sgr90">; ┌ @ lecture.md:393 within `move&#39;</span>
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rdi, %rax
<span class="sgr90">; │┌ @ int.jl:87 within `+&#39;</span>
	<span class="sgr96"><span class="sgr1">vmovdqu</span></span>	<span class="sgr33">(</span>%rdx<span class="sgr33">)</span>, %xmm0
	<span class="sgr96"><span class="sgr1">vpaddq</span></span>	<span class="sgr33">(</span>%rsi<span class="sgr33">)</span>, %xmm0, %xmm0
<span class="sgr90">; │└</span>
	<span class="sgr96"><span class="sgr1">vmovdqu</span></span>	%xmm0, <span class="sgr33">(</span>%rdi<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">retq</span></span>
<span class="sgr90">; └</span></code></pre><p>and</p><pre><code class="language-julia hljs">@code_native move(Position(1.0,1.0), Position(2.0,2.0))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">	.text
<span class="sgr90">; ┌ @ lecture.md:393 within `move&#39;</span>
	<span class="sgr96"><span class="sgr1">movq</span></span>	%rdi, %rax
<span class="sgr90">; │┌ @ float.jl:326 within `+&#39;</span>
	<span class="sgr96"><span class="sgr1">vmovupd</span></span>	<span class="sgr33">(</span>%rsi<span class="sgr33">)</span>, %xmm0
	<span class="sgr96"><span class="sgr1">vaddpd</span></span>	<span class="sgr33">(</span>%rdx<span class="sgr33">)</span>, %xmm0, %xmm0
<span class="sgr90">; │└</span>
	<span class="sgr96"><span class="sgr1">vmovupd</span></span>	%xmm0, <span class="sgr33">(</span>%rdi<span class="sgr33">)</span>
	<span class="sgr96"><span class="sgr1">retq</span></span>
<span class="sgr90">; └</span></code></pre><h2 id="Intermezzo:-How-does-the-Julia-compiler-work?"><a class="docs-heading-anchor" href="#Intermezzo:-How-does-the-Julia-compiler-work?">Intermezzo: How does the Julia compiler work?</a><a id="Intermezzo:-How-does-the-Julia-compiler-work?-1"></a><a class="docs-heading-anchor-permalink" href="#Intermezzo:-How-does-the-Julia-compiler-work?" title="Permalink"></a></h2><p>Let&#39;s walk through an example. Consider the following definitions</p><pre><code class="language-julia hljs">move(a::Position, by::Position) = Position(a.x + by.x, a.y + by.y)
move(a::T, by::T) where {T&lt;:Position} = Position(a.x + by.x, a.y + by.y)
move(a::Position{Float64}, by::Position{Float64}) = Position(a.x + by.x, a.y + by.y)
move(a::Vector{&lt;:Position}, by::Vector{&lt;:Position}) = move.(a, by)
move(a::Vector{&lt;:Position}, by::Position) = move.(a, by)</code></pre><p>and a function call</p><pre><code class="language-julia hljs">a = Position(1.0, 1.0)
by = Position(2.0, 2.0)
move(a, by)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Position{Float64}(3.0, 3.0)</code></pre><ol><li>The compiler knows that you call the function <code>move</code>.</li><li>The compiler infers the type of the arguments. You can view the result with</li></ol><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; (typeof(a),typeof(by))</code><code class="nohighlight hljs ansi" style="display:block;">(Main.Position{Float64}, Main.Position{Float64})</code></pre><ol><li>The compiler identifies all <code>move</code>-methods with arguments of type <code>(Position{Float64}, Position{Float64})</code>:</li></ol><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.method_instances(move, (typeof(a), typeof(by)))</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Core.MethodInstance}:
 MethodInstance for move(::Main.Position{Float64}, ::Main.Position{Float64})</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = Base.method_instances(move, (typeof(a), typeof(by))) |&gt; first</code><code class="nohighlight hljs ansi" style="display:block;">MethodInstance for move(::Main.Position{Float64}, ::Main.Position{Float64})</code></pre><p>4a. If the method has been specialized (compiled), then the arguments are prepared and the method is invoked. The compiled specialization can be seen from</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.cache</code><code class="nohighlight hljs ansi" style="display:block;">Core.CodeInstance(MethodInstance for move(::Main.Position{Float64}, ::Main.Position{Float64}), #undef, 0x00000000000074ff, 0xffffffffffffffff, Main.Position{Float64}, #undef, UInt8[0x0c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x16, 0x88  …  0xc8, 0x3d, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x09, 0x01], true, true, Ptr{Nothing} @0x00007fdd1a02c4d0, Ptr{Nothing} @0x00007fdd1a02c4c0)</code></pre><p>4b. If the method has not been specialized (compiled), the method is compiled for the given type of arguments and continues as in step 4a. A compiled function is therefore  a &quot;blob&quot; of <strong>native code</strong> living in a particular memory location. When Julia calls a function, it needs to pick the right block corresponding to a function with particular type of parameters.</p><p>If the compiler cannot narrow the types of arguments to concrete types, it has to perform the above procedure inside the called function, which has negative effects on performance, as the type resulution and identification of the methods can be slow, especially for methods with many arguments (e.g. 30ns for a method with one argument, 100 ns for method with two arguements). Recall the above example</p><pre><code class="language-julia hljs">wolfpack_a =  [Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Wolf(&quot;3&quot;, 3)]
@benchmark energy(wolfpack_a)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 998 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">15.432 ns</span></span> … <span class="sgr35">51.306 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">19.140 ns              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">20.120 ns</span></span> ± <span class="sgr32"> 3.283 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

    ▂       █▁<span class="sgr34"> </span>  <span class="sgr32"> </span>   ▄                                         
  ▄▅█▆▃▄▂▂▆▆██<span class="sgr34">▄</span>▇▃<span class="sgr32">▂</span>▂▅▄█▆▃▅▅▄▇▅▃▃▂▂▂▂▂▂▂▂▂▁▁▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ ▃
  15.4 ns<span class="sgr90">         Histogram: frequency by time</span>        34.1 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><p>and</p><pre><code class="language-julia hljs">wolfpack_b =  Any[Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Wolf(&quot;3&quot;, 3)]
@benchmark energy(wolfpack_b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 956 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1"> 88.917 ns</span></span> … <span class="sgr35">168.210 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">106.178 ns               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">110.265 ns</span></span> ± <span class="sgr32"> 15.036 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

   ▅█▄            ▃▆█<span class="sgr34">▅</span>▂ ▁<span class="sgr32">▁</span>▁        ▂▅▆▄▁   ▁ ▁▃▅▅▂   ▁          ▂
  █████▆█▆▅▅▁▃▄▁▃▅███<span class="sgr34">█</span>███<span class="sgr32">█</span>█▇▇▇▆▇▇▇██████████████████████▇▇▇██▇▇ █
  88.9 ns<span class="sgr90">       Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>        145 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><p>An interesting intermediate between fully abstract and fully concrete type happens, when the compiler knows that arguments have abstract type, which is composed of a small number of concrete types. This case  called Union-Splitting, which happens when there is just a little bit of uncertainty. Julia will do something like</p><pre><code class="language-julia hljs">argtypes = typeof(args)
push!(execution_stack, args)
if T == Tuple{Int, Bool}
  @goto compiled_blob_1234
else # the only other option is Tuple{Float64, Bool}
  @goto compiled_blob_1236
end</code></pre><p>For example</p><pre><code class="language-julia hljs">const WolfOrSheep = Union{Wolf, Sheep}
wolfpack_c =  WolfOrSheep[Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Wolf(&quot;3&quot;, 3)]
@benchmark energy(wolfpack_c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BenchmarkTools.Trial: 10000 samples with 997 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">18.456 ns</span></span> … <span class="sgr35">65.200 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span>0.00% … 0.00%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">22.067 ns              </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span>0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">22.612 ns</span></span> ± <span class="sgr32"> 3.765 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>0.00% ± 0.00%

   ▇         <span class="sgr34">█</span> <span class="sgr32"> </span>                                               
  ▃█▇▃▂▂▂▁▁▂▄<span class="sgr34">█</span>█<span class="sgr32">▃</span>▂▂▂▂▂▂▂▆▃▂▂▂▃█▃▄▂▂▂▁▂▁▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂ ▃
  18.5 ns<span class="sgr90">         Histogram: frequency by time</span>        37.4 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">0 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">0</span>.</code></pre><p>Thanks to union splitting, Julia is able to have performant operations on arrays with undefined / missing values for example</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; [1, 2, 3, missing] |&gt; typeof</code><code class="nohighlight hljs ansi" style="display:block;">Vector{Union{Missing, Int64}} (alias for Array{Union{Missing, Int64}, 1})</code></pre><h3 id="More-on-matching-methods-and-arguments"><a class="docs-heading-anchor" href="#More-on-matching-methods-and-arguments">More on matching methods and arguments</a><a id="More-on-matching-methods-and-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#More-on-matching-methods-and-arguments" title="Permalink"></a></h3><p>In the above process, the step, where Julia looks for a method instance with corresponding parameters can be very confusing. The rest of this lecture will focus on this. For those who want to have a formal background, we recommend <a href="https://www.youtube.com/watch?v=Y95fAipREHQ">talk of  Francesco Zappa Nardelli</a> and / or the one of <a href="https://www.youtube.com/watch?v=LT4AP7CUMAw">Jan Vitek</a>.</p><p>When Julia needs to specialize a method instance, it needs to find it among multiple definitions. A single function can have many method instances, see for example <code>methods(+)</code> which  lists all method instances of the <code>+</code>-function. How does Julia select the proper one?</p><ol><li>It finds all methods where the type of arguments match or are subtypes of restrictions on arguments in the method definition.</li></ol><p>2a. If there are multiple matches, the compiler selects the most specific definition.</p><p>2b. If the compiler cannot decide, which method instance to choose, it throws an error.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; confused_move(a::Position{Float64}, by) = Position(a.x + by.x, a.y + by.y)</code><code class="nohighlight hljs ansi" style="display:block;">confused_move (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; confused_move(a, by::Position{Float64}) = Position(a.x + by.x, a.y + by.y)</code><code class="nohighlight hljs ansi" style="display:block;">confused_move (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; confused_move(Position(1.0,2.0), Position(1.0,2.0))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: confused_move(::Main.Position{Float64}, ::Main.Position{Float64}) is ambiguous. Candidates:
  confused_move(a::Main.Position{Float64}, by) in Main at REPL[1]:1
  confused_move(a, by::Main.Position{Float64}) in Main at REPL[2]:1
Possible fix, define
  confused_move(::Main.Position{Float64}, ::Main.Position{Float64})</code></pre><p>2c. If it cannot find a suitable method, it throws an error.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; move(Position(1,2), VaguePosition(&quot;hello&quot;,&quot;world&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching +(::Int64, ::String)
Closest candidates are:
  +(::Any, ::Any, <span class="sgr91">::Any</span>, <span class="sgr91">::Any...</span>) at operators.jl:560
  +(::T, <span class="sgr91">::T</span>) where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at int.jl:87
  +(::Union{Int16, Int32, Int64, Int8}, <span class="sgr91">::BigInt</span>) at gmp.jl:534
  ...</code></pre><p>Some examples: Consider following definitions</p><pre><code class="language-julia hljs">move(a::Position, by::Position) = Position(a.x + by.x, a.y + by.y)
move(a::T, by::T) where {T&lt;:Position} = T(a.x + by.x, a.y + by.y)
move(a::Position{Float64}, by::Position{Float64}) = Position(a.x + by.x, a.y + by.y)
move(a::Vector{&lt;:Position}, by::Vector{&lt;:Position}) = move.(a, by)
move(a::Vector{T}, by::Vector{T}) where {T&lt;:Position} = move.(a, by)
move(a::Vector{&lt;:Position}, by::Position) = move.(a, by)</code></pre><p>Which method will compiler select for</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; move(Position(1.0,2.0), Position(1.0,2.0))</code><code class="nohighlight hljs ansi" style="display:block;">Main.Position{Float64}(2.0, 4.0)</code></pre><p>The first three methods match the types of argumens, but the compiler will select the third one, since it is the most specific.</p><p>Which method will compiler select for</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; move(Position(1,2), Position(1,2))</code><code class="nohighlight hljs ansi" style="display:block;">Main.Position{Int64}(2, 4)</code></pre><p>Again, the first and second method definitions match the argument, but the second is the most specific.</p><p>Which method will the compiler select for</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; move([Position(1,2)], [Position(1,2)])</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Main.Position{Int64}}:
 Main.Position{Int64}(2, 4)</code></pre><p>Again, the fourth and fifth method definitions match the argument, but the fifth is the most specific.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; move([Position(1,2), Position(1.0,2.0)], [Position(1,2), Position(1.0,2.0)])</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Main.Position}:
 Main.Position{Int64}(2, 4)
 Main.Position{Float64}(2.0, 4.0)</code></pre><h3 id="Frequent-problems"><a class="docs-heading-anchor" href="#Frequent-problems">Frequent problems</a><a id="Frequent-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Frequent-problems" title="Permalink"></a></h3><ol><li>Why does the following fail?</li></ol><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; foo(a::Vector{Real}) = println(&quot;Vector{Real}&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">foo (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; foo([1.0,2,3])</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching foo(::Vector{Float64})
Closest candidates are:
  foo(<span class="sgr91">::Vector{Real}</span>) at REPL[1]:1</code></pre><p>Julia&#39;s type system is <strong>invariant</strong>, which means that <code>Vector{Real}</code> is different from <code>Vector{Float64}</code> and from <code>Vector{Float32}</code>, even though <code>Float64</code> and <code>Float32</code> are sub-types of <code>Real</code>. Therefore <code>typeof([1.0,2,3])</code> isa <code>Vector{Float64}</code> which is not subtype of <code>Vector{Real}.</code> For <strong>covariant</strong> languages, this would be true. For more information on variance in computer languages, <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">see here</a>. If de above definition of <code>foo</code> should be applicable to all vectors which has elements of subtype of <code>Real</code> we have define it as</p><pre><code class="language-julia hljs">foo(a::Vector{T}) where {T&lt;:Real} = println(&quot;Vector{T} where {T&lt;:Real}&quot;)</code></pre><p>or equivalently but more tersely as</p><pre><code class="language-julia hljs">foo(a::Vector{&lt;:Real}) = println(&quot;Vector{T} where {T&lt;:Real}&quot;)</code></pre><ol><li>Diagonal rule says that a repeated type in a method signature has to be a concrete type. Consider for example the function below</li></ol><pre><code class="language-julia hljs">move(a::T, b::T) where {T&lt;:Position} = T(a.x + by.x, a.y + by.y)</code></pre><p>we cannot call it with <code>move(Position(1.0,2.0), Position(1,2))</code>, since in this case <code>Position(1.0,2.0)</code> is of type <code>Position{Float64}</code> while <code>Position(1,2)</code> is of type <code>Position{Int64}</code>.</p><ol><li>When debugging why arguments do not match a particular method definition, it is useful to use <code>typeof</code>, <code>isa</code>, and <code>&lt;:</code> commands. For example</li></ol><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(Position(1.0,2.0))</code><code class="nohighlight hljs ansi" style="display:block;">Main.Position{Float64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(Position(1,2))</code><code class="nohighlight hljs ansi" style="display:block;">Main.Position{Int64}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Position(1,2) isa Position{Float64}</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Position(1,2) isa Position{Real}</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Position(1,2) isa Position{&lt;:Real}</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(Position(1,2)) &lt;: Position{&lt;:Float64}</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(Position(1,2)) &lt;: Position{&lt;:Real}</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="A-bizzare-definition-which-you-can-encounter"><a class="docs-heading-anchor" href="#A-bizzare-definition-which-you-can-encounter">A bizzare definition which you can encounter</a><a id="A-bizzare-definition-which-you-can-encounter-1"></a><a class="docs-heading-anchor-permalink" href="#A-bizzare-definition-which-you-can-encounter" title="Permalink"></a></h3><p>The following definition of a one-hot matrix is taken from <a href="https://github.com/FluxML/Flux.jl/blob/1a0b51938b9a3d679c6950eece214cd18108395f/src/onehot.jl#L10-L12">Flux.jl</a></p><pre><code class="language-julia hljs">struct OneHotArray{T&lt;:Integer, L, N, var&quot;N+1&quot;, I&lt;:Union{T,AbstractArray{T, N}}} &lt;: AbstractArray{Bool, var&quot;N+1&quot;}
  indices::I
end</code></pre><p>The parameters of the type carry information about the type used to encode the position of <code>one</code> in each column in <code>T</code>, the dimension of one-hot vectors in <code>L</code>, the dimension of the storage of <code>indices</code> in <code>N</code> (which is zero for <code>OneHotVector</code> and one for <code>OneHotMatrix</code>), number of dimensions of the <code>OneHotArray</code> in <code>var&quot;N+1&quot;</code> and the type of underlying storage of indicies <code>I</code>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_01/hw/">« Homework</a><a class="docs-footer-nextpage" href="../lab/">Lab »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 28 October 2021 19:04">Thursday 28 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
