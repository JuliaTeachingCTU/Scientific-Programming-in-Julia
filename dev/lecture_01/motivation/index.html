<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Motivation · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_01/motivation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/onlinestats.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Motivation</a><ul class="internal"><li><a class="tocitem" href="#Classical-approach:-create-a-*fast*-library-and-flexible-calling-enviroment"><span>Classical approach: create a <em>fast</em> library and flexible calling enviroment</span></a></li><li class="toplevel"><a class="tocitem" href="#Julia-approach:-fresh-thinking"><span>Julia approach: fresh thinking</span></a></li><li><a class="tocitem" href="#Challenge"><span>Challenge</span></a></li><li><a class="tocitem" href="#Julia-way"><span>Julia way</span></a></li><li><a class="tocitem" href="#Teaser-example"><span>Teaser example</span></a></li><li><a class="tocitem" href="#Reproducibile-research"><span>Reproducibile research</span></a></li><li><a class="tocitem" href="#Julia-from-user&#39;s-point-of-view"><span>Julia from user&#39;s point of view</span></a></li></ul></li><li><a class="tocitem" href="../basics/">Basics</a></li><li><a class="tocitem" href="../demo/">Examples</a></li><li><a class="tocitem" href="../outline/">Outline</a></li><li><a class="tocitem" href="../lab/">Lab</a></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design Patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Package development, Unit test &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Performance Benchmarking</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Language introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_06/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_06/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_07/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_07/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Automatic differentiation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_08/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_08/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Intermediate representation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_09/lab/">Lab</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Parallel programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_10/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_10/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">12: Uncertainty propagation in ODE</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_12/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_12/hw/">Homework</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">1: Introduction</a></li><li class="is-active"><a href>Motivation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Motivation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/2022W/docs/src/lecture_01/motivation.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-Scientific-Programming"><a class="docs-heading-anchor" href="#Introduction-to-Scientific-Programming">Introduction to Scientific Programming</a><a id="Introduction-to-Scientific-Programming-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Scientific-Programming" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Loose definition of Scientific Programming</header><div class="admonition-body"><p>Scientific programming language is designed and optimized for the use of mathematical formula and matrices <a href="https://en.wikipedia.org/wiki/Scientific_programming_language">wiki</a></p></div></div><p>Examples of Scientific programming languages include ALGOL, APL, Fortran, J, Julia, Maple, MATLAB and R.</p><p>Key requirements:</p><ol><li>fast execution of the code (complex algorithms)</li><li>ease of code reuse / restructuring </li></ol><p>Contrast to general-purpose language:</p><ul><li>less concern with standalone executable/libraby compilation </li><li>less concern with Application binary interface (ABI)</li><li>less concern with business models (library + header files)</li><li>less concern with public/private separation</li></ul><div class="admonition is-success"><header class="admonition-header">Example of a scientific task</header><div class="admonition-body"><p>In many applications, we encounter the task of optimization a function given by a routine (e.g. engineering, finance, etc.)</p><pre><code class="language-julia hljs">using Optim

P(x,y) = x^2 - 3x*y + 5y^2 - 7y + 3   # user defined function

z₀ = [ 0.0
       0.0 ]     # starting point 

optimize(z -&gt; P(z...), z₀, ConjugateGradient())
optimize(z -&gt; P(z...), z₀, Newton())
optimize(z -&gt; P(z...), z₀, Newton();autodiff = :forward)
</code></pre></div></div><p>Very simple for a user, very complicated for a programmer. The program should:</p><ul><li>pick the right optimization method (easy by config-like approach)</li><li>compute gradient (Hessian) of a <em>user</em> function</li></ul><h2 id="Classical-approach:-create-a-*fast*-library-and-flexible-calling-enviroment"><a class="docs-heading-anchor" href="#Classical-approach:-create-a-*fast*-library-and-flexible-calling-enviroment">Classical approach: create a <em>fast</em> library and flexible calling enviroment</a><a id="Classical-approach:-create-a-*fast*-library-and-flexible-calling-enviroment-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-approach:-create-a-*fast*-library-and-flexible-calling-enviroment" title="Permalink"></a></h2><p>Crucial algorithms (sort, least squares...) are relatively small and well defined. Application of these algorithms to real-world problem is typically not well defined and requires more code. Iterative development. </p><p>Think of a problem of repeated execution of similar jobs with different options. Different level </p><ul><li>binary executable with command-line switches</li><li>binary executable with configuration file</li><li>scripting language/environment (Read-Eval-Print Loop)</li></ul><p>It is not a strict boundary, increasing expresivity of the configuration file will create a new scripting language.</p><p>Ending up in the <em>2 language problem</em>. </p><ol><li><p>Low-level programming = computer centric</p><ul><li>close to the hardware</li><li>allows excellent optimization for fast execution</li></ul></li><li><p>High-level programming = user centric</p><ul><li>running code with many different modifications as easily as possible</li><li>allowing high level of abstraction</li></ul></li></ol><p>In scientific programming, the most well known scripting languages are: Python,  Matlab, R</p><ul><li>If you care about standard &quot;configurations&quot; they are just perfect.  (PyTorch, BLAS)</li><li>You hit a problem with more complex experiments, such a modifying the internal algorithms.</li></ul><p>The scripting language typically makes decisions (<code>if</code>) at runtime. Becomes slow.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><ol><li>Basic Linear Algebra Subroutines (BLAS)–MKL, OpenBlas–-with bindings (Matlab, NumPy)</li><li>Matlab and Mex (C with pointer arithmetics)</li><li>Python with transcription to C (Cython)</li></ol><h3 id="Convergence-efforts"><a class="docs-heading-anchor" href="#Convergence-efforts">Convergence efforts</a><a id="Convergence-efforts-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-efforts" title="Permalink"></a></h3><ol><li>Just-in-time compilation (understands high level and converts to low-level)</li><li>automatic typing (auto in C++) (extends low-level with high-level concepts)</li></ol><h1 id="Julia-approach:-fresh-thinking"><a class="docs-heading-anchor" href="#Julia-approach:-fresh-thinking">Julia approach: fresh thinking</a><a id="Julia-approach:-fresh-thinking-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-approach:-fresh-thinking" title="Permalink"></a></h1><p><img src="../julia-scope.svg" alt/></p><p>A dance between specialization and abstraction. </p><ul><li><strong>Specialization</strong>  allows for custom treatment. The right algorithm for the right circumstance is obtained by <em>Multiple dispatch</em>,</li><li><strong>Abstraction</strong> recognizes what remains the same after differences are stripped away. Abstractions in mathematics are captured as code through <em>generic programming</em>.</li></ul><p>Why a new language?</p><h2 id="Challenge"><a class="docs-heading-anchor" href="#Challenge">Challenge</a><a id="Challenge-1"></a><a class="docs-heading-anchor-permalink" href="#Challenge" title="Permalink"></a></h2><p>Translate high-level thinking with as much abstraction as possible into specific <em>fast</em> machine code.</p><p>Not so easy!</p><div class="admonition is-category-theorem"><header class="admonition-header">Indexing array x in Matlab:</header><div class="admonition-body"><pre><code class="language-matlab hljs">x = [1,2,3]
y=x(4/2)
y=x(5/2)</code></pre><p>In the first case it works, in the second throws an error.</p><ul><li>type instability </li><li>function <code>inde(x,n,m)=x(n/m)</code> can never be fast.</li><li>Poor language design choice!</li></ul></div></div><p>Simple solution</p><ul><li>Solved by different floating and integer division operation <code>/,÷</code></li><li>Not so simple with complex objects, e.g. triangular matrices</li></ul><p>Julia was designed as a high-level language that allows very high level abstract concepts but <em>propagates</em> as much information about the specifics as possible to help the compiler to generate as fast code as possible. Taking lessons from the inability to achieve fast code compilation (mostly from python).</p><p><img src="../benchmarks.svg" alt/></p><ul><li>julia is faster than C?</li></ul><h2 id="Julia-way"><a class="docs-heading-anchor" href="#Julia-way">Julia way</a><a id="Julia-way-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-way" title="Permalink"></a></h2><p>Design principle: abstraction should have <em>zero</em> runtime  cost</p><ul><li>flexible type system with strong typing (abstract types)</li><li>multiple dispatch</li><li>single language from high to low levels (as much as possible) optimize execution as much as you can during <em>compile time</em><ul><li>functions as symbolic abstraction layers</li></ul></li></ul><p><img src="../julia-compilation.svg" alt/></p><ul><li>AST = Abstract Syntax Tree</li><li>IR = Intermediate Representation</li></ul><h2 id="Teaser-example"><a class="docs-heading-anchor" href="#Teaser-example">Teaser example</a><a id="Teaser-example-1"></a><a class="docs-heading-anchor-permalink" href="#Teaser-example" title="Permalink"></a></h2><p>Function recursion with arbitrary number of arguments:</p><pre><code class="language-julia hljs">fsum(x) = x
fsum(x,p...) = x+fsum(p[1],p[2:end]...)</code></pre><p>Defines essentially a sum of inputs. Nice generic and abstract concept.</p><p>Possible in many languages:</p><ul><li>Matlab via <code>nargin, varargin</code> using construction <code>if nargin==1, out=varargin{1}, else out=fsum(varargin{2:end}), end</code></li></ul><p>Julia solves this <code>if</code> at compile time. </p><p>The generated code can be inspected by macro <code>@code_llvm</code>?</p><pre><code class="nohighlight hljs">fsum(1,2,3)
@code_llvm fsum(1,2,3)
@code_llvm fsum(1.0,2.0,3.0)
fz()=fsum(1,2,3)
@code_llvm fz()</code></pre><p>Note that each call of fsum generates a new and different function.</p><p>Functions can act either as regular functions or like templates in C++. Compiler decides.</p><p>This example is relatively simple, many other JIT languages can optimize such code. Julia allows taking this approach further.</p><p>Generality of the code:</p><pre><code class="language-julia hljs">fsum(&#39;c&#39;,1)
fsum([1,2],[3,4],[5,6])</code></pre><p>Relies on <em>multiple dispatch</em> of the <code>+</code> function.</p><p>More involved example:</p><pre><code class="language-julia hljs">using Zygote

f(x)=3x+1           # user defined function
@code_llvm f&#39;(10)</code></pre><p>The simplification was not achieved by the compiler alone.</p><ul><li>Julia provides tools for AST and IR code manipulation</li><li>automatic differentiation via IR manipulation is implemented in Zygote.jl</li><li>in a similar way, debugger is implemented in Debugger.jl</li><li>very simple to design <em>domain specific</em> language<pre><code class="language-julia hljs">using Turing
using StatsPlots

@model function gdemo(x, y)
    s² ~ InverseGamma(2, 3)
    m ~ Normal(0, sqrt(s²))
    x ~ Normal(m, sqrt(s²))
    y ~ Normal(m, sqrt(s²))
end</code></pre></li></ul><p>Such tools allow building a very convenient user experience on abstract level, and reaching very efficient code.</p><h2 id="Reproducibile-research"><a class="docs-heading-anchor" href="#Reproducibile-research">Reproducibile research</a><a id="Reproducibile-research-1"></a><a class="docs-heading-anchor-permalink" href="#Reproducibile-research" title="Permalink"></a></h2><p>Think about a code that was written some time ago. To run it, you often need to be able to have the same version of the language it was written for. </p><ul><li><p><strong>Standard way</strong> language freezes syntax and guarantees some back-ward compatibility (Matlab), which prevents future improvements</p></li><li><p><strong>Julia approach</strong> allows easy recreation of the <em>environment</em> in which the code was developed. Every project (e.g. directory) can have its own environment</p></li></ul><div class="admonition is-success"><header class="admonition-header">Environment</header><div class="admonition-body"><p>Is an independent set of packages that can be local to an individual project or shared and selected by name.</p></div></div><div class="admonition is-success"><header class="admonition-header">Package</header><div class="admonition-body"><p>A package is a source tree with a standard layout providing functionality that can be reused by other Julia projects.</p></div></div><p>This allows  Julia to be a  rapidly evolving ecosystem with frequent changes due to:</p><ul><li>built-in package manager</li><li>switching between multiple versions of packages</li></ul><h3 id="Package-manager"><a class="docs-heading-anchor" href="#Package-manager">Package manager</a><a id="Package-manager-1"></a><a class="docs-heading-anchor-permalink" href="#Package-manager" title="Permalink"></a></h3><ul><li>implemented by Pkg.jl</li><li>source tree have their structure defined by a convention</li><li>have its own mode in REPL</li><li>allows adding packages for using (<code>add</code>) or development (<code>dev</code>)</li><li>supporting functions for creation (<code>generate</code>) and activation (<code>activate</code>) and many others</li></ul><h2 id="Julia-from-user&#39;s-point-of-view"><a class="docs-heading-anchor" href="#Julia-from-user&#39;s-point-of-view">Julia from user&#39;s point of view</a><a id="Julia-from-user&#39;s-point-of-view-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-from-user&#39;s-point-of-view" title="Permalink"></a></h2><ol><li><p><strong>compilation</strong> of everything to as specialized as possible</p><ul><li>very fast code</li><li>slow interaction (caching...)</li><li>generating libraries is harder <ul><li>think of <code>fsum</code>, </li><li>everything is &quot;.h&quot;  (Eigen library)</li></ul></li><li>debugging is different to matlab/python</li></ul></li><li><p><strong>extensibility</strong>, Multiple dispatch = multi-functions</p><ul><li>allows great extensibility and code composition</li><li>not (yet) mainstream thinking</li><li>Julia is not Object-oriented</li><li>Julia is (not pure) functional language</li></ul></li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../projects/">« Projects</a><a class="docs-footer-nextpage" href="../basics/">Basics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 15 December 2022 12:15">Thursday 15 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
