var documenterSearchIndex = {"docs":
[{"location":"projects/#projects","page":"Projects","title":"Projects","text":"","category":"section"},{"location":"projects/","page":"Projects","title":"Projects","text":"The goal of the project should be to create something, which is actually useful. Therefore we offer a lot of freedom in how the project will look like with the condition that you should spent around 60 hours on it (this number was derived as follows: each credit is worth 30 hours minus 13 lectures + labs minus 10 homeworks 2 hours each) and you should demonstrate some skills in solving the project. In general, we can distinguish three types of project depending on the beneficiary:","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"You benefit: Use / try to solve a well known problem using Julia language,\nOur group: work with your tutors on a topic researched in the AIC group, \nJulia community: choose an issue in a registered Julia project you like and fix it (documentation issues are possible but the resulting documentation should be very nice.).","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"The project should be of sufficient complexity that verify your skill of the language (to be agreed individually).","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"Below, we list some potential projects for inspiration.","category":"page"},{"location":"projects/#Implementing-new-things","page":"Projects","title":"Implementing new things","text":"","category":"section"},{"location":"projects/#The-Equation-Learner-And-Its-Symbolic-Representation","page":"Projects","title":"The Equation Learner And Its Symbolic Representation","text":"","category":"section"},{"location":"projects/","page":"Projects","title":"Projects","text":"In many scientific and engineering one searches for interpretable (i.e. human-understandable) models instead of the black-box function approximators that neural networks provide. The equation learner (EQL) is one approach that can identify concise equations that describe a given dataset.","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"The EQL is essentially a neural network with different unary or binary activation functions at each indiviual unit. The network weights are regularized during training to obtain a sparse model which hopefully results in a model that represents a simple equation.","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"The goal of this project is to implement the EQL, and if there is enough time the improved equation learner (iEQL). The equation learners should be tested on a few toy problems (possibly inspired by the tasks in the papers).  Finally, you will implement functionality that can transform the learned model into a symbolic, human readable, and exectuable Julia expression.","category":"page"},{"location":"projects/#Architecture-visualizer","page":"Projects","title":"Architecture visualizer","text":"","category":"section"},{"location":"projects/","page":"Projects","title":"Projects","text":"Write a tool that will take model written in Flux / Lux and visualize network architecture for publication. ","category":"page"},{"location":"projects/#Learning-Large-Language-Models-with-reduced-precition","page":"Projects","title":"Learning Large Language Models with reduced precition","text":"","category":"section"},{"location":"projects/","page":"Projects","title":"Projects","text":"Large Language Models ((Chat) GPT, LLama, Falcon, Palm, ...) are huge. A recent trend is to perform optimization in reduced precision, for example in int8 instead of Float32. Such feature is currently missing in Julia ecosystem and this project should be about bringing this to the community (for an introduction, read these blogs *LLM-int8 and emergent features**, *A gentle introduction to 8-bit Matrix Multiplication). The goal would be to implement this as an additional type of Number / Matrix and overload multiplication on CPU (and ideally on GPU) to make it transparent for neural networks? What I will learn? In this project, you will learn a lot about the (simplicity of) implementation of deep learning libraries and you will practice abstraction of Julia's types. You can furthermore learn about GPU Kernel programming and Transformers.jl library.","category":"page"},{"location":"projects/#Planning-algorithms","page":"Projects","title":"Planning algorithms","text":"","category":"section"},{"location":"projects/","page":"Projects","title":"Projects","text":"Extend SymbolicPlanners.jl with the mm-ϵ variant of the bi-directional search MM: A bidirectional search algorithm that is guaranteed to meet in the middle. This pull request might be very helpful in understanding better the library.","category":"page"},{"location":"projects/#A-Rule-Learning-Algorithms","page":"Projects","title":"A Rule Learning Algorithms","text":"","category":"section"},{"location":"projects/","page":"Projects","title":"Projects","text":"Rule-based models are simple and very interpretable models that have been around for a long time and are gaining popularity again. The goal of this project is to implement one of these algorithms","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"sequential covering","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"algorithm called RIPPER and evaluate it on a number of datasets.","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"Learning Certifiably Optimal Rule Lists for Categorical Data\nBoolean decision rules via column generation\nLearning Optimal Decision Trees with SAT\nA SAT-based approach to learn explainable decision sets","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"To increase the impact of the project, consider interfacing it with MLJ.jl","category":"page"},{"location":"projects/#Parallel-optimization","page":"Projects","title":"Parallel optimization","text":"","category":"section"},{"location":"projects/","page":"Projects","title":"Projects","text":"Implement one of the following algorithms to train neural networks in parallel. Can be implemented in a separate package or consider extending FluxDistributed.jl. Do not forget to verify that the method actually works!!!","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"Hogwild!\nLocal sgd with periodic averaging: Tighter analysis and adaptive synchronization\nDistributed optimization for deep learning with gossip exchange","category":"page"},{"location":"projects/#Improving-support-for-multi-threadding-functions-in-NNLib","page":"Projects","title":"Improving support for multi-threadding functions in NNLib","text":"","category":"section"},{"location":"projects/","page":"Projects","title":"Projects","text":"NNlib.jl is a workhorse library for deep learning in Julia (it powers Flux.jl). Yet most of their functions are single-threaded. The task is to choose few of them (e.g. logitcrossentropy or application of non-linearity) and make them multi-threaded. Ideally, you should make a workable pull request that will be accepted by the community. Warning: this will require interaction with the Flux community","category":"page"},{"location":"projects/#Project-requirements","page":"Projects","title":"Project requirements","text":"","category":"section"},{"location":"projects/","page":"Projects","title":"Projects","text":"The goal of the semestral project is to create a Julia pkg with reusable, properly tested and documented code. We have given you some options of topics, as well as the freedom to choose something that could be useful for your research or other subjects. In general we are looking for something where performance may be crucial such as data processing, optimization or equation solving.","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"In practice the project should follow roughly this tree structure","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":".\n├── scripts\n│\t├── run_example.jl\t\t\t# one or more examples showing the capabilities of the pkg\n│\t├── Project.toml \t\t\t# YOUR_PROJECT should be added here with develop command with rel path\n│\t└── Manifest.toml \t\t\t# should be committed as it allows to reconstruct the environment exactly\n├── src\n│\t├── YOUR_PROJECT.jl \t\t# ideally only some top level code such as imports and exports, rest of the code included from other files\n│\t├── src1.jl \t\t\t\t# source files structured in some logical chunks\n│\t└── src2.jl\n├── test\n│\t├── runtest.jl              # contains either all the tests or just includes them from other files\n│\t├── Project.toml  \t\t\t# lists some additional test dependencies\n│\t└── Manifest.toml   \t\t# usually not committed to git as it is generated on the fly\n├── README.md \t\t\t\t\t# describes in short what the pkg does and how to install pkg (e.g. some external deps) and run the example\n├── Project.toml  \t\t\t\t# lists all the pkg dependencies\n└── Manifest.toml  \t\t\t\t# usually not committed to git as the requirements may be to restrictive","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"The first thing that we will look at is README.md, which should warn us if there are some special installation steps, that cannot be handled with Julia's Pkg system. For example if some 3rd party binary dependency with license is required. Secondly we will try to run tests in the test folder, which should run and not fail and should cover at least some functionality of the pkg. Thirdly and most importantly we will instantiate environment in scripts and test if the example runs correctly. Lastly we will focus on documentation in terms of code readability, docstrings and inline comments. ","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"Only after all this we may look at the extent of the project and it's difficulty, which may help us in deciding between grades. ","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"Nice to have things, which are not strictly required but obviously improves the score.","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"Ideally the project should be hosted on GitHub, which could have the continuous integration/testing set up.\nInclude some benchmark and profiling code in your examples, which can show us how well you have dealt with the question of performance.\nSome parallelization attempts either by multi-processing, multi-threadding, or CUDA. Do not forget to show the improvement.\nDocumentation with a webpage using Documenter.jl.","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"Here are some examples of how the project could look like:","category":"page"},{"location":"projects/","page":"Projects","title":"Projects","text":"ImageInspector","category":"page"},{"location":"lecture_01/basics/#Syntax","page":"Basics","title":"Syntax","text":"","category":"section"},{"location":"lecture_01/basics/#Elementary-syntax:-Matlab-heritage","page":"Basics","title":"Elementary syntax: Matlab heritage","text":"","category":"section"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Very much like matlab:","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"indexing from  1\narray as first-class A=[1 2 3]","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Cheat sheet: https://cheatsheets.quantecon.org/","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Introduction: https://juliadocs.github.io/Julia-Cheat-Sheet/","category":"page"},{"location":"lecture_01/basics/#Arrays-are-first-class-citizens","page":"Basics","title":"Arrays are first-class citizens","text":"","category":"section"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Many design choices were motivated considering matrix arguments:","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"x *= 2 is implemented as x = x*2 causing new allocation (vectors).","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"The reason is consistency with matrix operations: A *= B works as A = A*B.","category":"page"},{"location":"lecture_01/basics/#Broadcasting-operator","page":"Basics","title":"Broadcasting operator","text":"","category":"section"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Julia generalizes matlabs .+ operation to general use for any function. ","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"a = [1 2 3]\nsin.(a)\nf(x)=x^2+3x+8\nf.(a)","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Solves the problem of inplace multiplication","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"x .*= 2 ","category":"page"},{"location":"lecture_01/basics/#Functional-roots-of-Julia","page":"Basics","title":"Functional roots of Julia","text":"","category":"section"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Function is a first-class citizen.","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Repetition of functional programming:","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"function mymap(f::Function,a::AbstractArray)\n    b = similar(a)\n    for i=1:length(a)\n        b[i]=f(a[i])\n    end\n    b\nend","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Allows for anonymous functions:","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"mymap(x->x^2+2,[1.0,2.0])","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Function properties:","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Arguments are passed by reference (change of mutable inputs inside the function is visible outside)\nConvention: function changing inputs have a name ending by \"!\" symbol\nreturn value \nthe last line of the function declaration, \nreturn keyword\nzero cost abstraction","category":"page"},{"location":"lecture_01/basics/#Different-style-of-writing-code","page":"Basics","title":"Different style of writing code","text":"","category":"section"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Definitions of multiple small functions and their composition","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"fsum(x) = x\nfsum(x,p...) = x+fsum(p[1],p[2:end]...)","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"a single methods may not be sufficient to understand the full algorithm. In procedural language, you may write:","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"function out=fsum(x,varargin)\nif nargin==2 # TODO: better treatment\n    out=x\nelse\n    out = fsum(varargin{1},varargin{2:end})\nend","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"The need to build intuition for function composition.","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Dispatch is easier to optimize by the compiler.","category":"page"},{"location":"lecture_01/basics/#Operators-are-functions","page":"Basics","title":"Operators are functions","text":"","category":"section"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"operator function name\n[A B C ...] hcat\n[A; B; C; ...] vcat\n[A B; C D; ...] hvcat\nA' adjoint\nA[i] getindex\nA[i] = x setindex!\nA.n getproperty\nA.n = x setproperty!","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"Can be redefined and overloaded for different input types. The getproperty method can define access to the memory structure.","category":"page"},{"location":"lecture_01/basics/#Broadcasting-revisited","page":"Basics","title":"Broadcasting revisited","text":"","category":"section"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"The a.+b syntax is a syntactic sugar for broadcast(+,a,b).","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"The special meaning of the dot is that they will be fused into a single call:","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"f.(g.(x .+ 1)) is treated by Julia as broadcast(x -> f(g(x + 1)), x). \nAn assignment y .= f.(g.(x .+ 1)) is treated as in-place operation broadcast!(x -> f(g(x + 1)), y, x).","category":"page"},{"location":"lecture_01/basics/","page":"Basics","title":"Basics","text":"The same logic works for lists, tuples, etc.","category":"page"},{"location":"lecture_01/hw/#Homework-1:-Extending-polynomial-the-other-way","page":"Homework","title":"Homework 1: Extending polynomial the other way","text":"","category":"section"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-homework\">\n<header class=\"admonition-header\">Homework (2 points)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Extend the original polynomial function to the case where x is a square matrix. Create a function called circlemat, that returns nxn matrix A(n) with the following elements","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"leftA(n)right_ij = \nbegincases\n   1 textif  (i = j-1 land j  1) lor (i = n land j=1) \n   1 textif  (i = j+1 land j  n) lor (i = 1 land j=n) \n   0  text  otherwise\nendcases","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"and evaluate the polynomial","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"f(A) = I + A + A^2 + A^3","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":", at point A = A(10).","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"HINTS for matrix definition: You can try one of these options:","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"create matrix with all zeros with zeros(n,n), use two nested for loops going in ranges 1:n and if condition with logical or ||, and && \nemploy array comprehension with nested loops [expression for i in 1:n, j in 1:n] and ternary operator condition ? true branch : false","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"HINTS for polynomial extension:","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"extend the original example (one with for-loop) to initialize the accumulator variable with matrix of proper size (use size function to get the dimension), using argument typing for x is preferred to distinguish individual implementations <: AbstractMatrix","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"or","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"test later defined polynomial methods, that may work out of the box","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\" hidden>\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Nothing to see here.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise (voluntary)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Install GraphRecipes and Plots packages into the environment defined during the lecture and figure out, how to plot the graph defined by adjacency matrix A from the homework.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"HINTS:","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"There is help command inside the the pkg mod of the REPL. Type ? add to find out how to install a package. Note that both pkgs are registered.\nFollow a guide in the Plots pkg's documentation, which is accessible through docs icon on top of the README in the GitHub repository. Direct link.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Activate the environment in pkg mode, if it is not currently active.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"pkg> activate .","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Installing pkgs is achieved using the add command. Running ] ? add returns a short piece of documentation for this command:","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"pkg> ? add\n[...]\n  Examples\n\n  pkg> add Example                                          # most commonly used for registered pkgs (installs usually the latest release)\n  pkg> add Example@0.5                                      # install with some specific version (realized through git tags)\n  pkg> add Example#master                                   # install from master branch directly\n  pkg> add Example#c37b675                                  # install from specific git commit\n  pkg> add https://github.com/JuliaLang/Example.jl#master   # install from specific remote repository (when pkg is not registered)\n  pkg> add git@github.com:JuliaLang/Example.jl.git          # same as above but using the ssh protocol\n  pkg> add Example=7876af07-990d-54b4-ab0e-23690620f79a     # when there are multiple pkgs with the same name","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"As the both Plots and GraphRecipes are registered and we don't have any version requirements, we will use the first option.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"pkg> add Plots\npkg> add GraphRecipes","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"This process downloads the pkgs and triggers some build steps, if for example some binary dependencies are needed. The process duration depends on the \"freshness\" of Julia installation and the size of each pkg. With Plots being quite dependency heavy, expect few minutes. After the installation is complete we can check the updated environment with the status command.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"pkg> status","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"The plotting itself as easy as calling the graphplot function on our adjacency matrix.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"using GraphRecipes, Plots\nA = [ 0  1  0  0  0  0  0  0  0  1; 1  0  1  0  0  0  0  0  0  0; 0  1  0  1  0  0  0  0  0  0; 0  0  1  0  1  0  0  0  0  0; 0  0  0  1  0  1  0  0  0  0; 0  0  0  0  1  0  1  0  0  0; 0  0  0  0  0  1  0  1  0  0; 0  0  0  0  0  0  1  0  1  0; 0  0  0  0  0  0  0  1  0  1; 1  0  0  0  0  0  0  0  1  0]# hide\ngraphplot(A)","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"graphplot(A) #hide","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_01/hw/#How-to-submit?","page":"Homework","title":"How to submit?","text":"","category":"section"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Isolate the code of the compulsory task into a script named hw.jl alongside with the Project.toml and Manifest.toml of the environment. Create a zipfile of the folder and send it to the lab instructor, who has assigned the task, via email (contact emails are located on the homepage of the course).","category":"page"},{"location":"lecture_01/outline/#Course-outline","page":"Outline","title":"Course outline","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"Introduction\nType system\nuser: tool for abstraction\ncompiler: tool for memory layout\nDesign patterns (mental setup)\nJulia is a type-based language\nmultiple-dispatch generalizes OOP and FP\nPackages\nway how to organize code\ncode reuse (alternative to libraries)\nexperiment reproducibility\nBenchmarking\nhow to measure code efficiency\nIntrospection\nunderstand how the compiler process the data\nMacros\nautomate writing of boring the boilerplate code\ngood macro create cleaner code\nAutomatic Differentiation\nTheory: difference between the forward and backward mode\nImplementation techniques\nIntermediate representation\nhow to use internal the representation of the code \nexample in automatic differentiation\nParallel computing\nthreads, processes\nGraphics card coding\ntypes for GPU\nspecifics of architectures\nOrdinary Differential Equations\nsimple solvers\nerror propagation\nData driven ODE\ncombine ODE with optimization\nautomatic differentiation (adjoints)","category":"page"},{"location":"lecture_01/lab/#Lab-01:-Introduction-to-Julia","page":"Lab","title":"Lab 01: Introduction to Julia","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This lab should get everyone up to speed in the basics of Julia's installation, syntax and basic coding. For more detailed introduction you can check out Lectures 1-3 of the bachelor course.","category":"page"},{"location":"lecture_01/lab/#Testing-Julia-installation-(custom-setup)","page":"Lab","title":"Testing Julia installation (custom setup)","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to proceed further let's run a simple script to see, that the setup described in chapter Installation is working properly. After spawning a terminal/cmdline run this command:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia ./test_setup.jl","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The script does the following ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"\"Tests\" if Julia is added to path and can be run with julia command from anywhere\nPrints Julia version info\nChecks Julia version.\nChecks git configuration (name + email)\nCreates an environment configuration files\nInstalls a basic pkg called BenchmarkTools, which we will use for benchmarking a simple function later in the labs.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"There are some quality of life improvements over long term support versions of Julia and thus throughout this course we will use the latest stable release of Julia 1.6.x.","category":"page"},{"location":"lecture_01/lab/#Polynomial-evaluation-example","page":"Lab","title":"Polynomial evaluation example","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Let's consider a common mathematical example for evaluation of nth-degree polynomial","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"f(x) = a_nx^n + a_n-1x^n-1 + dots + a_0x^0","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"where x in mathbbR and veca in mathbbR^n+1.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way of writing this in a generic fashion is realizing that essentially the function f is really implicitly containing argument veca, i.e. f equiv f(veca x), yielding the following Julia code","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    accumulator = 0\n    for i in length(a):-1:1\n        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n    end\n    return accumulator\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Evaluate the code of the function called polynomial in Julia REPL and evaluate the function itself with the following arguments.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6] # list coefficients a from a^0 to a^n\nx = 3               # point of evaluation\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way is to just copy&paste into an already running terminal manually. As opposed to the default Python REPL, Julia can deal with the blocks of code and different indentation much better without installation of an ipython-like REPL. There are ways to make this much easier in different text editors/IDEs:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"VSCode - when using Julia extension is installed and .jl file is opened, Ctrl/Cmd+Enter will spawn Julia REPL\nSublime Text - Ctrl/Cmd+Enter with Send Code pkg (works well with Linux terminal or tmux, support for Windows is poor)\nVim - there is a Julia language plugin, which can be combine with vimcmdline to gain similar functionality","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Either way, you should see the following:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    accumulator = 0\n    for i in length(a):-1:1\n        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n    end\n    return accumulator\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Similarly we enter the arguments of the function a and x:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6]\nx = 3","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Function call intuitively takes the name of the function with round brackets as arguments, i.e. works in the same way as majority of programming languages. The result is printed unless a ; is added at the end of the statement.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)    # function call","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Thanks to the high level nature of Julia language it is often the case that examples written in pseudocode are almost directly rewritable into the language itself without major changes and the code can be thus interpreted easily.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"(Image: polynomial_explained)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Due to the existence of the end keyword, indentation is not necessary as opposed to other languages such as Python, however it is strongly recommended to use it, see style guide.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Though there are libraries/IDEs that allow us to step through Julia code (Debugger.jl link and VSCode link), here we will explore the code interactively in REPL by evaluating pieces of code separately.","category":"page"},{"location":"lecture_01/lab/#Basic-types,-assignments-and-variables","page":"Lab","title":"Basic types, assignments and variables","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"When defining a variable through an assignment we get the representation of the right side, again this is different from the default  behavior in Python, where the output of assignments a = [-19, 7, -4, 6] or x = 3, prints nothing. Internally Julia returns the result of the display function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6]\ndisplay(a) # should return the same thing as the line above","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As you can see, the string that is being displayed contains information about the contents of a variable along with it's type in this case this is a Vector/Array of Int types. If the output of display is insufficient the type of variable can be checked with the typeof function:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(a)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Additionally for collection/iterable types such as Vector there is also the eltype function, which returns the type of elements in the collection.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"eltype(a)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In most cases variables store just a reference to a place in memory either stack/heap (exceptions are primitive types such as Int, Float) and therefore creating an array a, \"storing\" the reference in b with an assignment and changing elements of b, e.g. b[1] = 2, changes also the values in a.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Create variables x and accumulator, storing floating point 3.0 and integer value 0 respectively. Check the type of variables using typeof function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"x = 3.0\naccumulator = 0\ntypeof(x), typeof(accumulator)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#For-cycles-and-ranges","page":"Lab","title":"For cycles and ranges","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Moving further into the polynomial function we encounter the definition of a for cycle, with the de facto standard syntax","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"for iteration_variable in iterator\n    # do something\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As an example of iterator we have used an instance of a range type ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"r = length(a):-1:1\ntypeof(r)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As opposed to Python, ranges in Julia are inclusive, i.e. they contain number from start to end - in this case running from 4 to 1 with negative step -1, thus counting down. This can be checked with the collect and/or length functions.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"collect(r)\nlength(r)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Create variable c containing an array of even numbers from 2 to 42. Furthermore create variable d that is different from c only at the 7th position, which will contain 13.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINT: Use collect function for creation of c and copy for making a copy of c.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"c = collect(2:2:42)\nd = copy(c)\nd[7] = 13\nd","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Functions-and-operators","page":"Lab","title":"Functions and operators","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Let us now move from the function body to the function definition itself. From the picture at the top of the page, we can infer the general syntax for function definition:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function function_name(arguments)\n    # do stuff with arguments and define output value `something`\n    return something\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The return keyword can be omitted, if the last line being evaluated contains the result.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"By creating the function polynomial we have defined a variable polynomial, that from now on always refers to a function and cannot be reassigned to a different type, like for example Int.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial = 42","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This is caused by the fact that each function defines essentially a new type, the same like Int ~ Int64 or Vector{Int}.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(polynomial)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"You can check that it is a subtype of the Function abstract type, with the subtyping operator <:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(polynomial) <: Function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"These concepts will be expanded further in the type system lecture, however for now note that this construction is quite useful for example if we wanted to create derivative rules for our function derivativeof(::typeof(polynomial), ...).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Looking at mathematical operators +, *, we can see that in Julia they are also standalone functions. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"+\n*","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The main difference from our polynomial function is that there are multiple methods, for each of these functions. Each one of the methods coresponds to a specific combination of arguments, for which the function can be specialized to using multiple dispatch. You can see the list by calling a methods function:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia> methods(+)\n# 190 methods for generic function \"+\":                                                                               \n[1] +(x::T, y::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at\n int.jl:87                                                                                                            \n[2] +(c::Union{UInt16, UInt32, UInt64, UInt8}, x::BigInt) in Base.GMP at gmp.jl:528                                   \n[3] +(c::Union{Int16, Int32, Int64, Int8}, x::BigInt) in Base.GMP at gmp.jl:534\n...","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"One other notable difference is that these functions allow using both infix and postfix notation a + b and +(a,b), which is a specialty of elementary functions such as arithmetic operators or set operation such as ∩, ∪, ∈. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The functionality of methods is complemented with the reverse lookup methodswith, which for a given type returns a list of methods that can be called with it as an argument.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia> methodswith(Int)\n[1] +(x::T, y::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at int.jl:87\n[2] +(c::Union{Int16, Int32, Int64, Int8}, x::BigInt) in Base.GMP at gmp.jl:534\n[3] +(c::Union{Int16, Int32, Int64, Int8}, x::BigFloat) in Base.MPFR at mpfr.jl:384\n[4] +(x::BigFloat, c::Union{Int16, Int32, Int64, Int8}) in Base.MPFR at mpfr.jl:379\n[5] +(x::BigInt, c::Union{Int16, Int32, Int64, Int8}) in Base.GMP at gmp.jl:533\n...","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Define function called addone with one argument, that adds 1 to the argument.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function addone(x)\n    x + 1\nend\naddone(1) == 2","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Calling-for-help","page":"Lab","title":"Calling for help","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to better understand some keywords we have encountered so far, we can ask for help in the Julia's REPL itself with the built-in help terminal. Accessing help terminal can be achieved by writing ? with a query keyword after. This searches documentation of all the available source code to find the corresponding keyword. The simplest way to create documentation, that can be accessed in this way, is using so called docstrings, which are multiline strings written above function or type definition. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"\"\"\"\n    polynomial(a, x)\n\nReturns value of a polynomial with coefficients `a` at point `x`.\n\"\"\"\nfunction polynomial(a, x)\n    # function body\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"More on this in lecture 4 about pkg development.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Lookup docstring for the basic functions that we have introduced in the previous exercises: typeof, eltype, length, collect, copy, methods and methodswith. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Try it with others, for example with the subtyping operator <:.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Example docstring for typeof function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"  typeof(x)\n\n  Get the concrete type of x.\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> a = 1//2;\n  \n  julia> typeof(a)\n  Rational{Int64}\n  \n  julia> M = [1 2; 3.5 4];\n  \n  julia> typeof(M)\n  Matrix{Float64} (alias for Array{Float64, 2})","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Testing-waters","page":"Lab","title":"Testing waters","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As the arguments of the polynomial functions are untyped, i.e. they do not specify the allowed types like for example polynomial(a, x::Number) does, the following exercise explores which arguments the function accepts, while giving expected result.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Choose one of the variables af to ac representing polynomial coefficients and try to evaluate it with the polynomial function at point x=3 as before. Lookup the type of coefficient collection variable itself with typeof and the items in the collection with eltype. In this case we allow you to consult your solution with the expandable solution bellow to find out more information about a particular example.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"af = [-19.0, 7.0, -4.0, 6.0]\nat = (-19, 7, -4, 6)\nant = (a₀ = -19, a₁ = 7, a₂ = -4, a₃ = 6)\na2d = [-19 -4; 7 6]\nac = [2i^2 + 1 for i in -2:1]\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(af), eltype(af)\npolynomial(af, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As opposed to the basic definition of a type the array is filled with Float64 types and the resulting value gets promoted as well to the Float64.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(at), eltype(at)\npolynomial(at, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"With round brackets over a fixed length vector we get the Tuple type, which is so called immutable \"array\" of a fixed size (its elements cannot be changed, unless initialized from scratch). Each element can be of a different type, but here we have only one and thus the Tuple is aliased into NTuple. There are some performance benefits for using immutable structure, which will be discussed later.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Defining key=value pairs inside round brackets creates a structure called NamedTuple, which has the same properties as Tuple and furthermore its elements can be conveniently accessed by dot syntax, e.g. ant.a₀.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ant), eltype(ant)\npolynomial(ant, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Defining a 2D array is a simple change of syntax, which initialized a matrix row by row separated by ; with spaces between individual elements. The function returns the same result because linear indexing works in 2d arrays in the column major order.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(a2d), eltype(a2d)\npolynomial(a2d, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The last example shows so called array comprehension syntax, where we define and array of known length using and for loop iteration. Resulting array/vector has integer elements, however even mixed type is possible yielding Any, if there isn't any other common supertype to promote every entry into. (Use ? to look what promote and promote_type does.)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ac), eltype(ac)\npolynomial(ac, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"So far we have seen that polynomial function accepts a wide variety of arguments, however there are some understandable edge cases that it cannot handle.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Consider first the vector/array of characters ach","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"ach = ['1', '2', '3', '4']","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"which themselves have numeric values (you can check by converting them to Int Int('1') or convert(Int, '1')). In spite of that, our untyped function cannot process such input, as there isn't an operation/method that would allow multiplication of Char and Int type. Julia tries to promote the argument types to some common type, however checking the promote_type(Int, Char) returns Any (union of all types), which tells us that the conversion is not possible automatically.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ach), eltype(ach)\npolynomial(ach, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In the stacktrace we can see the location of each function call. If we include the function polynomial from some file poly.jl using include(\"poly.jl\"), we will see that the location changes from REPL[X]:10 to the actual file name.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"By swapping square brackets for round in the array comprehension ac above, we have defined so called generator/iterator, which as opposed to original variable ac does not allocate an array, only the structure that produces it.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"ag = (2i^2 + 1 for i in -2:1)\ntypeof(ag), eltype(ag)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"You may notice that the element type in this case is Any, which means that a function using this generator as an argument cannot specialize based on the type and has to infer it every time an element is generated/returned. We will touch on how this affects performance in one of the later lectures.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(ag, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The problem that we face during evaluation is that generator type is missing the getindex operation, as they are made for situations where the size of the collection may be unknown and the only way of obtaining particular elements is through sequential iteration. Generators can be useful for example when creating batches of data for a machine learning training. We can \"fix\" the situation using collect function, mentioned earlier, however that again allocates an array.","category":"page"},{"location":"lecture_01/lab/#Extending/limiting-the-polynomial-example","page":"Lab","title":"Extending/limiting the polynomial example","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Following up on the polynomial example, let's us expand it a little further in order to facilitate the arguments, that have been throwing exceptions. The first direction, which we will move forward to, is providing the user with more detailed error message when an incorrect type of coefficients has been provided.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Design an if-else condition such that the array of Char example throws an error with custom string message, telling the user what went wrong and printing the incorrect input alongside it. Confirm that we have not broken the functionality of other examples from previous exercise.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINTS:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Throw the ArgumentError(msg) with throw function and string message msg. More details in help mode ? or at the end of this document.\nStrings are defined like this s = \"Hello!\"\nUse string interpolation to create the error message. It allows injecting an expression into a string with the $ syntax b = 1; s = \"Hellow Number $(b)\"\nCompare eltype of the coefficients with Char type.\nThe syntax for if-else:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"if condition\n    println(\"true\") # true branch code\nelse\n    println(\"false\") # false branch code\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Not equal condition can be written as a != b.\nThrowing an exception automatically returns from the function. Use return inside one of the branches to return the correct value.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way is to wrap the whole function inside an if-else condition and returning only when the input is \"correct\" (it will still fail in some cases).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    if eltype(a) != Char\n        accumulator = 0\n        for i in length(a):-1:1\n            accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n        end\n        return accumulator\n    else\n        throw(ArgumentError(\"Invalid coefficients $(a) of type Char!\"))\n    end\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Now this should show our predefined error message. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(ach, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Testing on other examples should pass without errors and give the same output as before.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)\npolynomial(af, x)\npolynomial(at, x)\npolynomial(ant, x)\npolynomial(a2d, x)\npolynomial(ac, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The second direction concerns the limitation to index-able structures, which the generator example is not. For this we will have to rewrite the whole loop in a more functional programming approach using map, anonymous function and other concepts.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Rewrite the following code inside our original polynomial function with map, enumerate and anonymous function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"accumulator = 0\nfor i in length(a):-1:1\n    accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"note: Anonymous functions reminder\nx -> x + 1              # unless the reference is stored it cannot be called\nplusone = x -> x + 1    # the reference can be stored inside a variable\nplusone(x)              # calling with the same syntax","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINTS:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Use enumerate to obtain iterator over a that returns a tuple of ia = (i, aᵢ). With Julia 1-based indexing i starts also from 1 and goes up to length(a).\nPass this into a map with either in-place or predefined anonymous function that does the operation of x^(i-1) * aᵢ.\nUse sum to collect the resulting array into accumulator variable or directly into the return command.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: There is even shorter way how to write this using one line function syntax and recently added options to the sum function. See entry in the help mode ?.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Ordered from the longest to the shortest, here are three examples with the same functionality (and there are definitely many more). Using the map(iterable) do itervar ... end syntax, that creates anonymous function from the block of code.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    powers = map(enumerate(a)) do (i, aᵢ)\n        x^(i-1) * aᵢ\n    end\n    accumulator = sum(powers)\n    return accumulator\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Using the default syntax for map and storing the anonymous into a variable","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    polypow = ia -> x^(ia[1]-1) * ia[2] # \n    powers = map(polypow, enumerate(a))\n    return sum(powers)\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As the function polypow is used only once, there is no need to assign it to a local variable.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    powers = map(ia -> x^(ia[1]-1) * ia[2], enumerate(a))\n    sum(powers)\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Checking the behavior on all the inputs.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)\npolynomial(af, x)\npolynomial(at, x)\npolynomial(ant, x)\npolynomial(a2d, x)\npolynomial(ach, x)\npolynomial(ac, x)\npolynomial(ag, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Using one line function definition and the recently added option of a function in the first argument of sum:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x) = sum(ia -> x^(ia[1]-1) * ia[2], enumerate(a))\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#How-to-use-code-from-other-people","page":"Lab","title":"How to use code from other people","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The script that we have run at the beginning of this lab has created two new files inside the current folder:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"./\n ├── Manifest.toml\n └── Project.toml","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Every folder with a toml file called Project.toml, can be used by Julia's pkg manager into setting so called environment, which contains a list of pkgs to be installed. Setting up or more often called activating an environment can be done either before starting Julia itself by running julia with the --project XXX flag or from within the Julia REPL, by switching to Pkg mode with ] key (similar to the help mode activated by pressing ?) and running command activate.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"So far we have used the general environment (depending on your setup), which by default does not come with any 3rd party packages and includes only the base and standard libraries - already quite powerful on its own. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to find which environment is currently active, run the following:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"pkg> status","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The output of such command usually indicates the general environment located at .julia/ folder (${HOME}/.julia/ or ${APPDATA}/.julia/ in case of Unix/Windows based systems respectively)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"pkg> status\nStatus `~/.julia/environments/v1.6/Project.toml` (empty project)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Generally one should avoid working in the general environment, with the exception of some generic pkgs, such as PkgTemplates.jl, which is used for generating library templates/folder structure like the one above (link), more on this in the lecture on pkg development. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Activate the environment inside the current folder and check that the BenchmarkTools package has been installed. Use BenchmarkTools pkg's @btime to benchmark our polynomial function with the following arguments.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"aexp = ones(10) ./ factorial.(0:9)\nx = 1.1\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINTS:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In pkg mode use the command activate and status to check the presence. \nIn order to import the functionality from other package, lookup the keyword using in the repl help mode ?. \nThe functionality that we want to use is the @btime macro (it acts almost like a function but with a different syntax @macro arg1 arg2 arg3 ...). More on macros in lecture 7.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Compare the output of polynomial(aexp, x) with the value of exp(x), which it approximates.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"note: Broadcasting\nIn the assignment's code, we are using quite ubiquitous concept in Julia called broadcasting or simply the dot-syntax - represented here by ./, factorial.. This concept allows to map both simple arithmetic operations as well as custom functions across arrays, with the added benefit of increased performance, when the broadcasting system can merge operations into a more efficient code. More information can be found in the official documentation or section of our bachelor course.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"There are other options to import a function/macro from a different package, however for now let's keep it simple with the using Module syntax, that brings to the REPL, all the variables/function/macros exported by the BenchmarkTools pkg. If @btime is exported, which it is, it can be accessed without specification i.e. just by calling @btime without the need for BenchmarkTools.@btime. More on the architecture of pkg/module loading in the package developement lecture.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia> using BenchmarkTools\n\njulia> @btime polynomial(aexp, x)\n  97.119 ns (1 allocation: 16 bytes)\n3.004165230550543","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The output gives us the time of execution averaged over multiple runs (the number of samples is defined automatically based on run time) as well as the number of allocations and the output of the function, that is being benchmarked.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: The difference between our approximation and the \"actual\" function value computed as a difference of the two. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(aexp, x) - exp(x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The apostrophes in the previous sentence are on purpose, because implementation of exp also relies on a finite sum, though much more sophisticated than the basic Taylor expansion.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Discussion-and-future-directions","page":"Lab","title":"Discussion & future directions","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Instead of if-else statements that would throw an error for different types, in Julia, we generally see the pattern of typing the function in a way, that for other than desirable types MethodError is emitted with the information about closest matching methods. This is part of the design process in Julia of a function and for the particular functionality of the polynomial example, we can look into the Julia itself, where it has been implemented in the evalpoly function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"methods(evalpoly)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Another avenue, that we have only touched with the BenchmarkTools, is performance and will be further explored in the later lectures.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"With the next lecture focused on typing in Julia, it is worth noting that polynomials lend themselves quite nicely to a definition of a custom type, which can help both readability of the code as well further extensions.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"struct Polynom{C}\n    coefficients::{C}\nend\n\nfunction (p:Polynom)(x)\n    polynomial(p.coefficients, x)\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"","category":"page"},{"location":"lecture_01/lab/#Useful-resources","page":"Lab","title":"Useful resources","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Getting Started tutorial from JuliaLang documentation - Docs\nConverting syntax between MATLAB ↔ Python ↔ Julia - Cheatsheet\nBachelor course for refreshing your knowledge - Course\nStylistic conventions - Style Guide\nReserved keywords - List\nOfficial cheatsheet with basic syntax - link","category":"page"},{"location":"lecture_01/lab/#lab_errors","page":"Lab","title":"Various errors and how to read them","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This section summarizes most commonly encountered types of errors in Julia and how to resolve them or at least understand, what has gone wrong. It expands a little bit the official documentation, which contains the complete list with examples. Keep in mind again, that you can use help mode in the REPL to query error types as well.","category":"page"},{"location":"lecture_01/lab/#MethodError","page":"Lab","title":"MethodError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This type of error is most commonly thrown by Julia's multiple dispatch system with a message like no method matching X(args...), seen in two examples bellow.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"2 * 'a'                       # many candidates\ngetindex((i for i in 1:4), 3) # no candidates","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Both of these examples have a short stacktrace, showing that the execution failed on the top most level in REPL, however if this code is a part of some function in a separate file, the stacktrace will reflect it. What this error tells us is that the dispatch system could not find a method for a given function, that would be suitable for the type of arguments, that it has been given. In the first case Julia offers also a list of candidate methods, that match at least some of the arguments","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"When dealing with basic Julia functions and types, this behavior can be treated as something given and though one could locally add a method for example for multiplication of Char and Int, there is usually a good reason why Julia does not support such functionality by default. On the other hand when dealing with user defined code, this error may suggest the developer, that either the functions are too strictly typed or that another method definition is needed in order to satisfy the desired functionality.","category":"page"},{"location":"lecture_01/lab/#InexactError","page":"Lab","title":"InexactError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This type of error is most commonly thrown by the type conversion system (centered around convert function), informing the user that it cannot exactly convert a value of some type to match arguments of a function being called.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Int(1.2)                      # root cause\nappend!([1,2,3], 1.2)         # same as above but shows the root cause deeper in the stack trace","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In this case the function being Int and the value a floating point. The second example shows InexactError may be caused deeper inside an inconspicuous function call, where we want to extend an array by another value, which is unfortunately incompatible.","category":"page"},{"location":"lecture_01/lab/#ArgumentError","page":"Lab","title":"ArgumentError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As opposed to the previous two errors, ArgumentError can contain user specified error message and thus can serve multiple purposes. It is however recommended to throw this type of error, when the parameters to a function call do not match a valid signature, e.g. when factorial were given negative or non-integer argument (note that this is being handled in Julia by multiple dispatch and specific DomainError).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This example shows a concatenation of two 2d arrays of incompatible sizes 3x3 and 2x2.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"hcat(ones(3,3), zeros(2,2))","category":"page"},{"location":"lecture_01/lab/#KeyError","page":"Lab","title":"KeyError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This error is specific to hash table based objects such as the Dict type and tells the user that and indexing operation into such structure tried to access or delete a non-existent element.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"d = Dict(:a => [1,2,3], :b => [1,23])\nd[:c]","category":"page"},{"location":"lecture_01/lab/#TypeError","page":"Lab","title":"TypeError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Type assertion failure, or calling an intrinsic function (inside LLVM, where code is strictly typed) with incorrect argument type. In practice this error comes up most often when comparing value of a type against the Bool type as seen in the example bellow.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"if 1 end                # calls internally typeassert(1, Bool)\ntypeassert(1, Bool)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to compare inside conditional statements such as if-elseif-else or the ternary operator x ? a : b the condition has to be always of Bool type, thus the example above can be fixed by the comparison operator: if 1 == 1 end (in reality either the left or the right side of the expression contains an expression or a variable to compare against).","category":"page"},{"location":"lecture_01/lab/#UndefVarError","page":"Lab","title":"UndefVarError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"While this error is quite self-explanatory, the exact causes are often quite puzzling for the user. The reason behind the confusion is to do with code scoping, which comes into play for example when trying to access a local variable from outside of a given function or just updating a global variable from within a simple loop. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In the first example we show the former case, where variable is declared from within a function and accessed from outside afterwards.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function plusone(x)\n    uno = 1\n    return x + uno\nend\nuno # defined only within plusone","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Unless there is variable I_am_not_defined in the global scope, the following should throw an error.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"I_am_not_defined","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Often these kind of errors arise as a result of bad code practices, such as long running sessions of Julia having long forgotten global variables, that do not exist upon new execution (this one in particular has been addressed by the authors of the reactive Julia notebooks Pluto.jl).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"For more details on code scoping we recommend particular places in the bachelor course lectures here and there.","category":"page"},{"location":"lecture_01/lab/#ErrorException-and-error-function","page":"Lab","title":"ErrorException & error function","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"ErrorException is the most generic error, which can be thrown/raised just by calling the error function with a chosen string message. As a result developers may be inclined to misuse this for any kind of unexpected behavior a user can run into, often providing out-of-context/uninformative messages.","category":"page"},{"location":"installation/#install","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In order to participate in the course, everyone should install a recent version of Julia together with some text editor of choice. Furthermore during the course we will introduce some best practices of creating/testing and distributing your own Julia code, for which we will require a GitHub account.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"We recommend to install Julia via juliaup. We are using the latest, stable version of Julia (which at the time of this writing is v1.9). Once you have installed juliaup you can get any Julia version you want via:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"juliaup add $JULIA_VERSION\n\n# or more concretely:\njuliaup add 1.9\n\n# but please, just use the latest, stable version","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Now you should be able to start Julia an be greated with the following:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.9.2 (2023-07-05)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\njulia>","category":"page"},{"location":"installation/#Julia-IDE","page":"Installation","title":"Julia IDE","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"There is no one way to install/develop and run Julia, which may be strange users coming from MATLAB, but for users of general purpose languages such as Python, C++ this is quite common. Most of the Julia programmers to date are using","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Visual Studio Code,\nand the corresponding Julia extension.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"This setup is described in a comprehensive step-by-step guide in our bachelor course Julia for Optimization & Learning.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note that this setup is not a strict requirement for the lectures/labs and any other text editor with the option to send code to the terminal such as Vim (+Tmux), Emacs, or Sublime Text will suffice.","category":"page"},{"location":"installation/#GitHub-registration-and-Git-setup","page":"Installation","title":"GitHub registration & Git setup","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"As one of the goals of the course is writing code that can be distributed to others, we recommend a GitHub account, which you can create here (unless you already have one). In order to interact with GitHub repositories, we will be using git. For installation instruction (Windows only) see the section in the bachelor course.","category":"page"},{"location":"lecture_01/demo/#Extensibility-of-the-language","page":"Examples","title":"Extensibility of the language","text":"","category":"section"},{"location":"lecture_01/demo/#DifferentialEquations","page":"Examples","title":"DifferentialEquations","text":"","category":"section"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"A package for solving differential equations, similar to odesolve in Matlab.","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"Example:","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"using DifferentialEquations\nfunction lotka_volterra(du,u,p,t)\n  x, y = u\n  α, β, δ, γ = p\n  du[1] = dx = α*x - β*x*y\n  du[2] = dy = -δ*y + γ*x*y\nend\nu0 = [1.0,1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0]\nprob = ODEProblem(lotka_volterra,u0,tspan,p)\n\nsol = solve(prob)\nusing Plots\nplot(sol)","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"lecture_01/demo/#Measurements","page":"Examples","title":"Measurements","text":"","category":"section"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"A package defining \"numbers with precision\" and complete algebra on these numbers:","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"using Measurements\n\na = 4.5 ± 0.1\nb = 3.8 ± 0.4\n\n2a + b\nsin(a)/cos(a) - tan(a)","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"It also defines recipes for Plots.jl how to plot such numbers.","category":"page"},{"location":"lecture_01/demo/#Starting-ODE-from-an-interval","page":"Examples","title":"Starting ODE from an interval","text":"","category":"section"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"using Measurements\nu0 = [1.0±0.1,1.0±0.01]\n\nprob = ODEProblem(lotka_volterra,u0,tspan,p)\nsol = solve(prob)\nplot(sol,denseplot=false)","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"all algebraic operations are defined, \npasses all grid refinement techniques\nplot uses the correct  plotting for intervals","category":"page"},{"location":"lecture_01/demo/#Integration-with-other-toolkits","page":"Examples","title":"Integration with other toolkits","text":"","category":"section"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"Flux: toolkit for modelling Neural Networks. Neural network is a function.","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"integration with Measurements,\nIntegration with ODE (think of NN as part of the ODE)","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"Turing: Probabilistic modelling toolkit","category":"page"},{"location":"lecture_01/demo/","page":"Examples","title":"Examples","text":"integration with FLux (NN)\ninteration with ODE\nusing arbitrary bijective transformations, Bijectors.jl","category":"page"},{"location":"lecture_01/motivation/#Introduction-to-Scientific-Programming","page":"Motivation","title":"Introduction to Scientific Programming","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"note: Loose definition of Scientific Programming\nScientific programming languages are designed and optimized for implementing mathematical formulas and for computing with matrices.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Examples of Scientific programming languages include ALGOL, APL, Fortran, J, Julia, Maple, MATLAB and R.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Key requirements for a Scientific programming language:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Fast execution of the code (complex algorithms).\nEase of code reuse / code restructuring.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"<figure>\n  <img src=\"julia-set.png\"; max-width: 100%; height: auto;/>\n  <figcaption>\n    <a href=\"https://en.wikipedia.org/wiki/Julia_set\">Julia set</a>.\n    Shamelessly stolen from\n    <a href=\"https://juliagraphics.github.io/ColorSchemes.jl/stable/images/\">Colorschemes.jl</a>.\n  </figcaption>\n</figure>","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In contrast, to general-purpose language Julia has:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"less concern with standalone executable/libraby compilation \nless concern with Application binary interface (ABI)\nless concern with business models (library + header files)\nless concern with public/private separation","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"tip: Example of a scientific task\nIn many applications, we encounter the task of optimization a function given by a routine (e.g. engineering, finance, etc.)using Optim\n\nP(x,y) = x^2 - 3x*y + 5y^2 - 7y + 3   # user defined function\n\nz₀ = [ 0.0\n       0.0 ]     # starting point \n\noptimize(z -> P(z...), z₀, ConjugateGradient())\noptimize(z -> P(z...), z₀, Newton())\noptimize(z -> P(z...), z₀, Newton();autodiff = :forward)\n","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Very simple for a user, very complicated for a programmer. The program should:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"pick the right optimization method (easy by config-like approach)\ncompute gradient (Hessian) of a user function","category":"page"},{"location":"lecture_01/motivation/#Classical-approach:-create-a-*fast*-library-and-flexible-calling-enviroment","page":"Motivation","title":"Classical approach: create a fast library and flexible calling enviroment","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Crucial algorithms (sort, least squares...) are relatively small and well defined. Application of these algorithms to real-world problem is typically not well defined and requires more code. Iterative development. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Think of a problem of repeated execution of similar jobs with different options. Different level ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"binary executable with command-line switches\nbinary executable with configuration file\nscripting language/environment (Read-Eval-Print Loop)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"It is not a strict boundary, increasing expresivity of the configuration file will create a new scripting language.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Ending up in the 2 language problem. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Low-level programming = computer centric\nclose to the hardware\nallows excellent optimization for fast execution\nHigh-level programming = user centric\nrunning code with many different modifications as easily as possible\nallowing high level of abstraction","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In scientific programming, the most well known scripting languages are: Python,  Matlab, R","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"If you care about standard \"configurations\" they are just perfect.  (PyTorch, BLAS)\nYou hit a problem with more complex experiments, such a modifying the internal algorithms.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"The scripting language typically makes decisions (if) at runtime. Becomes slow.","category":"page"},{"location":"lecture_01/motivation/#Examples","page":"Motivation","title":"Examples","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Basic Linear Algebra Subroutines (BLAS)–MKL, OpenBlas–-with bindings (Matlab, NumPy)\nMatlab and Mex (C with pointer arithmetics)\nPython with transcription to C (Cython)","category":"page"},{"location":"lecture_01/motivation/#Convergence-efforts","page":"Motivation","title":"Convergence efforts","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Just-in-time compilation (understands high level and converts to low-level)\nautomatic typing (auto in C++) (extends low-level with high-level concepts)","category":"page"},{"location":"lecture_01/motivation/#Julia-approach:-fresh-thinking","page":"Motivation","title":"Julia approach: fresh thinking","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"(Image: )","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"A dance between specialization and abstraction. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Specialization  allows for custom treatment. The right algorithm for the right circumstance is obtained by Multiple dispatch,\nAbstraction recognizes what remains the same after differences are stripped away. Abstractions in mathematics are captured as code through generic programming.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Why a new language?","category":"page"},{"location":"lecture_01/motivation/#Challenge","page":"Motivation","title":"Challenge","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Translate high-level thinking with as much abstraction as possible into specific fast machine code.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Not so easy!","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"theorem: Indexing array x in Matlab:\nx = [1,2,3]\ny=x(4/2)\ny=x(5/2)In the first case it works, in the second throws an error.type instability \nfunction inde(x,n,m)=x(n/m) can never be fast.\nPoor language design choice!","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Simple solution","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Solved by different floating and integer division operation /,÷\nNot so simple with complex objects, e.g. triangular matrices","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Julia was designed as a high-level language that allows very high level abstract concepts but propagates as much information about the specifics as possible to help the compiler to generate as fast code as possible. Taking lessons from the inability to achieve fast code compilation (mostly from python).","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"(Image: )","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"julia is faster than C?","category":"page"},{"location":"lecture_01/motivation/#Julia-way","page":"Motivation","title":"Julia way","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Design principle: abstraction should have zero runtime  cost","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"flexible type system with strong typing (abstract types)\nmultiple dispatch\nsingle language from high to low levels (as much as possible) optimize execution as much as you can during compile time\nfunctions as symbolic abstraction layers","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"(Image: )","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"AST = Abstract Syntax Tree\nIR = Intermediate Representation","category":"page"},{"location":"lecture_01/motivation/#Teaser-example","page":"Motivation","title":"Teaser example","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Function recursion with arbitrary number of arguments:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"fsum(x) = x\nfsum(x,p...) = x+fsum(p[1],p[2:end]...)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Defines essentially a sum of inputs. Nice generic and abstract concept.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Possible in many languages:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Matlab via nargin, varargin using construction if nargin==1, out=varargin{1}, else out=fsum(varargin{2:end}), end","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Julia solves this if at compile time. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"The generated code can be inspected by macro @code_llvm?","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"fsum(1,2,3)\n@code_llvm fsum(1,2,3)\n@code_llvm fsum(1.0,2.0,3.0)\nfz()=fsum(1,2,3)\n@code_llvm fz()","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Note that each call of fsum generates a new and different function.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Functions can act either as regular functions or like templates in C++. Compiler decides.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"This example is relatively simple, many other JIT languages can optimize such code. Julia allows taking this approach further.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Generality of the code:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"fsum('c',1)\nfsum([1,2],[3,4],[5,6])","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Relies on multiple dispatch of the + function.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"More involved example:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"using Zygote\n\nf(x)=3x+1           # user defined function\n@code_llvm f'(10)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"The simplification was not achieved by the compiler alone.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Julia provides tools for AST and IR code manipulation\nautomatic differentiation via IR manipulation is implemented in Zygote.jl\nin a similar way, debugger is implemented in Debugger.jl\nvery simple to design domain specific language\nusing Turing\nusing StatsPlots\n\n@model function gdemo(x, y)\n    s² ~ InverseGamma(2, 3)\n    m ~ Normal(0, sqrt(s²))\n    x ~ Normal(m, sqrt(s²))\n    y ~ Normal(m, sqrt(s²))\nend","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Such tools allow building a very convenient user experience on abstract level, and reaching very efficient code.","category":"page"},{"location":"lecture_01/motivation/#Reproducibile-research","page":"Motivation","title":"Reproducibile research","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Think about a code that was written some time ago. To run it, you often need to be able to have the same version of the language it was written for. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Standard way language freezes syntax and guarantees some back-ward compatibility (Matlab), which prevents future improvements\nJulia approach allows easy recreation of the environment in which the code was developed. Every project (e.g. directory) can have its own environment","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"tip: Environment\nIs an independent set of packages that can be local to an individual project or shared and selected by name.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"tip: Package\nA package is a source tree with a standard layout providing functionality that can be reused by other Julia projects.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"This allows  Julia to be a  rapidly evolving ecosystem with frequent changes due to:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"built-in package manager\nswitching between multiple versions of packages","category":"page"},{"location":"lecture_01/motivation/#Package-manager","page":"Motivation","title":"Package manager","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"implemented by Pkg.jl\nsource tree have their structure defined by a convention\nhave its own mode in REPL\nallows adding packages for using (add) or development (dev)\nsupporting functions for creation (generate) and activation (activate) and many others","category":"page"},{"location":"lecture_01/motivation/#Julia-from-user's-point-of-view","page":"Motivation","title":"Julia from user's point of view","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"compilation of everything to as specialized as possible\nvery fast code\nslow interaction (caching...)\ngenerating libraries is harder \nthink of fsum, \neverything is \".h\"  (Eigen library)\ndebugging is different to matlab/python\nextensibility, Multiple dispatch = multi-functions\nallows great extensibility and code composition\nnot (yet) mainstream thinking\nJulia is not Object-oriented\nJulia is (not pure) functional language","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img class=\"docs-light-only\"; src=\"https://raw.githubusercontent.com/JuliaTeachingCTU/JuliaCTUGraphics/master/logo/Scientific-Programming-in-Julia-logo.svg\"; alt=\"Scientific Programming in Julia logo\"; max-width: 100%; height: auto>\n<img class=\"docs-dark-only\"; src=\"https://raw.githubusercontent.com/JuliaTeachingCTU/JuliaCTUGraphics/master/logo/Scientific-Programming-in-Julia-logo-dark.svg\"; alt=\"Scientific Programming in Julia logo\"; max-width: 100%; height: auto;>","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nENV[\"GKSwstype\"] = \"100\"\ngr()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Scientific Programming requires the highest performance but we also want to write very high level code to enable rapid prototyping and avoid error prone, low level implementations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Julia programming language is designed with exactly those requirements of scientific computing in mind.  In this course we will show you how to make use of the tools and advantages that jit-compiled Julia provides over dynamic, high-level languages like Python or lower level languages like C++.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<figure>\n  <img src=\"assets/dual.png\"; max-width: 100%; height: auto;/>\n  <figcaption>\n    Learn the power of abstraction.\n    Example: The essence of <a href=\"https://juliadiff.org/ForwardDiff.jl/dev/dev/how_it_works/\">forward mode</a> automatic differentiation.\n  </figcaption>\n</figure>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Before joining the course, consider reading the following two blog posts to figure out if Julia is a language in which you want to invest your time.","category":"page"},{"location":"","page":"Home","title":"Home","text":"What is great about Julia.\nWhat is bad about Julia.","category":"page"},{"location":"#What-will-you-learn?","page":"Home","title":"What will you learn?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First and foremost you will learn how to think julia - meaning how write fast, extensible, reusable, and easy-to-read code using things like optional typing, multiple dispatch, and functional programming concepts.  The later part of the course will teach you how to use more advanced concepts like language introspection, metaprogramming, and symbolic computing. Amonst others you will implement your own automatic differetiation (the backbone of modern machine learning) package based on these advanced techniques that can transform intermediate representations of Julia code.","category":"page"},{"location":"#Organization","page":"Home","title":"Organization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This course webpage contains all information about the course that you need, including lecture notes, lab instructions, and homeworks. The official format of the course is 2+2 (2h lectures/2h labs per week) for 4 credits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The official course code is: B0M36SPJ and the timetable for the winter semester 2022 can be found here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The course will be graded based on points from your homework (max. 20 points) and points from a final project (max. 30 points).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below is a table that shows which lectures have homeworks (and their points).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Homework 1 2 3 4 5 6 7 8 9 10 11 12 13\nPoints 2 2 2 2 2 2 2 2 - 2 - 2 -","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hint: The first few homeworks are easier. Use them to fill up your points.","category":"page"},{"location":"#final_project","page":"Home","title":"Final project","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The final project will be individually agreed on for each student. Ideally you can use this project to solve a problem you have e.g. in your thesis, but don't worry - if you cannot come up with an own project idea, we will suggest one to you. More info and project suggestion can be found here.","category":"page"},{"location":"#Grading","page":"Home","title":"Grading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Your points from the homeworks and the final project are summed and graded by the standard grading scale below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grade A B C D E F\nPoints 45-50 40-44 35-39 30-34 25-29 0-25","category":"page"},{"location":"#emails","page":"Home","title":"Teachers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"– E-mail Room Role\nTomáš Pevný pevnak@protonmail.ch KN:E-406 Lecturer\nVašek Šmídl smidlva1@fjfi.cvut.cz KN:E-333 Lecturer\nMatěj Zorek zorekmat@fel.cvut.cz KN:E-333 Lab Instructor\nNiklas Heim heimnikl@fel.cvut.cz KN:E-333 Lab Instructor","category":"page"},{"location":"#Prerequisites","page":"Home","title":"Prerequisites","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are no hard requirements to take the course, but if you are not at all familiar with Julia we recommend you to take Julia for Optimization and Learning before enrolling in this course. The Functional Programming course also contains some helpful concepts for this course. And knowledge about computer hardware, namely basics of how CPU works, how it interacts with memory through caches, and basics of multi-threadding certainly helps.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Official documentation\nWorkflow tips, and what is new in v1.9\nThink Julia: How to Think Like a Computer Scientist\nFrom Zero to Julia!\nWikiBooks\nJustin Krumbiel's excellent introduction to the package manager.\njuliadatascience.io contains an excellent introduction to plotting with Makie.\nMIT Course: Julia Computation\nTim Holy's Advanced Scientific Computing","category":"page"},{"location":"how_to_submit_hw/#homeworks","page":"Homework submission","title":"Homework submission","text":"","category":"section"},{"location":"how_to_submit_hw/","page":"Homework submission","title":"Homework submission","text":"This document should describe the homework submission procedure.","category":"page"}]
}
