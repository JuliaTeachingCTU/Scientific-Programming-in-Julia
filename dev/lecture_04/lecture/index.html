<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_04/lecture/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/onlinestats.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design Patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Package development, Unit test &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a><ul class="internal"><li><a class="tocitem" href="#Namespaces-and-modules"><span>Namespaces and modules</span></a></li><li><a class="tocitem" href="#Namespaces-and-scoping"><span>Namespaces &amp; scoping</span></a></li><li><a class="tocitem" href="#Packages"><span>Packages</span></a></li><li><a class="tocitem" href="#Project-environments"><span>Project environments</span></a></li><li><a class="tocitem" href="#Project-Manifest"><span>Project Manifest</span></a></li><li><a class="tocitem" href="#Package-manager"><span>Package manager</span></a></li><li><a class="tocitem" href="#Package-hygiene-workflow"><span>Package hygiene - workflow</span></a></li><li><a class="tocitem" href="#Unit-testing,-/test"><span>Unit testing, /test</span></a></li><li><a class="tocitem" href="#Documentation-and-Style,-/docs"><span>Documentation &amp; Style, /docs</span></a></li><li><a class="tocitem" href="#Precompilation"><span>Precompilation</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">4: Package development, Unit test &amp; CI</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/2023W/docs/src/lecture_04/lecture.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="pkg_lecture"><a class="docs-heading-anchor" href="#pkg_lecture">Package development</a><a id="pkg_lecture-1"></a><a class="docs-heading-anchor-permalink" href="#pkg_lecture" title="Permalink"></a></h1><p>Organization of the code is more important with the increasing size of the project and the number of contributors and users. Moreover, it will become essential when different codebases are expected to be combined and reused. </p><ul><li>Julia was designed from the beginning to encourage code reuse across different codebases as possible</li><li>Julia ecosystem lives on a <em>namespace</em>. From then, it builds projects and environments.</li></ul><h2 id="Namespaces-and-modules"><a class="docs-heading-anchor" href="#Namespaces-and-modules">Namespaces and modules</a><a id="Namespaces-and-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Namespaces-and-modules" title="Permalink"></a></h2><p>Namespace logically separate fragments of source code so that they can be developed independently without affecting each other. If I define a function in one namespace, I will still be able to define another function in a different namespace even though both functions have the same name.</p><ul><li><p>prevents confusion when common words are used in different meaning:</p><ul><li>Too general name of functions &quot;create&quot;, &quot;extend&quot;, &quot;loss&quot;, </li><li>or data &quot;X&quot;, &quot;y&quot; (especially in mathematics, think of π)</li><li>may not be an issue if used with different types</li></ul></li><li><p><em>Modules</em> is Julia syntax for a namespace</p></li></ul><p>Example:</p><pre><code class="language-julia hljs">module MySpace
function test1()
  println(&quot;test1&quot;)
end
function test2()
  println(&quot;test2&quot;)
end
export test1
#include(&quot;filename.jl&quot;)
end</code></pre><p>Function <code>include</code> copies content of the file to this location (will be part of the module).</p><p>Creates functions:</p><pre><code class="language-julia hljs">MySpace.test1
MySpace.test2</code></pre><p>For easier manipulation, these functions can be &quot;exported&quot; to be exposed to the outer world (another namespace).</p><p>Keyword: <code>using</code> exposes the exported functions and structs:</p><pre><code class="language-julia hljs">using .MySpace</code></pre><p>The dot means that the module was defined in this scope.</p><p>Keyword: <code>import</code> imports function with availability to redefine it.</p><p>Combinations:</p><table><tr><th style="text-align: right">usecase</th><th style="text-align: right">results</th></tr><tr><td style="text-align: right">using MySpace</td><td style="text-align: right">MySpace.test1</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">MySpace.test2</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">test1</td></tr><tr><td style="text-align: right">using MySpace: test1</td><td style="text-align: right">test1</td></tr><tr><td style="text-align: right">import MySpace</td><td style="text-align: right">MySpace.test1*</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">MySpace.test2*</td></tr><tr><td style="text-align: right">import MySpace: test1</td><td style="text-align: right">test1*</td></tr><tr><td style="text-align: right">import MySpace: test2</td><td style="text-align: right">test2*</td></tr></table><ul><li>symbol &quot;*&quot; denotes functions that can be redefined</li></ul><pre><code class="language-julia hljs"> using  .MySpace: test1
 test1()=println(&quot;new test&quot;)
 import  .MySpace: test1
 test1()=println(&quot;new test&quot;)</code></pre><h3 id="Conflicts:"><a class="docs-heading-anchor" href="#Conflicts:">Conflicts:</a><a id="Conflicts:-1"></a><a class="docs-heading-anchor-permalink" href="#Conflicts:" title="Permalink"></a></h3><p>When importing/using functions with name that is already imported/used from another module:</p><ul><li>the imported functions/structs are invalidated. </li><li>both functions has to be acessed by their full names.</li></ul><p>Resolution:</p><ul><li>It may be easier to cherry pick only the functions we need (rather than importing all via <code>using</code>)</li><li>rename some function using keyword <code>as</code><pre><code class="language-julia hljs">import MySpace2: test1 as t1</code></pre></li></ul><h3 id="Submodules"><a class="docs-heading-anchor" href="#Submodules">Submodules</a><a id="Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Submodules" title="Permalink"></a></h3><p>Modules can be used or included within other modules:</p><pre><code class="language-julia hljs">module A
   a=1;
end
module B
   module C
       c = 2
   end
   b = C.c # you can read from C    (by reference)
   using ..A: a
   # a= b # but not write to A
end;</code></pre><p>REPL of Julia is a module called &quot;Main&quot;. </p><ul><li>modules are not copied, but referenced, i.e. <code>B.b===B.C.c</code></li><li>including one module twice (from different packages) is not a problem</li><li>Upcoming Julia 1.9 has the ability to change the contextual module in the REPL: <code>REPL.activate(TestPackage)</code></li></ul><h3 id="Revise.jl"><a class="docs-heading-anchor" href="#Revise.jl">Revise.jl</a><a id="Revise.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Revise.jl" title="Permalink"></a></h3><p>The fact that Julia can redefine a function in a Module by importing it is used by package <code>Revise.jl</code> to synchronize REPL with a module or file.</p><p>So far, we have worked in REPL. If you have a file that is loaded and you want to modify it, you would need to either:</p><ol><li>reload the whole file, or</li><li>copy the changes to REPL</li></ol><p><code>Revise.jl</code> does the latter automatically.</p><p>Example demo:</p><pre><code class="language-julia hljs">using Revise.jl
includet(&quot;example.jl&quot;)</code></pre><p>Works with: </p><ul><li>any package loaded with <code>import</code> or <code>using</code>, </li><li>script  loaded with <code>includet</code>, </li><li>Base julia itself (with Revise.track(Base))</li><li>standard libraries (with, e.g., using Unicode; Revise.track(Unicode))</li></ul><p>Does not work with variables!</p><p><strong>How it works</strong>: monitors source code for changes and then does:</p><pre><code class="language-julia hljs">for def in setdiff(oldexprs, newexprs)
    # `def` is an expression that defines a method.
    # It was in `oldexprs`, but is no longer present in `newexprs`--delete the method.
    delete_methods_corresponding_to_defexpr(mod, def)
end
for def in setdiff(newexprs, oldexprs)
    # `def` is an expression for a new or modified method. Instantiate it.
    Core.eval(mod, def)
end</code></pre><h2 id="Namespaces-and-scoping"><a class="docs-heading-anchor" href="#Namespaces-and-scoping">Namespaces &amp; scoping</a><a id="Namespaces-and-scoping-1"></a><a class="docs-heading-anchor-permalink" href="#Namespaces-and-scoping" title="Permalink"></a></h2><p>Every module introduces a new global scope. </p><ul><li><p>Global scope</p><ul><li>No variable or function is expected to exist  outside of it</li><li>Every module is equal to a global scope (no single &quot;global&quot; exists)</li><li>The REPL has a global module called <code>Main</code></li></ul></li><li><p>Local scope</p><p>Variables in Julia do not need to be explicitly declared, they are created by assignments: <code>x=1</code>. </p><p>In local scope, the compiler checks if variable <code>x</code> does not exist outside. We have seen:</p><pre><code class="language-julia hljs">x=1
f(y)=x+y</code></pre><p>The rules for local scope determine how to treat <strong>assignment</strong> of <code>x</code>. If local <code>x</code> exists, it is used, if it does not:</p><ul><li>in <em>hard</em> scope: new local <code>x</code> is created</li><li>in <em>soft</em> scope: checks if <code>x</code> exists outside (global)<ul><li>if not: new local <code>x</code> is created</li><li>if yes: the split is REPL/non-interactive:<ul><li>REPL: global <code>x</code> is used (convenience, as of 1.6)</li><li>non-interactive: local <code>x</code> is created</li></ul></li></ul></li></ul></li></ul><ul><li>keyword <code>local</code> and <code>global</code> can be used to specify which variable to use</li></ul><p>From documentation:</p><table><tr><th style="text-align: left">Construct</th><th style="text-align: left">Scope type</th><th style="text-align: left">Allowed within</th></tr><tr><td style="text-align: left"><code>module</code>, <code>baremodule</code></td><td style="text-align: left">global</td><td style="text-align: left">global</td></tr><tr><td style="text-align: left"><code>struct</code></td><td style="text-align: left">local (soft)</td><td style="text-align: left">global</td></tr><tr><td style="text-align: left"><code>for</code>, <code>while</code>, <code>try</code></td><td style="text-align: left">local (soft)</td><td style="text-align: left">global, local</td></tr><tr><td style="text-align: left"><code>macro</code></td><td style="text-align: left">local (hard)</td><td style="text-align: left">global</td></tr><tr><td style="text-align: left">functions, <code>do</code> blocks, <code>let</code> blocks, comprehensions, generators</td><td style="text-align: left">local (hard)</td><td style="text-align: left">global, local</td></tr></table><p>Question:</p><pre><code class="language-julia hljs">x=1
f()= x=3
f()
@show x;</code></pre><pre><code class="language-julia hljs">x = 1
for _ = 1:1
   x=3
end
@show x;</code></pre><h2 id="Packages"><a class="docs-heading-anchor" href="#Packages">Packages</a><a id="Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Packages" title="Permalink"></a></h2><p>Package is a source tree with a standard layout. It provides a module and thus can be loaded with <code>include</code> or <code>using</code>.</p><p>Minimimal package:</p><pre><code class="nohighlight hljs">PackageName/
├── src/
│   └── PackageName.jl
├── Project.toml</code></pre><p>Contains:</p><ul><li><p><code>Project.toml</code> file describing basic properties:</p><ul><li><code>Name</code>, does not have to be unique (federated package sources)</li><li><code>UUID</code>, has to be unique (generated automatically)</li><li>optionally [deps], [targets],...</li></ul></li><li><p>file <code>src/PackageName.jl</code> that defines module <code>PackageName</code> which is executed when loaded.</p></li></ul><p>Many other optional directories:</p><ul><li>directory tests/,  (almost mandatory)</li><li>directory docs/    (common)</li><li>directory scripts/, examples/,... (optional)</li></ul><p>The package typically loads other modules that form package dependencies.</p><h2 id="Project-environments"><a class="docs-heading-anchor" href="#Project-environments">Project environments</a><a id="Project-environments-1"></a><a class="docs-heading-anchor-permalink" href="#Project-environments" title="Permalink"></a></h2><p>Is a package that does not contain <code>Name</code> and <code>UUID</code> in <code>Project.toml</code>. It&#39;s used when you don&#39;t need to create a package for your work. It&#39;s created by <code>activate some/path</code> in REPL package mode. </p><h2 id="Project-Manifest"><a class="docs-heading-anchor" href="#Project-Manifest">Project Manifest</a><a id="Project-Manifest-1"></a><a class="docs-heading-anchor-permalink" href="#Project-Manifest" title="Permalink"></a></h2><p>Both package and environment can contain an additional file <code>Manifest.toml</code>. This file tracks full dependency tree of a project including versions of the packages on which it depends.</p><p>for example:</p><pre><code class="language-toml hljs"># This file is machine-generated - editing it directly is not advised

[[AbstractFFTs]]
deps = [&quot;LinearAlgebra&quot;]
git-tree-sha1 = &quot;485ee0867925449198280d4af84bdb46a2a404d0&quot;
uuid = &quot;621f4979-c628-5d54-868e-fcf4e3e8185c&quot;
version = &quot;1.0.1&quot;

[[AbstractTrees]]
git-tree-sha1 = &quot;03e0550477d86222521d254b741d470ba17ea0b5&quot;
uuid = &quot;1520ce14-60c1-5f80-bbc7-55ef81b5835c&quot;
version = &quot;0.3.4&quot;</code></pre><p>Content of files <code>Project.toml</code> and <code>Manifest.toml</code> are maintained by PackageManager.</p><h2 id="Package-manager"><a class="docs-heading-anchor" href="#Package-manager">Package manager</a><a id="Package-manager-1"></a><a class="docs-heading-anchor-permalink" href="#Package-manager" title="Permalink"></a></h2><p>Handles both packages and projects:</p><ul><li><p>creating a project <code>]generate PkgName</code></p></li><li><p>adding an existing project <code>add PkgName</code> or <code>add https://github.com/JuliaLang/Example.jl</code></p><p>Names are resolved by Registrators (public or private).</p></li><li><p>removing <code>]rm PkgName</code></p></li><li><p>updating <code>]update</code></p></li><li><p>developing <code>]dev http://...</code> </p><ul><li><code>add</code> treats packages as being finished, version handling pkg manager. Precompiles!</li><li><code>dev</code> leaves all operations on the package to the user (git versioning, etc.). Always read content of files</li></ul></li></ul><p>By default these operations are related to environment <code>.julia/environments/v1.8</code></p><p>E.g. running and updating will update packages in <code>Manifest.toml</code> in this directory. What if the update breaks functionality of some project package that uses special features?</p><p>There can and should be more than one environment!</p><p>Project environments are based on files with installed packages.</p><ul><li><p>switching by <code>]activate Path</code> - creates <code>Project.toml</code> if not existing</p></li><li><p>from that moment, all package modifications will be relevant only to this project!</p></li><li><p>when switching to a new project <code>]instantiate</code> will prepare (download and precompile) the environment</p><ul><li>creates <code>Manifest.toml</code> = list of all exact versions of all packages </li></ul></li><li><p>which Packages are visible is determined by <code>LOAD_PATH</code></p><ul><li>typically contaings default libraries and default environment</li><li>it is different for REPL and Pkg.tests ! No default env. in tests. </li></ul></li></ul><h2 id="Package-hygiene-workflow"><a class="docs-heading-anchor" href="#Package-hygiene-workflow">Package hygiene - workflow</a><a id="Package-hygiene-workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Package-hygiene-workflow" title="Permalink"></a></h2><div class="admonition is-category-theorem"><header class="admonition-header">Potential danger</header><div class="admonition-body"><p>Package dependencies may not be compatible: </p><ul><li>package <code>A</code> requires <code>C@&lt;0.2</code></li><li>package <code>B</code> requires <code>C@&gt;0.3</code></li><li>what should happen when <code>]add A</code> and <code>add B</code>?</li></ul></div></div><ul><li>keep your &quot;@v#.#&quot; as clean as possible (recommended are only debugging/profiling packages)</li><li>use packages as much as you can, even for short work with scripts <code>]activate .</code><ul><li>adding a package existing elsewhere is cheap (global cache)</li></ul></li><li>if do you not wish to store any files just test random tricks of a cool package: <code>]activate --temp</code></li></ul><h3 id="Package-development-with-Revise"><a class="docs-heading-anchor" href="#Package-development-with-Revise">Package development with Revise</a><a id="Package-development-with-Revise-1"></a><a class="docs-heading-anchor-permalink" href="#Package-development-with-Revise" title="Permalink"></a></h3><p>Developing a package with interactive test/development:</p><ol><li>Create a package/module at one directory <code>MainPackage</code></li><li>Create a script at another directory <code>MainScript</code>, and activate it <code>]activate .</code></li><li><code>dev MainPackage</code> in the <code>MainScript</code> environment<ul><li>Revise.jl will watch the <code>MainPackage</code> so it is always up to date</li><li>in <code>dev</code> mode you have full control over commits etc.</li></ul></li></ol><h2 id="Unit-testing,-/test"><a class="docs-heading-anchor" href="#Unit-testing,-/test">Unit testing, /test</a><a id="Unit-testing,-/test-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-testing,-/test" title="Permalink"></a></h2><p>Without explicit keywords for checking constructs (think missing functions in interfaces), the good quality of the code is guaranteed by detailed unit testing.</p><ul><li><p>each package should have directory <code>/test</code></p></li><li><p>file <code>/test/runtest.jl</code> is run by the command <code>]test</code> of the package manager</p><p>this file typically contains <code>include</code> of other tests</p></li><li><p>no formal structure of tests is prescribed</p><ul><li>test files are just ordinary julia scripts</li><li>user is free to choose what to test and how (freedom x formal rules)</li></ul></li><li><p>testing functionality is supported by macros <code>@test</code> and <code>@teststet</code></p><pre><code class="nohighlight hljs">@testset &quot;trigonometric identities&quot; begin
    θ = 2/3*π
    @test sin(-θ) ≈ -sin(θ)
    @test cos(-θ) ≈ cos(θ)
    @test sin(2θ) ≈ 2*sin(θ)*cos(θ)
    @test cos(2θ) ≈ cos(θ)^2 - sin(θ)^2
end;</code></pre></li></ul><p>Testset is a collection of tests that will be run and summarized in a common report.</p><ul><li><p>Testsets can be nested: testsets in testsets</p></li><li><p>tests can be in loops or functions</p><pre><code class="language-julia hljs">for i=1:10
   @test a[i]&gt;0
end</code></pre></li><li><p>Useful macro <code>≈</code> checks for equality with given tolerance</p><pre><code class="language-julia hljs">a=5+1e-8
@test a≈5
@test a≈5 atol=1e-10</code></pre></li></ul><ul><li><p>@testset resets RNG to Random.GLOBAL_SEED before and after the test for repeatability </p><p>The same results of RNG are not guaranteed between Julia versions!</p></li><li><p>Test coverage: package <code>Coverage.jl</code></p></li><li><p>Can be run automatically by continuous integration, e.g. GitHub actions</p></li><li><p>integration in VSCode test via package <code>TestItems.jl</code> </p></li></ul><h2 id="Documentation-and-Style,-/docs"><a class="docs-heading-anchor" href="#Documentation-and-Style,-/docs">Documentation &amp; Style, /docs</a><a id="Documentation-and-Style,-/docs-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-and-Style,-/docs" title="Permalink"></a></h2><p>A well written package is reusable if it is well documented. </p><p>The simpliest kind of documentation is the docstring:</p><pre><code class="language-julia hljs">&quot;Auxiliary function for printing a hello&quot;
hello()=println(&quot;hello&quot;)

&quot;&quot;&quot;
More complex function that adds π to input:
- x is the input argument (itemize)

Can be written in latex: ``x \leftarrow x + \pi``
&quot;&quot;&quot;
addπ(x) = x+π</code></pre><p>Yieds:</p><div class="admonition is-success"><header class="admonition-header">Renders as</header><div class="admonition-body"><p>More complex function that adds π to input:</p><ul><li>x is the input argument (itemize)</li></ul><p>Can be written in latex: <span>$x \leftarrow x + \pi$</span></p></div></div><p>Structure of the document</p><pre><code class="nohighlight hljs">PackageName/
├── src/
│   └── SourceFile.jl
├── docs/
│    ├── build/
│    ├── src/
│    └── make.jl
...</code></pre><p>Where the line-by-line documentation is in the source files.</p><ul><li><code>/docs/src</code> folder can contain more detailed information: introductory pages, howtos, tutorials, examples</li><li>running <code>make.jl</code> controls which pages are generated in what form (html or latex) documentation in the /build  directory</li><li>automated with GitHub actions</li></ul><p>Documentation is generated by the julia code.</p><ul><li>code in documentation can be evaluated</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x=3</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @show x</code><code class="nohighlight hljs ansi" style="display:block;">x = 3
3</code></pre><ul><li><p>documentation can be added by code:</p><pre><code class="language-julia hljs">struct MyType
    value::String
end

Docs.getdoc(t::MyType) = &quot;Documentation for MyType with value $(t.value)&quot;

x = MyType(&quot;x&quot;)
y = MyType(&quot;y&quot;)</code></pre><p>See <code>?x</code> and <code>?y</code>. </p><p>It uses the same very standard building blocks: multiple dispatch.</p></li></ul><h2 id="Precompilation"><a class="docs-heading-anchor" href="#Precompilation">Precompilation</a><a id="Precompilation-1"></a><a class="docs-heading-anchor-permalink" href="#Precompilation" title="Permalink"></a></h2><p>By default, every package is precompiled when loading and stored in compiled form in a cache.</p><p>If it defines methods that extend previously defined (e.g. from Base), it may affect already loaded packages which need to be recompiled as well. May take time.</p><p>Julia has a tracking mechanism that stores information about the whole graph of dependencies. </p><p>Faster code can be achieved by the <code>precompile</code> directive:</p><pre><code class="language-julia hljs">module FSum

fsum(x) = x
fsum(x,p...) = x+fsum(p[1],p[2:end]...)

precompile(fsum,(Float64,Float64,Float64))
end</code></pre><p>Can be investigated using <code>MethodAnalysis</code>.</p><pre><code class="language-julia hljs">using MethodAnalysis
mi =methodinstances(fsum)</code></pre><p>Useful packages:</p><ul><li><p><code>PackageCompiler.jl</code> has three main purposes:</p><ul><li>Creating custom sysimages for reduced latency when working locally with packages that has a high startup time.</li><li>Creating &quot;apps&quot; which are a bundle of files including an executable that can be sent and run on other machines without Julia being installed on that machine.</li><li>Creating a relocatable C library bundle form of Julia code.</li></ul></li></ul><ul><li><code>AutoSysimages.jl</code> allows easy generation of precompiles images - reduces package loading</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_03/lecture/">« Lecture</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 29 September 2023 10:41">Friday 29 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
