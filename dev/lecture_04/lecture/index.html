<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_04/lecture/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages development, Unit Tests &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a><ul class="internal"><li><a class="tocitem" href="#Namespaces-and-modules"><span>Namespaces and modules</span></a></li><li><a class="tocitem" href="#Namespaces-and-scoping"><span>Namespaces &amp; scoping</span></a></li><li><a class="tocitem" href="#Packages"><span>Packages</span></a></li><li><a class="tocitem" href="#Project-environments"><span>Project environments</span></a></li><li><a class="tocitem" href="#Package/Project-manager"><span>Package/Project manager</span></a></li><li><a class="tocitem" href="#Unit-testing,-/test"><span>Unit testing, /test</span></a></li><li><a class="tocitem" href="#Documentation-and-Style,-/docs"><span>Documentation &amp; Style, /docs</span></a></li><li><a class="tocitem" href="#Precompilation"><span>Precompilation</span></a></li></ul></li><li><a class="tocitem" href="../lab/">Lab</a></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Benchmarking, profiling, and performance gotchas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Language introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_06/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_06/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_07/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_07/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Introduction to automatic differentiation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/lecture/">Lecture</a></li></ul></li><li><span class="tocitem">9: Manipulating intermediate representation</span></li><li><span class="tocitem">10: Different levels of parallel programming</span></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><span class="tocitem">12: Uncertainty propagation in ODE</span></li><li><span class="tocitem">13: Learning ODE from data</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">4: Packages development, Unit Tests &amp; CI</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_04/lecture.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="pkg_lecture"><a class="docs-heading-anchor" href="#pkg_lecture">Package development</a><a id="pkg_lecture-1"></a><a class="docs-heading-anchor-permalink" href="#pkg_lecture" title="Permalink"></a></h1><p>Organization of the code is more important with the increasing size of the project and the number of contributors and users. Moreover, it will become essential when different codebases are expected to be combined and reused. </p><ul><li>Julia was designed from the beginning to encourage code reuse across different codebases as possible</li><li>Julia ecosystem lives on a <em>namespace</em>. From then, it builds projects and environments.</li></ul><h2 id="Namespaces-and-modules"><a class="docs-heading-anchor" href="#Namespaces-and-modules">Namespaces and modules</a><a id="Namespaces-and-modules-1"></a><a class="docs-heading-anchor-permalink" href="#Namespaces-and-modules" title="Permalink"></a></h2><p>Namespace logically separate fragments of source code so that they can be developed independently without affecting each other. If I define a function in one namespace, I will still be able to define another function in a different namespace even though both functions have the same name.</p><ul><li><p>prevents confusion when common words are used in different meaning:</p><ul><li>Too general name of functions &quot;create&quot;, &quot;extend&quot;, &quot;loss&quot;, </li><li>or data &quot;X&quot;, &quot;y&quot; (especially in mathematics, think of π)</li><li>may not be an issue if used with different types</li></ul></li><li><p><em>Modules</em> is Julia syntax for a namespace</p></li></ul><p>Example:</p><pre><code class="language-julia hljs">module MySpace
function test1()
  println(&quot;test1&quot;)
end
function test2()
  println(&quot;test2&quot;)
end
export test1
#include(&quot;filename.jl&quot;)
end</code></pre><p>Function <code>include</code> copies content of the file to this location (will be part of the module).</p><p>Creates functions:</p><pre><code class="language-julia hljs">MySpace.test1
MySpace.test2</code></pre><p>For easier manipulation, these functions can be &quot;exported&quot; to be exposed to the outer world (another namespace).</p><p>Keyword: <code>using</code> exposes the exported functions and structs:</p><pre><code class="language-julia hljs">using .MySpace</code></pre><p>The dot means that the module was defined in this scope.</p><p>Keyword: <code>import</code> imports function with availability to redefine it.</p><p>Combinations:</p><table><tr><th style="text-align: right">usecase</th><th style="text-align: right">results</th></tr><tr><td style="text-align: right">using MySpace</td><td style="text-align: right">MySpace.test1</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">MySpace.test2</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">test1</td></tr><tr><td style="text-align: right">using MySpace: test1</td><td style="text-align: right">test1</td></tr><tr><td style="text-align: right">import MySpace</td><td style="text-align: right">MySpace.test1*</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">MySpace.test2*</td></tr><tr><td style="text-align: right">import MySpace: test1</td><td style="text-align: right">test1*</td></tr><tr><td style="text-align: right">import MySpace: test2</td><td style="text-align: right">test2*</td></tr></table><ul><li>symbol &quot;*&quot; denotes functions that can be redefined</li></ul><pre><code class="language-julia hljs"> using  MySpace: test1
 test1()=println(&quot;new test&quot;)
 import  MySpace: test1
 test1()=println(&quot;new test&quot;)</code></pre><h3 id="Conflicts:"><a class="docs-heading-anchor" href="#Conflicts:">Conflicts:</a><a id="Conflicts:-1"></a><a class="docs-heading-anchor-permalink" href="#Conflicts:" title="Permalink"></a></h3><p>When importing/using functions with name that that is already imported/used from another module:</p><ul><li>the imported functions/structs are invalidated. </li><li>both function has to be acessed by their full names.</li></ul><p>Resoluton:</p><ul><li>It may be easier to cherry pick only the functions we need (rather than importing all via <code>using</code>)</li><li>remane some function using keyword <code>as</code><pre><code class="language-julia hljs">import MySpace2: test1 as t1</code></pre></li></ul><h3 id="Submodules"><a class="docs-heading-anchor" href="#Submodules">Submodules</a><a id="Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Submodules" title="Permalink"></a></h3><p>Modules can be used or included withing another modules:</p><pre><code class="language-julia hljs">module A
   a=1;
end
module B
   module C
       c = 2
   end
   b = C.c   
   using ..A: a
end;</code></pre><p>REPL of Julia is a module called &quot;Main&quot;. </p><ul><li>modules are not copied, but referenced, i.e. <code>B.b===B.C.c</code></li><li>including one module twice (from different packages) is not a problem</li></ul><h3 id="Revise.jl"><a class="docs-heading-anchor" href="#Revise.jl">Revise.jl</a><a id="Revise.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Revise.jl" title="Permalink"></a></h3><p>The fact that julia can redefine a function in a Module by importing it is used by package <code>Revise.jl</code> to synchronize REPL with a module or file.</p><p>So far, we have worked in REPL. If you have a file that is loaded and you want to modify it, you would need to either:</p><ol><li>reload the whole file, or</li><li>copy the changes to REPL</li></ol><p><code>Revise.jl</code> do the latter automatically.</p><p>Example demo:</p><pre><code class="language-julia hljs">using Revise.jl
includet(&quot;example.jl&quot;)</code></pre><p>Works with: </p><ul><li>any package loaded with <code>import</code> or <code>using</code>, </li><li>script  loaded with <code>includet</code>, </li><li>Base julia itself (with Revise.track(Base))</li><li>standard libraries (with, e.g., using Unicode; Revise.track(Unicode))</li></ul><p>Does not work with variables!</p><p><strong>How it works</strong>: monitors source code for changes and then do</p><pre><code class="language-julia hljs">for def in setdiff(oldexprs, newexprs)
    # `def` is an expression that defines a method.
    # It was in `oldexprs`, but is no longer present in `newexprs`--delete the method.
    delete_methods_corresponding_to_defexpr(mod, def)
end
for def in setdiff(newexprs, oldexprs)
    # `def` is an expression for a new or modified method. Instantiate it.
    Core.eval(mod, def)
end</code></pre><h2 id="Namespaces-and-scoping"><a class="docs-heading-anchor" href="#Namespaces-and-scoping">Namespaces &amp; scoping</a><a id="Namespaces-and-scoping-1"></a><a class="docs-heading-anchor-permalink" href="#Namespaces-and-scoping" title="Permalink"></a></h2><p>Every module introduces a new global scope. </p><ul><li><p>Global scope</p><ul><li>No variable or function is expected to exist  outside of it</li><li>Every module is equal a global scope (no single &quot;global&quot; exists)</li><li>The REPL is a global module called <code>Main</code></li></ul></li><li><p>Local scope</p><p>Variables in Julia do not need to be explcitely declared, they are created by assignments: <code>x=1</code>. </p><p>In local scope, the compiler checks if variable <code>x</code> does not exists outside. We have seen:</p><pre><code class="language-julia hljs">x=1
f(y)=x+y</code></pre><p>The rules for local scope determine how to treat assignment of <code>x</code>. If local <code>x</code> exists, it is used, if it does not:</p><ul><li>in <em>hard</em> scope: new local <code>x</code> is created</li><li>in <em>soft</em> scope: checks if <code>x</code> exists outside (global)<ul><li>if not: new local <code>x</code> is created</li><li>if yes: the split is REPL/non-interactive:<ul><li>REPL: global <code>x</code> is used (convenience, as of 1.6)</li><li>non-interactive: local <code>x</code> is created</li></ul></li></ul></li></ul></li></ul><ul><li>keyword <code>local</code> and <code>global</code> can be used to specify which variable to use</li></ul><p>From documentation:</p><table><tr><th style="text-align: left">Construct</th><th style="text-align: left">Scope type</th><th style="text-align: left">Allowed within</th></tr><tr><td style="text-align: left"><code>module</code>, <code>baremodule</code></td><td style="text-align: left">global</td><td style="text-align: left">global</td></tr><tr><td style="text-align: left"><code>struct</code></td><td style="text-align: left">local (soft)</td><td style="text-align: left">global</td></tr><tr><td style="text-align: left"><code>for</code>, <code>while</code>, <code>try</code></td><td style="text-align: left">local (soft)</td><td style="text-align: left">global, local</td></tr><tr><td style="text-align: left"><code>macro</code></td><td style="text-align: left">local (hard)</td><td style="text-align: left">global</td></tr><tr><td style="text-align: left">functions, <code>do</code> blocks, <code>let</code> blocks, comprehensions, generators</td><td style="text-align: left">local (hard)</td><td style="text-align: left">global, local</td></tr></table><p>Question:</p><pre><code class="language-julia hljs">x=1
f()= x=3
f()
@show x;</code></pre><pre><code class="language-julia hljs">x = 1
for _ = 1:1
   x=3
end
@show x;</code></pre><h2 id="Packages"><a class="docs-heading-anchor" href="#Packages">Packages</a><a id="Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Packages" title="Permalink"></a></h2><p>Package is a source tree with a standard layout. Can be loaded with <code>include</code> or <code>using</code> and provides a module.</p><p>Minimimal project:</p><pre><code class="nohighlight hljs">PackageName/
├── src/
│   └── PackageName.jl
├── Project.toml</code></pre><p>Contains:</p><ul><li><p><code>Project.toml</code> file describing basic properties:</p><ul><li><code>Name</code>, does not have to be Unique (federated package sources)</li><li><code>UUID</code>, has to be uniques (generated automatically)</li><li>optionally [deps], [targets],...</li></ul></li><li><p>file <code>src/PackageName.jl</code> that defines module <code>PackageName</code> which is executed when loaded.</p></li></ul><p>Many other optional directories:</p><ul><li>directory tests/,  (almost mandatory)</li><li>directory docs/    (common)</li><li>directory scripts/, examples/,... (optional)</li></ul><p>The package typically loads other modules that form package dependencies.</p><h2 id="Project-environments"><a class="docs-heading-anchor" href="#Project-environments">Project environments</a><a id="Project-environments-1"></a><a class="docs-heading-anchor-permalink" href="#Project-environments" title="Permalink"></a></h2><p>Is a package that contains additional file <code>Manifest.toml</code>. This file tracks full dependency tree of a project including versions of the packages on which it depends.</p><p>for example:</p><pre><code class="language-toml hljs"># This file is machine-generated - editing it directly is not advised

[[AbstractFFTs]]
deps = [&quot;LinearAlgebra&quot;]
git-tree-sha1 = &quot;485ee0867925449198280d4af84bdb46a2a404d0&quot;
uuid = &quot;621f4979-c628-5d54-868e-fcf4e3e8185c&quot;
version = &quot;1.0.1&quot;

[[AbstractTrees]]
git-tree-sha1 = &quot;03e0550477d86222521d254b741d470ba17ea0b5&quot;
uuid = &quot;1520ce14-60c1-5f80-bbc7-55ef81b5835c&quot;
version = &quot;0.3.4&quot;</code></pre><p>Content of files <code>Project.toml</code> and <code>Manifest.toml</code> are maintained by PackageManager.</p><h2 id="Package/Project-manager"><a class="docs-heading-anchor" href="#Package/Project-manager">Package/Project manager</a><a id="Package/Project-manager-1"></a><a class="docs-heading-anchor-permalink" href="#Package/Project-manager" title="Permalink"></a></h2><p>Handles both packages and projects:</p><ul><li><p>creating a project <code>]generate PkgName</code></p></li><li><p>adding an existing project <code>add PkgName</code> or <code>add https://github.com/JuliaLang/Example.jl</code></p><p>Names are resolved by Registrators (public or private).</p></li><li><p>removing <code>]rm PkgName</code></p></li><li><p>updating <code>]update</code></p></li><li><p>developing <code>]dev http://...</code> </p><p>Always reads the actual content of files. <code>Add</code> creates a precompiled blob.</p></li></ul><p>By default these operations are related to environment <code>.julia/environments/v1.6</code></p><p>E.g. running an updating will update packages in <code>Manifest.toml</code> in this directory. What if the update breaks functionality of some project package that uses special features?</p><p>There can be more than one environment!</p><p>Any package can define its own project environment with a list of dependencies.</p><ul><li><p>switching by <code>]activate Path</code></p></li><li><p>from that moment, all package modifications will be relevant only to this project!</p></li><li><p>when switching to a new project <code>]instantiate</code> will prepare (download and precompile) the environment</p></li><li><p>which Packages are visible is determined by <code>LOAD_PATH</code></p><ul><li>typically contaings default libraries and default environment</li><li>it is different for REPL and Pkg.tests ! No default env. in tests.</li></ul></li></ul><h2 id="Unit-testing,-/test"><a class="docs-heading-anchor" href="#Unit-testing,-/test">Unit testing, /test</a><a id="Unit-testing,-/test-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-testing,-/test" title="Permalink"></a></h2><p>Without explicit keywords for checking constructs (think missing functions in interfaces), the good quality of the code is guaranteed by detailed unit testing.</p><ul><li><p>each package should have directory <code>/test</code></p></li><li><p>file <code>/test/runtest.jl</code> is run by command <code>]test</code> of the package manager</p><p>this file typically contains <code>include</code> of other tests</p></li><li><p>no formal structure of tests is prescribed</p><ul><li>test files are just ordinary julia scripts</li><li>user is free to choose what to test and how (freedom x formal rules)</li></ul></li><li><p>testing functionality is supported by macros <code>@test</code> and <code>@teststet</code></p><pre><code class="nohighlight hljs">@testset &quot;trigonometric identities&quot; begin
    θ = 2/3*π
    @test sin(-θ) ≈ -sin(θ)
    @test cos(-θ) ≈ cos(θ)
    @test sin(2θ) ≈ 2*sin(θ)*cos(θ)
    @test cos(2θ) ≈ cos(θ)^2 - sin(θ)^2
end;</code></pre></li></ul><p>Testset is a collection of tests that will be run and summarized in a common report.</p><ul><li><p>Testsets can be nested: testsets in testsets</p></li><li><p>tests can be in loops or functions</p><pre><code class="language-julia hljs">for i=1:10
   @test a[i]&gt;0
end</code></pre></li><li><p>Useful macro <code>≈</code> checks for equality with given tolerance</p><pre><code class="language-julia hljs">a=5+1e-8
@test a≈5
@test a≈5 atol=1e-10</code></pre></li></ul><ul><li><p>@testset resets RNG to Random.GLOBAL_SEED before and after the test for repeatability </p><p>The same results of RNG are not guaranteed between Julia versions!</p></li><li><p>Test coverage: package Coverage.jl  </p></li><li><p>Can be run automatically by continuous integration, e.g. GitHub actions</p></li></ul><h2 id="Documentation-and-Style,-/docs"><a class="docs-heading-anchor" href="#Documentation-and-Style,-/docs">Documentation &amp; Style, /docs</a><a id="Documentation-and-Style,-/docs-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-and-Style,-/docs" title="Permalink"></a></h2><p>A well written package is reusable if it is well documented. </p><p>The simpliest kind of documentation is the docstring:</p><pre><code class="language-julia hljs">&quot;Auxiliary function for printing a hello&quot;
hello()=println(&quot;hello&quot;)

&quot;&quot;&quot;
More complex function that adds π to input:
- x is the input argument (itemize)

Can be written in latex: ``x \leftarrow x + \pi``
&quot;&quot;&quot;
addπ(x) = x+π</code></pre><p>Yieds:</p><div class="admonition is-success"><header class="admonition-header">Renders as</header><div class="admonition-body"><p>More complex function that adds π to input:</p><ul><li>x is the input argument (itemize)</li></ul><p>Can be written in latex: <span>$x \leftarrow x + \pi$</span></p></div></div><p>Structure of the document</p><pre><code class="nohighlight hljs">PackageName/
├── src/
│   └── SourceFile.jl
├── docs/
│    ├── build/
│    ├── src/
│    └── make.jl
...</code></pre><p>Where the line-by-line documentation is in the source files.</p><ul><li><code>/docs/src</code> folder can contain more detailed information: introductory pages, howtos, tutorials, examples</li><li>running <code>make.jl</code> controls which pages are generated in what form (html or latex) documentation in the /build  directory</li><li>automated with GitHub actions</li></ul><p>Documentation is generated by the julia code.</p><ul><li><p>code in documentation can be evaluated</p><pre><code class="language- hljs">x=3
@show x</code></pre></li><li><p>documentation can be added by code:</p><pre><code class="language-julia hljs">struct MyType
    value::String
end

Docs.getdoc(t::MyType) = &quot;Documentation for MyType with value $(t.value)&quot;

x = MyType(&quot;x&quot;)
y = MyType(&quot;y&quot;)</code></pre><p>See <code>?x</code> and <code>?y</code>. </p><p>It uses the same very standdr building blocks: multiple dispatch.</p></li></ul><h2 id="Precompilation"><a class="docs-heading-anchor" href="#Precompilation">Precompilation</a><a id="Precompilation-1"></a><a class="docs-heading-anchor-permalink" href="#Precompilation" title="Permalink"></a></h2><p>By default, every package is precompiled when loading and stored in compiled form in a cache.</p><p>If it defines methods that extend previously defined (e.g. from Base), it may affect already loaded packages which need to be recompiled as well. May take time.</p><p>Julia has a tracking mechanism that stores information about the whole graph of dependencies. </p><p>Faster code can be achieved by the <code>precompile</code> directive:</p><pre><code class="language-julia hljs">module FSum

fsum(x) = x
fsum(x,p...) = x+fsum(p[1],p[2:end]...)

precompile(fsum,(Float64,Float64,Float64))
end</code></pre><p>Can be investigated using <code>MethodAnalysis</code>.</p><pre><code class="language-julia hljs">using MethodAnalysis
mi =methodinstances(fsum)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_03/hw/">« Homework</a><a class="docs-footer-nextpage" href="../lab/">Lab »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 12 November 2021 06:33">Friday 12 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
