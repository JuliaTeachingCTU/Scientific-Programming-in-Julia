<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · Scientific Programming in Julia</title><meta name="title" content="- · Scientific Programming in Julia"/><meta property="og:title" content="- · Scientific Programming in Julia"/><meta property="twitter:title" content="- · Scientific Programming in Julia"/><meta name="description" content="Documentation for Scientific Programming in Julia."/><meta property="og:description" content="Documentation for Scientific Programming in Julia."/><meta property="twitter:description" content="Documentation for Scientific Programming in Julia."/><meta property="og:url" content="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_09/ircode/"/><meta property="twitter:url" content="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_09/ircode/"/><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_09/ircode/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/onlinestats.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of type system &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Package development, unit tests &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Performance benchmarking</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Lanuage introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_06/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_06/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_07/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_07/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Automatic differentiation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_08/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_08/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Intermediate representation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture/">Lecture</a></li><li><a class="tocitem" href="../lab/">Lab</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/2023W/docs/src/lecture_09/ircode.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>These notes are from poking around <code>Core.Compiler</code> to see, how they are different from working just with <code>CodeInfo</code> and <code>IRTools.jl</code>. Notes are mainly around IRCode. Why there is a <code>Core.Compiler.IRCode</code> when there was <code>Core.CodeInfo</code>? Seems to be historical reasons. At the beginning, Julia did not have any intermediate representation and code directly emitted LLVM. Then, it has received an <code>CodeInfo</code> as in intermediate representation. <code>IRCode</code> seems like an evolution of <code>CodeInfo</code>. <code>Core.Compiler</code> works mostly with <code>IRCode</code>, but the <code>IRCode</code>  can be converted to the <code>CodeInfo</code> and the other way around. <code>IRCode</code> seems to be designed more for implementation of various optimisation phases. Personal experience tells me it is much nicer to work with even on the low level. </p><p>Throughout the explanation, we assume that <code>Core.Compiler</code> was imported as <code>CC</code> to decrease the typing load.</p><p>Let&#39;s play with a simple silly function </p><pre><code class="language-julia hljs">
function foo(x,y) 
  z = x * y 
  z + sin(x)
end</code></pre><h3 id="IRCode"><a class="docs-heading-anchor" href="#IRCode">IRCode</a><a id="IRCode-1"></a><a class="docs-heading-anchor-permalink" href="#IRCode" title="Permalink"></a></h3><p>We can obtain <code>CC.IRCode</code></p><pre><code class="language-julia hljs">import Core.Compiler as CC
(ir, rt) = only(Base.code_ircode(foo, (Float64, Float64), optimize_until = &quot;compact 1&quot;))</code></pre><p>which returns <code>Core.Compiler.IRCode</code> in <code>ir</code> and return-type <code>Float64</code> in <code>rt</code>. The output might look like </p><pre><code class="nohighlight hljs">julia&gt; (ir, rt) = only(Base.code_ircode(foo, (Float64, Float64), optimize_until = &quot;compact 1&quot;))
  1─ %1 = (_2 * _3)::Float64                                                    
  │   %2 = Main.sin(_2)::Float64                                                 
  │   %3 = (%1 + %2)::Float64                                                    
  └──      return %3                                                             
   =&gt; Float64
</code></pre><p>Options of <code>optimize_until</code> are <code>compact 1</code>, <code>compact 2</code>, <code>nothing.</code> I do not see a difference between <code>compact 2</code> and <code>compact 2</code>.</p><p>The IRCode structure is defined as</p><pre><code class="nohighlight hljs">struct IRCode
    stmts::InstructionStream
    argtypes::Vector{Any}
    sptypes::Vector{VarState}
    linetable::Vector{LineInfoNode}
    cfg::CFG
    new_nodes::NewNodeStream
    meta::Vector{Expr}
end</code></pre><p>where</p><ul><li><code>stmts</code> is a stream of instruction (more in this below)</li><li><code>argtypes</code> holds types of arguments of the function whose <code>IRCode</code> we have obtained</li><li><code>sptypes</code> is a vector of <code>VarState</code>. It seems to be related to parameters of types</li><li><code>linetable</code> is a table of unique lines in the source code from which statements </li><li><code>cfg</code> holds control flow graph, which contains building blocks and jumps between them</li><li><code>new_nodes</code> is an infrastructure that can be used to insert new instructions to the existing <code>IRCode</code> . The idea behind is that since insertion requires a renumbering all statements, they are put in a separate queue. They are put to correct position with a correct <code>SSANumber</code>  by calling <code>compact!</code>.</li><li><code>meta</code> is something.</li></ul><p>Before going further, let&#39;s take a look on <code>InstructionStream</code> defined as </p><pre><code class="language-julia hljs">struct InstructionStream
    inst::Vector{Any}
    type::Vector{Any}
    info::Vector{CallInfo}
    line::Vector{Int32}
    flag::Vector{UInt8}
end</code></pre><p>where </p><ul><li><code>inst</code> is a vector of instructions, stored as <code>Expr</code>essions. The allowed fields in <code>head</code> are described <a href="https://docs.julialang.org/en/v1/devdocs/ast/#Expr-types">here</a></li><li><code>type</code> is the type of the value returned by the corresponding statement</li><li><code>CallInfo</code> is ???some info???</li><li><code>line</code> is an index into <code>IRCode.linetable</code> identifying from which line in source code the statement comes from</li><li><code>flag</code>  are some flags providing additional information about the statement.</li></ul><pre><code class="nohighlight hljs">- `0x01 &lt;&lt; 0` = statement is marked as `@inbounds`
- `0x01 &lt;&lt; 1` = statement is marked as `@inline`
- `0x01 &lt;&lt; 2` = statement is marked as `@noinline`
- `0x01 &lt;&lt; 3` = statement is within a block that leads to `throw` call
- `0x01` &lt;&lt; 4 = statement may be removed if its result is unused, in particular it is thus be both pure and effect free
- `0x01 &lt;&lt; 5-6 = &lt;unused&gt;`
- `0x01 &lt;&lt; 7 = &lt;reserved&gt;` has out-of-band info</code></pre><p>For the above <code>foo</code> function, the InstructionStream looks like</p><pre><code class="language-julia hljs">julia&gt; DataFrame(flag = ir.stmts.flag, info = ir.stmts.info, inst = ir.stmts.inst, line = ir.stmts.line, type = ir.stmts.type)
4×5 DataFrame
 Row │ flag   info                               inst          line   type
     │ UInt8  CallInfo                           Any           Int32  Any
─────┼────────────────────────────────────────────────────────────────────────
   1 │   112  MethodMatchInfo(MethodLookupResu…  _2 * _3           1  Float64
   2 │    80  MethodMatchInfo(MethodLookupResu…  Main.sin(_2)      2  Float64
   3 │   112  MethodMatchInfo(MethodLookupResu…  %1 + %2           2  Float64
   4 │     0  NoCallInfo()                       return %3         2  Any</code></pre><p>We can index into the statements as <code>ir.stmts[1]</code>, which provides a &quot;view&quot; into the vector. To obtain the first instruction, we can do <code>ir.stmts[1][:inst]</code>.</p><p>The IRCode is typed, but the fields can contain <code>Any</code>. It is up to the user to provide corrrect types of the output and there is no helper functions to perform typing. A workaround is shown in the Petite Diffractor project. Julia&#39;s sections of the manual https://docs.julialang.org/en/v1/devdocs/ssair/ and seems incredibly useful. The IR form they talk about seems to be <code>Core.Compiler.IRCode</code>. </p><p>It seems to be that it is possible to insert IR instructions into the it structure by queuing that to the field <code>stmts</code> and then call <code>compact!</code>, which would perform the heavy machinery of relabeling everything.</p><h4 id="Example-of-modifying-the-function-through-IRCode"><a class="docs-heading-anchor" href="#Example-of-modifying-the-function-through-IRCode">Example of modifying the function through IRCode</a><a id="Example-of-modifying-the-function-through-IRCode-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-modifying-the-function-through-IRCode" title="Permalink"></a></h4><p>Below is an MWE that tries to modify the IRCode of a function and execute it.  The goal is to change the function <code>foo</code>  to <code>fooled</code>.</p><pre><code class="language-julia hljs">import Core.Compiler as CC
using Core: SSAValue, GlobalRef, ReturnNode

function foo(x,y) 
  z = x * y 
  z + sin(x)
end

function fooled(x,y) 
  z = x * y 
  z + sin(x) + cos(y)
end

(ir, rt) = only(Base.code_ircode(foo, (Float64, Float64), optimize_until = &quot;compact 1&quot;));
nr = CC.insert_node!(ir, 2, CC.NewInstruction(Expr(:call, Core.GlobalRef(Main, :cos), Core.Argument(3)), Float64))
nr2 = CC.insert_node!(ir, 4,  CC.NewInstruction(Expr(:call, GlobalRef(Main, :+), SSAValue(3), nr), Float64))
CC.setindex!(ir.stmts[4],  ReturnNode(nr2), :inst)
ir = CC.compact!(ir)
irfooled = Core.OpaqueClosure(ir)
irfooled(1.0, 2.0) == fooled(1.0, 2.0)</code></pre><p>So what we did?</p><ol><li><code>(ir, rt) = only(Base.code_ircode(foo, (Float64, Float64), optimize_until = &quot;compact 1&quot;))</code> obtain the <code>IRCode</code> of the function <code>foo</code> when called with both arguments being <code>Float64</code>. <code>rt</code> contains the return type of the </li><li>A new instruction <code>cos</code> is inserted to the <code>ir</code> by  <code>Core.Compiler.insert_node!</code>, which takes as an argument an <code>IRCode</code>, position (2 in our case), and new instruction. The new instruction is created by <code>NewInstruction</code> accepting as an input expression <code>Expr</code> and a return type. Here, we force it to be <code>Float64</code>, but ideally it should be inferred. (This would be the next stage). Or, may-be, we can run it through type inference? . The new instruction is added to the <code>ir.new_nodes</code> instruction stream and obtain a new SSAValue returned in <code>nr</code>, which can be then used further.</li><li>We add one more instruction <code>+</code> that uses output of the instruction we add in step 2, <code>nr</code> and SSAValue from statement 3 of the original IR (at this moment, the IR is still numbered with respect to the old IR, the renumbering will happen later.)  The output of this second instruction is returned in <code>nr2</code>.</li><li>Then, we rewrite the return statement to return <code>nr2</code> instead of <code>SSAValue(3)</code>.</li><li><code>ir = CC.compact!(ir)</code> is superimportant since it moves the newly added statements from <code>ir.new_stmts</code> to <code>ir.stmts</code> and importantly renumbers <code>SSAValues.</code> <em>Even though the function is mutating, the mutation here is meant that the argument is changed, but the new correct IRCode is returned and therefore has to be reassigned.</em></li><li>The function is created through <code>OpaqueClosure.</code></li><li>The last line certifies that the function do what it should do.</li></ol><p>There is no infrastructure to make the above manipulation transparent, like is the case of @generated function and codeinfo. It is possible to hook through generated function by converting the IRCode to untyped CodeInfo, in which case you do not have to bother with typing.</p><h4 id="How-to-obtain-code-info-the-proper-way?"><a class="docs-heading-anchor" href="#How-to-obtain-code-info-the-proper-way?">How to obtain code info the proper way?</a><a id="How-to-obtain-code-info-the-proper-way?-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-obtain-code-info-the-proper-way?" title="Permalink"></a></h4><p>This is the way code info is obtained in the diffractor.</p><pre><code class="language-julia hljs">mthds = Base._methods_by_ftype(sig, -1, world)
match = only(mthds)

mi = Core.Compiler.specialize_method(match)
ci = Core.Compiler.retrieve_code_info(mi, world)</code></pre><h3 id="CodeInfo"><a class="docs-heading-anchor" href="#CodeInfo">CodeInfo</a><a id="CodeInfo-1"></a><a class="docs-heading-anchor-permalink" href="#CodeInfo" title="Permalink"></a></h3><p><code>IRTools.jl</code> are great for modifying <code>CodeInfo</code>. I have found two tools for modifying <code>IRCode</code> and  I wonder if they have been abandoned because they were both dead ends or because of lack of human labor. I am also aware of Also, <a href="https://nbviewer.org/gist/tkf/d4734be24d2694a3afd669f8f50e6b0f/00_notebook.ipynb">this</a> is quite cool play with IRStuff.</p><p>Resources</p><ul><li>https://vchuravy.dev/talks/licm/</li><li><a href="https://github.com/JuliaCompilerPlugins/CompilerPluginTools.jl">CompilerPluginTools</a> </li><li><a href="https://github.com/JuliaCompilerPlugins/CodeInfoTools.jl">CodeInfoTools.jl</a>.</li><li>TKF&#39;s <a href="https://github.com/tkf/ShowCode.jl">CodeInfo.jl</a> is nice for visualization of the IRCode</li><li>Diffractor is an awesome source of howto. For example function <code>my_insert_node!</code> in <code>src/stage1/hacks.jl</code></li><li>https://nbviewer.org/gist/tkf/d4734be24d2694a3afd669f8f50e6b0f/00_notebook.ipynb</li><li>https://github.com/JuliaCompilerPlugins/Mixtape.jl</li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Thursday 30 November 2023 17:41">Thursday 30 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
