<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lab · Scientific Programming in Julia</title><meta name="title" content="Lab · Scientific Programming in Julia"/><meta property="og:title" content="Lab · Scientific Programming in Julia"/><meta property="twitter:title" content="Lab · Scientific Programming in Julia"/><meta name="description" content="Documentation for Scientific Programming in Julia."/><meta property="og:description" content="Documentation for Scientific Programming in Julia."/><meta property="twitter:description" content="Documentation for Scientific Programming in Julia."/><meta property="og:url" content="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_03/lab/"/><meta property="twitter:url" content="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_03/lab/"/><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_03/lab/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/onlinestats.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of type system &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture/">Lecture</a></li><li class="is-active"><a class="tocitem" href>Lab</a><ul class="internal"><li><a class="tocitem" href="#Part-I:-Female-and-Male-Sheep"><span>Part I: Female &amp; Male Sheep</span></a></li><li><a class="tocitem" href="#Part-II:-A-new,-parametric-type-hierarchy"><span>Part II: A new, parametric type hierarchy</span></a></li></ul></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Package development, unit tests &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Performance benchmarking</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Lanuage introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_06/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_06/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_07/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_07/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Automatic differentiation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_08/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_08/hw/">Homework</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">3: Design patterns</a></li><li class="is-active"><a href>Lab</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lab</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/2023W/docs/src/lecture_03/lab.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="lab03"><a class="docs-heading-anchor" href="#lab03">Lab 3: Predator-Prey Agents</a><a id="lab03-1"></a><a class="docs-heading-anchor-permalink" href="#lab03" title="Permalink"></a></h1><p>In this lab we will look at two different ways of extending our agent simulation to take into account that animals can have two different sexes: <em>female</em> and <em>male</em>.</p><p>In the first part of the lab you will re-use the code from <a href="../../lecture_02/lab/#lab02">lab 2</a> and create a new type of sheep (<code>⚥Sheep</code>) which has an additional field <em>sex</em>. In the second part you will redesign the type hierarchy from scratch using parametric types to make this agent system much more flexible and <em>julian</em>.</p><h2 id="Part-I:-Female-and-Male-Sheep"><a class="docs-heading-anchor" href="#Part-I:-Female-and-Male-Sheep">Part I: Female &amp; Male Sheep</a><a id="Part-I:-Female-and-Male-Sheep-1"></a><a class="docs-heading-anchor-permalink" href="#Part-I:-Female-and-Male-Sheep" title="Permalink"></a></h2><p>The code from lab 2 that you will need in the first part of this lab can be found <a href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_02/Lab02Ecosystem.jl">here</a>.</p><p>The goal of the first part of the lab is to demonstrate the <em>forwarding method</em> (which is close to how things are done in OOP) by implementing a sheep that can have two different sexes and can only reproduce with another sheep of opposite sex.</p><p>This new type of sheep needs an additonal field <code>sex::Symbol</code> which can be either <code>:male</code> or <code>:female</code>. In OOP we would simply inherit from <code>Sheep</code> and create a <code>⚥Sheep</code> with an additional field. In Julia there is no inheritance - only subtyping of abstract types. As you cannot inherit from a concrete type in Julia, we will have to create a wrapper type and forward all necessary methods. This is typically a sign of unfortunate type tree design and should be avoided, but if you want to extend a code base by an unforeseen type this forwarding of methods is a nice work-around.  Our <code>⚥Sheep</code> type will simply contain a classic <code>sheep</code> and a <code>sex</code> field</p><pre><code class="language-julia hljs">struct ⚥Sheep &lt;: Animal
    sheep::Sheep
    sex::Symbol
end
⚥Sheep(id, e=4.0, Δe=0.2, pr=0.8, pf=0.6, sex=rand(Bool) ? :female : :male) = ⚥Sheep(Sheep(id,e,Δe,pr,pf),sex)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep = ⚥Sheep(1)</code><code class="nohighlight hljs ansi" style="display:block;">Main.⚥Sheep(🐑 #1 E=4.0 ΔE=0.2 pr=0.8 pf=0.6, :male)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep.sheep</code><code class="nohighlight hljs ansi" style="display:block;">🐑 #1 E=4.0 ΔE=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep.sex</code><code class="nohighlight hljs ansi" style="display:block;">:male</code></pre><p>Instead of littering the whole code with custom getters/setters Julia allows us to overload the <code>sheep.field</code> behaviour by implementing custom <code>getproperty</code>/<code>setproperty!</code> methods.</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise:</header>
<div class="admonition-body"><p>Implement custom <code>getproperty</code>/<code>setproperty!</code> methods which allow to access the <code>Sheep</code> inside the <code>⚥Sheep</code> as if we would not be wrapping it.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs"># NOTE: the @forward macro we will discuss in a later lecture is based on this

function Base.getproperty(s::⚥Sheep, name::Symbol)
    if name in fieldnames(Sheep)
        getfield(s.sheep,name)
    else
        getfield(s,name)
    end
end

function Base.setproperty!(s::⚥Sheep, name::Symbol, x)
    if name in fieldnames(Sheep)
        setfield!(s.sheep,name,x)
    else
        setfield!(s,name,x)
    end
end</code></pre></p></details><p>You should be able to do the following with your overloads now</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep = ⚥Sheep(1)</code><code class="nohighlight hljs ansi" style="display:block;">Main.⚥Sheep(🐑 #1 E=4.0 ΔE=0.2 pr=0.8 pf=0.6, :male)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep.id</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep.sex</code><code class="nohighlight hljs ansi" style="display:block;">:male</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep.energy += 1</code><code class="nohighlight hljs ansi" style="display:block;">5.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep</code><code class="nohighlight hljs ansi" style="display:block;">Main.⚥Sheep(🐑 #1 E=5.0 ΔE=0.2 pr=0.8 pf=0.6, :male)</code></pre><p>In order to make the <code>⚥Sheep</code> work with the rest of the code we only have to forward the <code>eat!</code> method</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; eat!(s::⚥Sheep, food, world) = eat!(s.sheep, food, world);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sheep = ⚥Sheep(1);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; grass = Grass(2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; world = World([sheep,grass])</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Agent}
  🌿 #2 70% grown
  Main.⚥Sheep(🐑 #1 E=4.0 ΔE=0.2 pr=0.8 pf=0.6, :male)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eat!(sheep, grass, world)</code><code class="nohighlight hljs ansi" style="display:block;">0</code></pre><p>and implement a custom <code>reproduce!</code> method with the behaviour that we want.</p><p>However, the extension of <code>Sheep</code> to <code>⚥Sheep</code> is a very object-oriented approach. With a little bit of rethinking, we can build a much more elegant solution that makes use of Julia&#39;s powerful parametric types.</p><h2 id="Part-II:-A-new,-parametric-type-hierarchy"><a class="docs-heading-anchor" href="#Part-II:-A-new,-parametric-type-hierarchy">Part II: A new, parametric type hierarchy</a><a id="Part-II:-A-new,-parametric-type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Part-II:-A-new,-parametric-type-hierarchy" title="Permalink"></a></h2><p>First, let us note that there are two fundamentally different types of agents in our world: animals and plants. All species such as grass, sheep, wolves, etc. can be categorized as one of those two.  We can use Julia&#39;s powerful, <em>parametric</em> type system to define one large abstract type for all agents <code>Agent{S}</code>. The <code>Agent</code> will either be an <code>Animal</code> or a <code>Plant</code> with a type parameter <code>S</code> which will represent the specific animal/plant species we are dealing with.</p><p>This new type hiearchy can then look like this:</p><pre><code class="language-julia hljs">abstract type Species end

abstract type PlantSpecies &lt;: Species end
abstract type Grass &lt;: PlantSpecies end

abstract type AnimalSpecies &lt;: Species end
abstract type Sheep &lt;: AnimalSpecies end
abstract type Wolf &lt;: AnimalSpecies end

abstract type Agent{S&lt;:Species} end

# instead of Symbols we can use an Enum for the sex field
# using an Enum here makes things easier to extend in case you
# need more than just binary sexes and is also more explicit than
# just a boolean
@enum Sex female male</code></pre><p>Now we can create a <em>concrete</em> type <code>Animal</code> with the two parametric types and the fields that we already know from lab 2.</p><pre><code class="language-julia hljs">mutable struct Animal{A&lt;:AnimalSpecies} &lt;: Agent{A}
    const id::Int
    energy::Float64
    const Δenergy::Float64
    const reprprob::Float64
    const foodprob::Float64
    const sex::Sex
end</code></pre><p>To create an instance of <code>Animal</code> we have to specify the parametric type while constructing it</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Animal{Wolf}(1,5,5,1,1,female)</code><code class="nohighlight hljs ansi" style="display:block;">Main.Animal{Main.Wolf}(1, 5.0, 5.0, 1.0, 1.0, Main.female)</code></pre><p>Note that we now automatically have animals of any species without additional work. Starting with the overload of the <code>show</code> method we can already see that we can abstract away a lot of repetitive work into the type system. We can implement <em>one single</em> <code>show</code> method for all animal species!</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise:</header>
<div class="admonition-body"><p>Implement <code>Base.show(io::IO, a::Animal)</code> with a single method for all <code>Animal</code>s. You can get the pretty (unicode) printing of the <code>Species</code> types with another overload like this: <code>Base.show(io::IO, ::Type{Sheep}) = print(io,&quot;🐑&quot;)</code></p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function Base.show(io::IO, a::Animal{A}) where {A&lt;:AnimalSpecies}
    e = a.energy
    d = a.Δenergy
    pr = a.reprprob
    pf = a.foodprob
    s = a.sex == female ? &quot;♀&quot; : &quot;♂&quot;
    print(io, &quot;$A$s #$(a.id) E=$e ΔE=$d pr=$pr pf=$pf&quot;)
end

# note that for new species/sexes we will only have to overload `show` on the
# abstract species types like below!
Base.show(io::IO, ::Type{Sheep}) = print(io,&quot;🐑&quot;)
Base.show(io::IO, ::Type{Wolf}) = print(io,&quot;🐺&quot;)</code></pre></p></details><p>Unfortunately we have lost the convenience of creating plants and animals by simply calling their species constructor. For example, <code>Sheep</code> is just an abstract type that we cannot instantiate. However, we can manually define a new constructor that will give us this convenience back. This is done in exactly the same way as defining a constructor for a concrete type:</p><pre><code class="language-julia hljs">Sheep(id,E,ΔE,pr,pf,s=rand(Sex)) = Animal{Sheep}(id,E,ΔE,pr,pf,s)</code></pre><p>Ok, so we have a constructor for <code>Sheep</code> now. But what about all the other billions of species that you want to define in your huge master thesis project of ecosystem simulations?  Do you have to write them all by hand? <em>Do not despair!</em> Julia has you covered.</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise:</header>
<div class="admonition-body"><p>Overload all <code>AnimalSpecies</code> types with a constructor. You already know how to write constructors for specific types such as <code>Sheep</code>. Can you manage to sneak in a type variable? Maybe with <code>Type</code>?</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function (A::Type{&lt;:AnimalSpecies})(id::Int,E::T,ΔE::T,pr::T,pf::T,s::Sex) where T
    Animal{A}(id,E,ΔE,pr,pf,s)
end

# get the per species defaults back
randsex() = rand(instances(Sex))
Sheep(id; E=4.0, ΔE=0.2, pr=0.8, pf=0.6, s=randsex()) = Sheep(id, E, ΔE, pr, pf, s)
Wolf(id; E=10.0, ΔE=8.0, pr=0.1, pf=0.2, s=randsex()) = Wolf(id, E, ΔE, pr, pf, s)</code></pre></p></details><p>We have our convenient, high-level behaviour back!</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Sheep(1)</code><code class="nohighlight hljs ansi" style="display:block;">🐑♀ #1 E=4.0 ΔE=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Wolf(2)</code><code class="nohighlight hljs ansi" style="display:block;">🐺♂ #2 E=10.0 ΔE=8.0 pr=0.1 pf=0.2</code></pre><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise:</header>
<div class="admonition-body"><p>Check the methods for <code>eat!</code> and <code>kill_agent!</code> which involve <code>Animal</code>s and update their type signatures such that they work for the new type hiearchy.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function eat!(wolf::Animal{Wolf}, sheep::Animal{Sheep}, w::World)
    wolf.energy += sheep.energy * wolf.Δenergy
    kill_agent!(sheep,w)
end

# no change
# eat!(::Animal, ::Nothing, ::World) = nothing

# no change
# kill_agent!(a::Agent, w::World) = delete!(w.agents, a.id)

eats(::Animal{Wolf},::Animal{Sheep}) = true
eats(::Agent,::Agent) = false
# this one needs to wait until we have `Plant`s
# eats(::Animal{Sheep},g::Plant{Grass}) = g.size &gt; 0</code></pre></p></details><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise:</header>
<div class="admonition-body"><p>Finally, we can implement the new behaviour for <code>reproduce!</code> which we wanted. Build a function which first finds an animal species of opposite sex and then lets the two reproduce (same behaviour as before).</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">mates(a::Animal{A}, b::Animal{A}) where A&lt;:AnimalSpecies = a.sex != b.sex
mates(::Agent, ::Agent) = false

function find_mate(a::Animal, w::World)
    ms = filter(x-&gt;mates(x,a), w.agents |&gt; values |&gt; collect)
    isempty(ms) ? nothing : rand(ms)
end

function reproduce!(a::Animal{A}, w::World) where {A}
    m = find_mate(a,w)
    if !isnothing(m)
        a.energy = a.energy / 2
        vals = [getproperty(a,n) for n in fieldnames(Animal) if n ∉ [:id, :sex]]
        new_id = w.max_id + 1
        ŝ = Animal{A}(new_id, vals..., randsex())
        w.agents[ŝ.id] = ŝ
        w.max_id = new_id
    end
end</code></pre></p></details><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s1 = Sheep(1, s=female)</code><code class="nohighlight hljs ansi" style="display:block;">🐑♀ #1 E=4.0 ΔE=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 = Sheep(2, s=male)</code><code class="nohighlight hljs ansi" style="display:block;">🐑♂ #2 E=4.0 ΔE=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; w  = World([s1, s2])</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Animal{🐑}}
  🐑♂ #2 E=4.0 ΔE=0.2 pr=0.8 pf=0.6
  🐑♀ #1 E=4.0 ΔE=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reproduce!(s1, w); w</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Animal{🐑}}
  🐑♂ #2 E=4.0 ΔE=0.2 pr=0.8 pf=0.6
  🐑♂ #3 E=2.0 ΔE=0.2 pr=0.8 pf=0.6
  🐑♀ #1 E=2.0 ΔE=0.2 pr=0.8 pf=0.6</code></pre><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise:</header>
<div class="admonition-body"><p>Implement the type hiearchy we designed for <code>Plant</code>s as well.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">mutable struct Plant{P&lt;:PlantSpecies} &lt;: Agent{P}
    id::Int
    size::Int
    max_size::Int
end

# constructor for all Plant{&lt;:PlantSpecies} callable as PlantSpecies(...)
(A::Type{&lt;:PlantSpecies})(id, s, m) = Plant{A}(id,s,m)
(A::Type{&lt;:PlantSpecies})(id, m) = (A::Type{&lt;:PlantSpecies})(id,rand(1:m),m)

# default specific for Grass
Grass(id; max_size=10) = Grass(id, rand(1:max_size), max_size)

function Base.show(io::IO, p::Plant{P}) where P
    x = p.size/p.max_size * 100
    print(io,&quot;$P  #$(p.id) $(round(Int,x))% grown&quot;)
end

Base.show(io::IO, ::Type{Grass}) = print(io,&quot;🌿&quot;)

function eat!(sheep::Animal{Sheep}, grass::Plant{Grass}, w::World)
    sheep.energy += grass.size * sheep.Δenergy
    grass.size = 0
end
eats(::Animal{Sheep},g::Plant{Grass}) = g.size &gt; 0</code></pre></p></details><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; g = Grass(2)</code><code class="nohighlight hljs ansi" style="display:block;">🌿  #2 10% grown</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = Sheep(3)</code><code class="nohighlight hljs ansi" style="display:block;">🐑♀ #3 E=4.0 ΔE=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; w = World([g,s])</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Agent}
  🌿  #2 10% grown
  🐑♀ #3 E=4.0 ΔE=0.2 pr=0.8 pf=0.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eat!(s,g,w); w</code><code class="nohighlight hljs ansi" style="display:block;">Main.World{Main.Agent}
  🌿  #2 0% grown
  🐑♀ #3 E=4.2 ΔE=0.2 pr=0.8 pf=0.6</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture/">« Lecture</a><a class="docs-footer-nextpage" href="../hw/">Homework »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Thursday 23 November 2023 19:10">Thursday 23 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
