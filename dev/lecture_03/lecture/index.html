<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture ¬∑ Scientific Programming in Julia</title><meta name="title" content="Lecture ¬∑ Scientific Programming in Julia"/><meta property="og:title" content="Lecture ¬∑ Scientific Programming in Julia"/><meta property="twitter:title" content="Lecture ¬∑ Scientific Programming in Julia"/><meta name="description" content="Documentation for Scientific Programming in Julia."/><meta property="og:description" content="Documentation for Scientific Programming in Julia."/><meta property="twitter:description" content="Documentation for Scientific Programming in Julia."/><meta property="og:url" content="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_03/lecture/"/><meta property="twitter:url" content="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_03/lecture/"/><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_03/lecture/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/onlinestats.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design Patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a><ul class="internal"><li><a class="tocitem" href="#Design-Patterns-of-OOP-from-the-Julia-viewpoint"><span>Design Patterns of OOP from the Julia viewpoint</span></a></li><li><a class="tocitem" href="#Polymorphism:"><span>Polymorphism:</span></a></li><li><a class="tocitem" href="#Inheritance"><span>Inheritance</span></a></li><li><a class="tocitem" href="#Interfaces:-inheritance/subtyping-without-a-hierarchy-tree"><span>Interfaces: inheritance/subtyping without a hierarchy tree</span></a></li><li><a class="tocitem" href="#Traits:-cherry-picking-subtyping"><span>Traits: cherry picking subtyping</span></a></li><li><a class="tocitem" href="#Functional-tools:-Partial-evaluation"><span>Functional tools: Partial evaluation</span></a></li><li><a class="tocitem" href="#Functional-tools:-Closures"><span>Functional tools: Closures</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Aditional-materials"><span>Aditional materials</span></a></li></ul></li><li><a class="tocitem" href="../lab/">Lab</a></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Package development, Unit test &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Performance Benchmarking</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">3: Design Patterns</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/2023W/docs/src/lecture_03/lecture.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Design-patterns:-good-practices-and-structured-thinking"><a class="docs-heading-anchor" href="#Design-patterns:-good-practices-and-structured-thinking">Design patterns: good practices and structured thinking</a><a id="Design-patterns:-good-practices-and-structured-thinking-1"></a><a class="docs-heading-anchor-permalink" href="#Design-patterns:-good-practices-and-structured-thinking" title="Permalink"></a></h1><p>Every software developer has a desire to write better code. A desire to improve system performance. A desire to design software that is easy to maintain, easy to understand and explain.</p><p>Design patterns are recommendations and good practices accumulating knowledge of experienced  programmers.</p><p>The highest level of experience contains the design guiding principles:</p><ul><li>SOLID: Single Responsibility, Open/Closed, Liskov Substitution, Interface</li><li>Segregation, Dependency Inversion</li><li>DRY: Don&#39;t Repeat Yourself</li><li>KISS: Keep It Simple, Stupid!</li><li>POLA: Principle of Least Astonishment</li><li>YAGNI: You Aren&#39;t Gonna Need It (overengineering)</li><li>POLP: Principle of Least Privilege </li></ul><p>While these high-level concepts are intuitive, they are too general to give specific answers.</p><p>More detailed patterns arise for programming paradigms (declarative, imperative) with specific instances of functional or object-oriented programming.</p><p>The concept of design patterns originates in the OOP paradigm. OOP defines a strict way how to write software. Sometimes it is not clear how to squeeze real world problems into those rules.  Cookbook for many practical situations</p><ul><li>Gamma, E., Johnson, R., Helm, R., Johnson, R. E., &amp; Vlissides, J. (1995). Design patterns: elements of reusable object-oriented software. Pearson Deutschland GmbH.</li></ul><p>Defining 23 design patterns in three categories. Became extremely popular.</p><p><img src="../design_patterns.jpg" alt/> (C) Scott Wlaschin</p><p>Is julia OOP or FP? It is different from both, based on:</p><ul><li>types system (polymorphic)</li><li>multiple dispatch (extending single dispatch of OOP)</li><li>functions as first class </li><li>decoupling of data and functions</li><li>macros</li></ul><p>Any guidelines to solve real-world problems?</p><ul><li>Hands-On Design Patterns and Best Practices with Julia Proven solutions to common problems in software design for Julia 1.x Tom Kwong, CFA</li></ul><p>Fundamental tradeoff: rules vs. freedom</p><ul><li>freedom: in the C language it is possible to access assembler instructions, use pointer aritmetics:<ul><li>it is possible to write extremely efficient code</li><li>it is easy to segfault, leak memory, etc.</li></ul></li><li>rules: in strict languages (strict OOP, strict functional programing) you lose freedom for certain guarantees:<ul><li>e.g. strict functional programing guarantees that the program provably terminates</li><li>operations that are simple e.g. in pointer arithmetics may become clumsy and inefficient in those strict rules.</li><li>the compiler can validate the rules and complain if the code does not comply with them. </li></ul></li></ul><p>Julia is again a dance between freedom and strict rules. It is more inclined to freedom.  Provides few simple concepts that allow to construct design patterns common in other languages.</p><ul><li>the language does not enforce too many formalisms (via keywords (interface, trait, etc.) but they can be <ul><li>the compiler cannot check for correctness of these &quot;patterns&quot;</li><li>the user has a lot of freedom (and responsibility)</li></ul></li><li>lots of features can be added by Julia packages (with various level of comfort)<ul><li>macros</li></ul></li></ul><p>Read: </p><h2 id="Design-Patterns-of-OOP-from-the-Julia-viewpoint"><a class="docs-heading-anchor" href="#Design-Patterns-of-OOP-from-the-Julia-viewpoint">Design Patterns of OOP from the Julia viewpoint</a><a id="Design-Patterns-of-OOP-from-the-Julia-viewpoint-1"></a><a class="docs-heading-anchor-permalink" href="#Design-Patterns-of-OOP-from-the-Julia-viewpoint" title="Permalink"></a></h2><p>OOP is currently very popular concept (C++, Java, Python).  It has strenghts and weaknesses. The Julia authors tried to keep the strength and overcome weaknesses. </p><p>Key features of OOP:</p><ul><li>Encapsulation </li><li>Inheritance </li><li>Polymorphism </li></ul><p>Classical OOP languages define classes that bind processing functions to the data. Virtual methods are defined only for the attached methods of the classes.</p><div class="admonition is-success"><header class="admonition-header">Encapsulation</header><div class="admonition-body"><p>Refers to bundling of data with the methods that operate on that data, or the restricting of direct access to some of an object&#39;s components. Encapsulation is used to hide the values or state of a structured data object inside a class, preventing direct access to them by clients in a way that could expose hidden implementation details or violate state invariance maintained by the methods. </p></div></div><div class="admonition is-success"><header class="admonition-header">Making Julia to mimic OOP</header><div class="admonition-body"><p>There are many discussions how to make Julia to behave like an OOP. The best implementation to our knowledge is <a href="https://github.com/Suzhou-Tongyuan/ObjectOriented.jl">ObjectOriented</a></p></div></div><h3 id="Encapsulation-Advantage:-Consistency-and-Validity"><a class="docs-heading-anchor" href="#Encapsulation-Advantage:-Consistency-and-Validity">Encapsulation Advantage: Consistency and Validity</a><a id="Encapsulation-Advantage:-Consistency-and-Validity-1"></a><a class="docs-heading-anchor-permalink" href="#Encapsulation-Advantage:-Consistency-and-Validity" title="Permalink"></a></h3><p>With fields of data structure freely accessible, the information may become inconsistent.</p><pre><code class="nohighlight hljs">mutable struct Grass &lt;: Plant
    id::Int
    size::Int
    max_size::Int
end</code></pre><p>What if I create Grass with larger size than <code>max_size</code>?</p><pre><code class="language-julia hljs">grass = Grass(1,50,5)</code></pre><p>Freedom over Rules. Maybe I would prefer to introduce some rules.</p><p>Some encapsulation may be handy keeping it consistent. Julia has <code>inner constructor</code>.</p><pre><code class="language-julia hljs">mutable struct Grass2 &lt;: Plant
    id::Int
    size::Int
    max_size::Int
    Grass2(id,sz,msz) = sz &gt; msz ? error(&quot;size can not be greater that max_size&quot;) : new(id,sz,msz)
end</code></pre><p>When defined, Julia does not provide the default outer constructor. </p><p>But fields are still accessible:</p><pre><code class="language-julia hljs">grass.size = 10000</code></pre><p>Recall that <code>grass.size=1000</code> is a syntax of <code>setproperty!(grass,:size,1000)</code>, which can be redefined:</p><pre><code class="language-julia hljs">function Base.setproperty!(obj::Grass, sym::Symbol, val)
    if sym==:size
        @assert val&lt;=obj.max_size &quot;size have to be lower than max_size!&quot;
    end
    setfield!(obj,sym,val)
end</code></pre><p>Function <code>setfield!</code> can not be overloaded.</p><p>Julia has <em>partial encapsulation</em> via a mechanism for consistency checks. </p><div class="admonition is-category-warn"><header class="admonition-header">Array in unmutable struct can be mutated</header><div class="admonition-body"><p>The mutability applies to the structure and not to encapsulated structures.</p><pre><code class="language-julia hljs">struct Foo
    x::Float64
    y::Vector{Float64}
    z::Dict{Int,Int}
end</code></pre><p>In the structure <code>Foo</code>, <code>x</code> cannot be mutated, but fields of <code>y</code> and key-value pairs of <code>z</code> can be mutated, because they are mutable containers. But I cannot replace <code>y</code> with a different <code>Vector</code>.</p></div></div><h3 id="Encapsulation-Disadvantage:-the-Expression-Problem"><a class="docs-heading-anchor" href="#Encapsulation-Disadvantage:-the-Expression-Problem">Encapsulation Disadvantage: the Expression Problem</a><a id="Encapsulation-Disadvantage:-the-Expression-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Encapsulation-Disadvantage:-the-Expression-Problem" title="Permalink"></a></h3><p>Encapsulation limits the operations I can do with an object. Sometimes too much. Consider a matrix of methods/types(data-structures)</p><p>Consider an existing matrix of data and functions:</p><table><tr><th style="text-align: right">data \ methods</th><th style="text-align: right">find_food</th><th style="text-align: right">eat!</th><th style="text-align: right">grow!</th><th style="text-align: right"></th><th style="text-align: right"></th></tr><tr><td style="text-align: right">Wolf</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">Sheep</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right">Grass</td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td><td style="text-align: right"></td></tr></table><p>You have a good reason not to modify the original source (maintenance).</p><p>Imagine we want to extend the world to use new animals and new methods for all animals.</p><p>Object-oriented programming </p><ul><li>classes are primary objects (hierarchy)</li><li>define animals as classes ( inheriting from abstract class)</li><li>adding a new animal is easy</li><li>adding a new method for all animals is hard (without modifying the original code)</li></ul><p>Functional programming </p><ul><li>functions are primary</li><li>define operations <code>find_food</code>, <code>eat!</code></li><li>adding a new operation is easy</li><li>adding new data structure to existing operations is hard</li></ul><p>Solutions:</p><ol><li>multiple-dispatch = julia</li><li>open classes (monkey patching) = add methods to classes on the fly</li><li>visitor pattern = partial fix for OOP [extended visitor pattern using dynamic_cast]</li></ol><h3 id="Morale:"><a class="docs-heading-anchor" href="#Morale:">Morale:</a><a id="Morale:-1"></a><a class="docs-heading-anchor-permalink" href="#Morale:" title="Permalink"></a></h3><ul><li>Julia does not enforces creation getters/setters by default  (setproperty is mapped to setfield)</li><li>it provides tools to enforce access restriction if the user wants it.</li><li>can be used to imitate objects: </li></ul><p>https://stackoverflow.com/questions/39133424/how-to-create-a-single-dispatch-object-oriented-class-in-julia-that-behaves-l/39150509#39150509</p><h2 id="Polymorphism:"><a class="docs-heading-anchor" href="#Polymorphism:">Polymorphism:</a><a id="Polymorphism:-1"></a><a class="docs-heading-anchor-permalink" href="#Polymorphism:" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">Polymorphism in OOP</header><div class="admonition-body"><p>Polymorphism is the method in an object-oriented programming language that performs different things as per the object‚Äôs class, which calls it. With Polymorphism, a message is sent to multiple class objects, and every object responds appropriately according to the properties of the class. </p></div></div><p>Example animals of different classes make different sounds. In Python:</p><pre><code class="language-python hljs">
class Sheep:
    def __init__(self, energy, Denergy):
        self.energy = energy
        self.Denergy = Denergy

    def make_sound(self):
        print(&quot;Baa&quot;)

sheep.make_sound()
wolf.make_sound()</code></pre><p>Will make distinct sounds (baa, Howl). </p><p>Can we achieve this in Julia?</p><pre><code class="nohighlight hljs">make_sound(s::Sheep)=println(&quot;Baa&quot;)
make_sound(w::Wolf)=println(&quot;Howl&quot;)</code></pre><div class="admonition is-success"><header class="admonition-header">Implementation of virtual methods</header><div class="admonition-body"><p>Virtual methods in OOP are typically implemented using Virtual Method Table, one for each class. <img src="../vtable.gif" alt/></p><p>Julia has a single method table. Dispatch can be either static or dynamic (slow).</p></div></div><p><em>Freedom</em> vs. Rules. </p><ul><li>Duck typing is a type of polymorphism without static types<ul><li>more  programming freedom, less formal guarantees</li></ul></li><li>julia does not check if <code>make_sound</code> exists for all animals. May result in <code>MethodError</code>. Responsibility of a programmer.<ul><li>define <code>make_sound(A::AbstractAnimal)</code></li></ul></li></ul><p>So far, the polymorphism coincides for OOP and julia becuase the method had only one argument =&gt; single argument dispatch.</p><p>Multiple dispatch is an <em>extension</em> of the classical first-argument-polymorphism of OOP, to all-argument polymorphism.</p><div class="admonition is-success"><header class="admonition-header">Challenge for OOP</header><div class="admonition-body"><p>How to code polymorphic behavior of interaction between two agents, e.g. an agent eating another agent in OOP?</p><p>Complicated.... You need a &quot;design pattern&quot; for it.</p></div></div><pre><code class="language-python hljs">class Sheep(Animal):
    energy: float = 4.0
    denergy: float = 0.2
    reprprob: float = 0.5
    foodprob: float = 0.9

    # hard, if not impossible to add behaviour for a new type of food
    def eat(self, a: Agent, w: World):
        if isinstance(a, Grass)
            self.energy += a.size * self.denergy
            a.size = 0
        else:
            raise ValueError(f&quot;Sheep cannot eat {type(a).__name__}.&quot;)</code></pre><p>Consider an extension to:</p><ul><li>Flower : easy</li><li>PoisonousGrass: harder</li></ul><p>Simple in Julia:</p><pre><code class="nohighlight hljs">eat!(w1::Sheep, a::Grass, w::World)=
eat!(w1::Sheep, a::Flower, w::World)=
eat!(w1::Sheep, a::PoisonousGrass, w::World)=</code></pre><p>Boiler-plate code can be automated by macros / meta programming.</p><h2 id="Inheritance"><a class="docs-heading-anchor" href="#Inheritance">Inheritance</a><a id="Inheritance-1"></a><a class="docs-heading-anchor-permalink" href="#Inheritance" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">Inheritance</header><div class="admonition-body"><p>Is the mechanism of basing one object or class upon another object (prototype-based inheritance) or class (class-based inheritance), retaining similar implementation. Deriving new classes (sub classes) from existing ones such as super class or base class and then forming them into a hierarchy of classes. In most class-based object-oriented languages, an object created through inheritance, a &quot;child object&quot;, acquires all the properties and behaviors of the &quot;parent object&quot; , with the exception of: constructors, destructor, overloaded operators.</p></div></div><p>Most commonly, the sub-class inherits methods and the data.</p><p>For example, in python we can design a sheep with additional field. Think of a situation that we want to refine the reproduction procedure for sheeps by considering differences for male and female. We do not have information about gender in the original implementation. </p><p>In OOP, we can use <em>inheritance</em>.</p><pre><code class="language-python hljs">class Sheep:
    def __init__(self, energy, Denergy):
        self.energy = energy
        self.Denergy = Denergy

    def make_sound(self):
        print(&quot;Baa&quot;)

class SheepWithGender(Sheep):
    def __init__(self, energy, Denergy,gender):
        super().__init__(energy, Denergy)
        self.gender = gender
    # make_sound is inherited 

# Can you do this in Julia?!</code></pre><p>Simple answer: NO, not exactly</p><ul><li>Sheep has fields, is a <strong>concrete</strong> type, we cannot extend it.<ul><li>with modification of the original code, we can define AbstractSheep with subtypes Sheep and SheepWithGender.</li></ul></li><li>But methods for AbstractAnimal works for sheeps! Is this inheritance?</li></ul><h3 id="Inheritance-vs.-Subtyping"><a class="docs-heading-anchor" href="#Inheritance-vs.-Subtyping">Inheritance vs. Subtyping</a><a id="Inheritance-vs.-Subtyping-1"></a><a class="docs-heading-anchor-permalink" href="#Inheritance-vs.-Subtyping" title="Permalink"></a></h3><p>Subtle difference:</p><ul><li>subtyping = equality of interface </li><li>inheritance = reuse of implementation </li></ul><p>In practice, subtyping reuse methods, <em>not</em> data fields.</p><p>We have seen this in Julia, using type hierarchy: </p><ul><li><code>agent_step!(a::Animal, w::World)</code></li><li>all animals subtype of <code>Animal</code> &quot;inherit&quot; this method.</li></ul><p>The type hierarchy is only one way of subtyping. Julia allows many variations, e.g. concatenating different parts of hierarchies via the <code>Union{}</code> type:</p><pre><code class="language-julia hljs">fancy_method(O::Union{Sheep,Grass})=println(&quot;Fancy&quot;)</code></pre><p>Is this a good idea? It can be done completely Ad-hoc! Freedom over Rules.</p><p>There are very good use-cases:</p><ul><li>Missing values:</li></ul><p><code>x::AbstractVector{&lt;:Union{&lt;:Number, Missing}}</code></p><div class="admonition is-category-theorem"><header class="admonition-header">SubTyping issues</header><div class="admonition-body"><p>With parametric types, unions and other construction, subtype resolution may become a complicated problem. Julia can even crash. (Jan Vitek&#39;s Keynote at JuliaCon 2021)[https://www.youtube.com/watch?v=LT4AP7CUMAw]</p></div></div><h3 id="Sharing-of-data-field-via-composition"><a class="docs-heading-anchor" href="#Sharing-of-data-field-via-composition">Sharing of data field via composition</a><a id="Sharing-of-data-field-via-composition-1"></a><a class="docs-heading-anchor-permalink" href="#Sharing-of-data-field-via-composition" title="Permalink"></a></h3><p>Composition is also recommended in OOP: (Composition over ingeritance)[https://en.wikipedia.org/wiki/Composition<em>over</em>inheritance]</p><pre><code class="language-julia hljs">struct ‚ö•Sheep &lt;: Animal
    sheep::Sheep
    sex::Symbol
end</code></pre><p>If we want our new ‚ö•Sheep to behave like the original Sheep, we need to <em>forward</em> the corresponding methods.</p><pre><code class="language-julia hljs">eat!(a::‚ö•Sheep, b::Grass, w::World)=eat!(a.sheep, b, w)</code></pre><p>and all other methods. Routine work. Boring!   The whole process can be automated using macros <code>@forward</code> from Lazy.jl.</p><p>Why so complicated? Wasn&#39;t the original inheritance tree structure better?</p><ul><li>multiple inheritance:<ul><li>you just compose two different &quot;trees&quot;.</li><li>common example with ArmoredVehicle = Vehicle + Weapon</li></ul></li><li>Do you think there is only one sensible inheritance tree?</li></ul><div class="admonition is-success"><header class="admonition-header">Animal World</header><div class="admonition-body"><p>Think of an inheritance tree of a full scope Animal world.</p><p>Idea #1: Split animals by biological taxonomy <img src="../animals.jpg" alt/></p><p>Hold on. </p><ul><li>Sharks and dolphins can swim very well!</li><li>Both bats and birds fly similarly!</li></ul><p>Idea #2: Split by the way they move!</p><p>Idea #3: Split by way of ...</p></div></div><p>In fact, we do not have a tree, but more like a matrix/tensor:</p><table><tr><th style="text-align: right"></th><th style="text-align: right">swims</th><th style="text-align: right">flies</th><th style="text-align: right">walks</th></tr><tr><td style="text-align: right">birds</td><td style="text-align: right">penguin</td><td style="text-align: right">eagle</td><td style="text-align: right">kiwi</td></tr><tr><td style="text-align: right">mammal</td><td style="text-align: right">dolphin</td><td style="text-align: right">bat</td><td style="text-align: right">sheep,wolf</td></tr><tr><td style="text-align: right">insect</td><td style="text-align: right">backswimmer</td><td style="text-align: right">fly</td><td style="text-align: right">beetle</td></tr></table><p>Single type hierarchy will not work. Other approaches:</p><ul><li>interfaces</li><li>parametric types</li></ul><p>Analyze what features of animals are common and <em>compose</em> the animal:</p><pre><code class="language-julia hljs">abstract type HeatType end
abstract type MovementType end
abstract type ChildCare end


mutable struct Animal{H&lt;:HeatType,M&lt;:MovementType,C&lt;:ChildCare} 
    id::Int
    ...
end</code></pre><p>Now, we can define methods dispatching on parameters of the main type.</p><p>Composition is simpler in such a general case. Composition over inheritance. </p><p>A simple example of parametric approach will be demonstarted in the lab.</p><h2 id="Interfaces:-inheritance/subtyping-without-a-hierarchy-tree"><a class="docs-heading-anchor" href="#Interfaces:-inheritance/subtyping-without-a-hierarchy-tree">Interfaces: inheritance/subtyping without a hierarchy tree</a><a id="Interfaces:-inheritance/subtyping-without-a-hierarchy-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Interfaces:-inheritance/subtyping-without-a-hierarchy-tree" title="Permalink"></a></h2><p>In OOP languages such as Java, interfaces have a dedicated keyword such that compiler can check correctes of the interface implementation. </p><p>In Julia, interfaces can be achived by defining ordinary functions.  Not so strict validation by the compiler as in other languages. Freedom...</p><h3 id="Example:-Iterators"><a class="docs-heading-anchor" href="#Example:-Iterators">Example: Iterators</a><a id="Example:-Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Iterators" title="Permalink"></a></h3><p>Many fundamental objects can be iterated: Arrays, Tuples, Data collections...</p><ul><li>They do not have any common &quot;predecessor&quot;. They are almost &quot;primitive&quot; types.</li><li>they share just the property of being iterable</li><li>we do not want to modify them in any way</li></ul><p>Example: of interface <code>Iterators</code> defined by &quot;duck typing&quot; via two functions.</p><table><tr><th style="text-align: right">Required methods</th><th style="text-align: right">Brief description</th></tr><tr><td style="text-align: right">iterate(iter)</td><td style="text-align: right">Returns either a tuple of the first item and initial state or nothing if empty</td></tr><tr><td style="text-align: right">iterate(iter, state)</td><td style="text-align: right">Returns either a tuple of the next item and next state or nothing if no items remain</td></tr></table><p>Defining these two methods for any object/collection <code>C</code> will make the following work:</p><pre><code class="language-julia hljs">for o in C
   # do something
end</code></pre><ul><li>The compiler will not check if both functions exist.</li><li>If one is missing, it will complain about it when it needs it</li><li>The error message may be less informative than in the case of formal definition</li></ul><p>Note:</p><ul><li>even iterators may have different features: they can be finite or infinite</li><li>for finite iterators we can define useful functions (<code>collect</code>)</li><li>how to pass this information in an extensible way?</li></ul><p>Poor solution: if statements.</p><pre><code class="language-julia hljs">function collect(iter)
 if iter isa Tuple...

end</code></pre><p>The compiler can do that for us.</p><h2 id="Traits:-cherry-picking-subtyping"><a class="docs-heading-anchor" href="#Traits:-cherry-picking-subtyping">Traits: cherry picking subtyping</a><a id="Traits:-cherry-picking-subtyping-1"></a><a class="docs-heading-anchor-permalink" href="#Traits:-cherry-picking-subtyping" title="Permalink"></a></h2><p>Trait mechanism in Julia is build using the existing tools: Type System and Multiple Dispatch.</p><p>Traits have a few key parts:</p><ul><li>Trait types: the different traits a type can have.</li><li>Trait function: what traits a type has.</li><li>Trait dispatch: using the traits.</li></ul><p>From iterators:</p><pre><code class="language-julia hljs"># trait types:

abstract type IteratorSize end
struct SizeUnknown &lt;: IteratorSize end
struct HasLength &lt;: IteratorSize end
struct IsInfinite &lt;: IteratorSize end

# Trait function: Input is a Type, output is a Type
IteratorSize(::Type{&lt;:Tuple}) = HasLength()
IteratorSize(::Type) = HasLength()  # HasLength is the default

# ...

# Trait dispatch
BitArray(itr) = gen_bitarray(IteratorSize(itr), itr)
gen_bitarray(isz::IteratorSize, itr) = gen_bitarray_from_itr(itr)
gen_bitarray(::IsInfinite, itr) =  throw(ArgumentError(&quot;infinite-size iterable used in BitArray constructor&quot;))
</code></pre><p>What is needed to define for a new type that I want to iterate over? </p><p>Do you still miss inheritance in the OOP style?</p><p>Many packages automating this with more structure:</p><ul><li>https://github.com/andyferris/Traitor.jl</li><li>https://github.com/mauro3/SimpleTraits.jl</li><li>https://github.com/tk3369/BinaryTraits.jl</li></ul><h2 id="Functional-tools:-Partial-evaluation"><a class="docs-heading-anchor" href="#Functional-tools:-Partial-evaluation">Functional tools: Partial evaluation</a><a id="Functional-tools:-Partial-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Functional-tools:-Partial-evaluation" title="Permalink"></a></h2><p>It is common to create a new function which &quot;just&quot; specify some parameters.</p><pre><code class="nohighlight hljs">_prod(x) = reduce(*,x)
_sum(x) = reduce(+,x)</code></pre><h2 id="Functional-tools:-Closures"><a class="docs-heading-anchor" href="#Functional-tools:-Closures">Functional tools: Closures</a><a id="Functional-tools:-Closures-1"></a><a class="docs-heading-anchor-permalink" href="#Functional-tools:-Closures" title="Permalink"></a></h2><div class="admonition is-success"><header class="admonition-header">Closure (lexical closure, function closure)</header><div class="admonition-body"><p>A technique for implementing lexically scoped name binding in a language with first-class functions. Operationally, a closure is a record storing a function together with an environment.</p></div></div><ul><li>originates in functional programming</li><li>now widespread in many common languages, Python, Matlab, etc..</li><li>memory management relies on garbage collector in general (can be optimized by compiler)</li></ul><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia hljs">function adder(x)
    return y-&gt;x+y
end</code></pre><p>creates a function that &quot;closes&quot; the argument <code>x</code>. Try: <code>f=adder(5); f(3)</code>.</p><pre><code class="language-julia hljs">x = 30;
function adder()
    return y-&gt;x+y
end</code></pre><p>creates a function that &quot;closes&quot; variable <code>x</code>.</p><pre><code class="language-julia hljs">f = adder(10)
f(1)
g = adder()
g(1)
</code></pre><p>Such function can be passed as an argument: <em>together</em> with the closed data.</p><h3 id="Implementation-of-closures-in-julia:-documentation"><a class="docs-heading-anchor" href="#Implementation-of-closures-in-julia:-documentation">Implementation of closures in julia: documentation</a><a id="Implementation-of-closures-in-julia:-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-of-closures-in-julia:-documentation" title="Permalink"></a></h3><p>Closure is a record storing a function together with an environment. The environment is a mapping associating each <em>free</em> variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created.</p><pre><code class="language-julia hljs">function adder(x)
    return y-&gt;x+y
end</code></pre><p>is lowered to (roughly):</p><pre><code class="language-julia hljs">struct ##1{T}
    x::T
end

(_::##1)(y) = _.x + y

function adder(x)
    return ##1(x)
end</code></pre><p>Note that the structure ##1 is not directly accessible. Try <code>f.x</code> and <code>g.x</code>.</p><h3 id="Functor-Function-like-structure"><a class="docs-heading-anchor" href="#Functor-Function-like-structure">Functor = Function-like structure</a><a id="Functor-Function-like-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Functor-Function-like-structure" title="Permalink"></a></h3><p>Each structure can have a method that is invoked when called as a function.</p><pre><code class="nohighlight hljs">(_::Sheep)()= println(&quot;üêë&quot;)</code></pre><p>You can think of it as <code>sheep.default_method()</code>.</p><h3 id="Coding-style"><a class="docs-heading-anchor" href="#Coding-style">Coding style</a><a id="Coding-style-1"></a><a class="docs-heading-anchor-permalink" href="#Coding-style" title="Permalink"></a></h3><p>From <code>Flux.jl</code>:</p><pre><code class="language-julia hljs">function train!(loss, ps, data, opt; cb = () -&gt; ())
  ps = Params(ps)
  cb = runall(cb)
  @progress for d in data
      gs = gradient(ps) do
        loss(batchmemaybe(d)...)
      end
      update!(opt, ps, gs)
      cb()
  end
end</code></pre><p>Is this confusing? What can <code>cb()</code> do and what it can not?</p><p>Note that function <code>train!</code> does not have many local variables. The important ones are arguments, i.e. exist in the scope from which the function was invoked.</p><pre><code class="language-julia hljs">loss(x,y)=mse(model(x),y)
cb() = @info &quot;training&quot; loss(x,y)
train!(loss, ps, data, opt; cb=cb)</code></pre><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>Usage of closures:</p><ul><li>callbacks: the function can also modify the enclosed variable.</li><li>abstraction: partial evaluation </li></ul><div class="admonition is-category-theorem"><header class="admonition-header">Beware: Performance of captured variables</header><div class="admonition-body"><p>Inference of types may be difficult in closures: https://github.com/JuliaLang/julia/issues/15276    </p></div></div><h2 id="Aditional-materials"><a class="docs-heading-anchor" href="#Aditional-materials">Aditional materials</a><a id="Aditional-materials-1"></a><a class="docs-heading-anchor-permalink" href="#Aditional-materials" title="Permalink"></a></h2><ul><li><a href="https://www.youtube.com/watch?v=srQt1NAHYC0">Functional desighn pattersn</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_02/hw/">¬´ Homework</a><a class="docs-footer-nextpage" href="../lab/">Lab ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Thursday 26 October 2023 15:36">Thursday 26 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
