<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lab · Scientific Programming in Julia</title><meta name="title" content="Lab · Scientific Programming in Julia"/><meta property="og:title" content="Lab · Scientific Programming in Julia"/><meta property="twitter:title" content="Lab · Scientific Programming in Julia"/><meta name="description" content="Documentation for Scientific Programming in Julia."/><meta property="og:description" content="Documentation for Scientific Programming in Julia."/><meta property="twitter:description" content="Documentation for Scientific Programming in Julia."/><meta property="og:url" content="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_06/lab/"/><meta property="twitter:url" content="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_06/lab/"/><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_06/lab/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of type system &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Package development, unit tests &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Performance benchmarking</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox" checked/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Lanuage introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../lecture/">Lecture</a></li><li class="is-active"><a class="tocitem" href>Lab</a><ul class="internal"><li><a class="tocitem" href="#Quick-reminder-of-introspection-tooling"><span>Quick reminder of introspection tooling</span></a></li><li><a class="tocitem" href="#AST-manipulation:-The-first-steps-to-metaprogramming"><span>AST manipulation: The first steps to metaprogramming</span></a></li><li><a class="tocitem" href="#Resources"><span>Resources</span></a></li></ul></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_07/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_07/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Automatic differentiation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_08/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_08/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Intermediate representation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_09/lab/">Lab</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Parallel programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_10/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_10/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-14" type="checkbox"/><label class="tocitem" for="menuitem-14"><span class="docs-label">11: GPU programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_11/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_11/lab/">Lab</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox"/><label class="tocitem" for="menuitem-15"><span class="docs-label">12: Ordinary Differential Equations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_12/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_12/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_12/hw/">Homework</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">6: Lanuage introspection</a></li><li class="is-active"><a href>Lab</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lab</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/2024W/docs/src/lecture_06/lab.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="introspection_lab"><a class="docs-heading-anchor" href="#introspection_lab">Lab 06: Code introspection and metaprogramming</a><a id="introspection_lab-1"></a><a class="docs-heading-anchor-permalink" href="#introspection_lab" title="Permalink"></a></h1><p>In this lab we are first going to inspect some tooling to help you understand what Julia does under the hood such as:</p><ul><li>looking at the code at different levels</li><li>understanding what method is being called</li><li>showing different levels of code optimization</li></ul><p>Secondly we will start playing with the metaprogramming side of Julia, mainly covering:</p><ul><li>how to view abstract syntax tree (AST) of Julia code</li><li>how to manipulate AST</li></ul><p>These topics will be extended in the next lecture/lab, where we are going use metaprogramming to manipulate code with macros.</p><p>We will be again a little getting ahead of ourselves as we are going to use quite a few macros, which will be properly explained in the next lecture as well, however for now the important thing to know is that a macro is just a special function, that accepts as an argument Julia code, which it can modify.</p><h2 id="Quick-reminder-of-introspection-tooling"><a class="docs-heading-anchor" href="#Quick-reminder-of-introspection-tooling">Quick reminder of introspection tooling</a><a id="Quick-reminder-of-introspection-tooling-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-reminder-of-introspection-tooling" title="Permalink"></a></h2><p>Let&#39;s start with the topic of code inspection, e.g. we may ask the following: What happens when Julia evaluates <code>[i for i in 1:10]</code>?</p><ul><li>parsing </li></ul><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; :([i for i in 1:10]) |&gt; dump</code><code class="nohighlight hljs ansi" style="display:block;">Expr
  head: Symbol comprehension
  args: Array{Any}((1,))
    1: Expr
      head: Symbol generator
      args: Array{Any}((2,))
        1: Symbol i
        2: Expr
          head: Symbol =
          args: Array{Any}((2,))
            1: Symbol i
            2: Expr
              head: Symbol call
              args: Array{Any}((3,))
                1: Symbol :
                2: Int64 1
                3: Int64 10</code></pre><ul><li>lowering</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Meta.@lower [i for i in 1:10]</code><code class="nohighlight hljs ansi" style="display:block;">:($(Expr(:thunk, CodeInfo(
   <span class="sgr33"> @ none within `top-level scope`</span>
<span class="sgr90">1 ─</span> %1 = :
<span class="sgr90">│  </span> %2 = (%1)(1, 10)
<span class="sgr90">│  </span> %3 = Base.Generator(Base.identity, %2)
<span class="sgr90">│  </span> %4 = Base.collect(%3)
<span class="sgr90">└──</span>      return %4
))))</code></pre><ul><li>typing</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f() = [i for i in 1:10]</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_typed f()</code><code class="nohighlight hljs ansi" style="display:block;">CodeInfo(
<span class="sgr90">1 ──</span> %1  = $(Expr(:foreigncall, :(:jl_alloc_genericmemory), Ref{Memory{Int64}}, svec(Any, Int64), 0, :(:ccall), Memory{Int64}, 10, 10))<span class="sgr36">::Memory{Int64}</span>
<span class="sgr90">│   </span> %2  = Core.memoryrefnew(%1)<span class="sgr36">::MemoryRef{Int64}</span>
<span class="sgr90">│   </span> %3  = %new(Vector{Int64}, %2, (10,))<span class="sgr36">::Vector{Int64}</span>
<span class="sgr90">│   </span> %4  = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr90">└───</span>       goto #5 if not %4
<span class="sgr90">2 ──</span> %6  = Base.sub_int(1, 1)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %7  = Base.bitcast(UInt64, %6)<span class="sgr36">::UInt64</span>
<span class="sgr90">│   </span> %8  = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr90">│   </span> %9  = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr90">│   </span> %10 = Base.getfield(%8, 1, %9)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %11 = Base.bitcast(UInt64, %10)<span class="sgr36">::UInt64</span>
<span class="sgr90">│   </span> %12 = Base.ult_int(%7, %11)<span class="sgr36">::Bool</span>
<span class="sgr90">└───</span>       goto #4 if not %12
<span class="sgr90">3 ──</span>       goto #5
<span class="sgr90">4 ──</span> %15 = Core.tuple(1)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Int64}, %15::Tuple{Int64})<span class="sgr90">::Union{}</span>
<span class="sgr90">└───</span>       unreachable
<span class="sgr90">5 ┄─</span> %18 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Int64}</span>
<span class="sgr90">│   </span> %19 = Base.memoryrefnew(%18, 1, false)<span class="sgr36">::MemoryRef{Int64}</span>
<span class="sgr90">│   </span>       Base.memoryrefset!(%19, 1, :not_atomic, false)<span class="sgr90">::Int64</span>
<span class="sgr90">└───</span>       goto #6
<span class="sgr90">6 ──</span>       nothing<span class="sgr90">::Nothing</span>
<span class="sgr90">7 ┄─</span> %23 = φ (#6 =&gt; 2, #20 =&gt; %57)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %24 = φ (#6 =&gt; 1, #20 =&gt; %32)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %25 = (%24 === 10)<span class="sgr36">::Bool</span>
<span class="sgr90">└───</span>       goto #9 if not %25
<span class="sgr90">8 ──</span>       goto #10
<span class="sgr90">9 ──</span> %28 = Base.add_int(%24, 1)<span class="sgr36">::Int64</span>
<span class="sgr90">└───</span>       goto #10
<span class="sgr90">10 ┄</span> %30 = φ (#8 =&gt; true, #9 =&gt; false)<span class="sgr36">::Bool</span>
<span class="sgr90">│   </span> %31 = φ (#9 =&gt; %28)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %32 = φ (#9 =&gt; %28)<span class="sgr36">::Int64</span>
<span class="sgr90">└───</span>       goto #12 if not %30
<span class="sgr90">11 ─</span>       goto #13
<span class="sgr90">12 ─</span>       goto #13
<span class="sgr90">13 ┄</span> %36 = φ (#11 =&gt; true, #12 =&gt; false)<span class="sgr36">::Bool</span>
<span class="sgr90">└───</span>       goto #15 if not %36
<span class="sgr90">14 ─</span>       goto #21
<span class="sgr90">15 ─</span> %39 = $(Expr(:boundscheck, false))<span class="sgr36">::Bool</span>
<span class="sgr90">└───</span>       goto #19 if not %39
<span class="sgr90">16 ─</span> %41 = Base.sub_int(%23, 1)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %42 = Base.bitcast(UInt64, %41)<span class="sgr36">::UInt64</span>
<span class="sgr90">│   </span> %43 = Base.getfield(%3, :size)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr90">│   </span> %44 = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr90">│   </span> %45 = Base.getfield(%43, 1, %44)<span class="sgr36">::Int64</span>
<span class="sgr90">│   </span> %46 = Base.bitcast(UInt64, %45)<span class="sgr36">::UInt64</span>
<span class="sgr90">│   </span> %47 = Base.ult_int(%42, %46)<span class="sgr36">::Bool</span>
<span class="sgr90">└───</span>       goto #18 if not %47
<span class="sgr90">17 ─</span>       goto #19
<span class="sgr90">18 ─</span> %50 = Core.tuple(%23)<span class="sgr36">::Tuple{Int64}</span>
<span class="sgr90">│   </span>       invoke Base.throw_boundserror(%3::Vector{Int64}, %50::Tuple{Int64})<span class="sgr90">::Union{}</span>
<span class="sgr90">└───</span>       unreachable
<span class="sgr90">19 ┄</span> %53 = Base.getfield(%3, :ref)<span class="sgr36">::MemoryRef{Int64}</span>
<span class="sgr90">│   </span> %54 = Base.memoryrefnew(%53, %23, false)<span class="sgr36">::MemoryRef{Int64}</span>
<span class="sgr90">│   </span>       Base.memoryrefset!(%54, %31, :not_atomic, false)<span class="sgr90">::Int64</span>
<span class="sgr90">└───</span>       goto #20
<span class="sgr90">20 ─</span> %57 = Base.add_int(%23, 1)<span class="sgr36">::Int64</span>
<span class="sgr90">└───</span>       goto #7
<span class="sgr90">21 ─</span>       goto #22
<span class="sgr90">22 ─</span>       goto #23
<span class="sgr90">23 ─</span>       goto #24
<span class="sgr90">24 ─</span>       return %3
) =&gt; Vector{Int64}</code></pre><ul><li>LLVM code generation</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_llvm f()</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr90">; Function Signature: f()</span>
<span class="sgr90">;  @ REPL[1]:1 within `f`</span>
<span class="sgr95">define</span> <span class="sgr95">nonnull</span> <span class="sgr95">ptr</span> <span class="sgr93">@julia_f_36778</span><span class="sgr33">()</span> #0 <span class="sgr33">{</span>
<span class="sgr91">L18:</span>
  %gcframe1 = <span class="sgr96"><span class="sgr1">alloca</span></span> <span class="sgr33">[3</span> x <span class="sgr95">ptr</span><span class="sgr33">]</span>, <span class="sgr95">align</span> <span class="sgr33">16</span>
  <span class="sgr96"><span class="sgr1">call</span></span> <span class="sgr36">void</span> <span class="sgr93">@llvm.memset.p0.i64</span><span class="sgr33">(</span><span class="sgr95">ptr</span> <span class="sgr95">align</span> <span class="sgr33">16</span> %gcframe1, <span class="sgr36">i8</span> <span class="sgr33">0</span>, <span class="sgr36">i64</span> <span class="sgr33">24</span>, <span class="sgr36">i1</span> <span class="sgr95">true</span><span class="sgr33">)</span>
  %thread_ptr = <span class="sgr95">call</span> <span class="sgr95">ptr</span> <span class="sgr95">asm</span> &quot;movq %fs:0, $0&quot;, &quot;=r&quot;<span class="sgr33">()</span> #10
  %tls_ppgcstack = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr36">i8</span>, <span class="sgr95">ptr</span> %thread_ptr, <span class="sgr36">i64</span> <span class="sgr33">-8</span>
  %tls_pgcstack = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %tls_ppgcstack, <span class="sgr95">align</span> <span class="sgr33">8</span>
  <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr36">i64</span> <span class="sgr33">4</span>, <span class="sgr95">ptr</span> %gcframe1, <span class="sgr95">align</span> <span class="sgr33">16</span>
  %frame.prev = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %gcframe1, <span class="sgr36">i64</span> <span class="sgr33">1</span>
  %task.gcstack = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %tls_pgcstack, <span class="sgr95">align</span> <span class="sgr33">8</span>
  <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr95">ptr</span> %task.gcstack, <span class="sgr95">ptr</span> %frame.prev, <span class="sgr95">align</span> <span class="sgr33">8</span>
  <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr95">ptr</span> %gcframe1, <span class="sgr95">ptr</span> %tls_pgcstack, <span class="sgr95">align</span> <span class="sgr33">8</span>
<span class="sgr90">; ┌ @ array.jl:785 within `collect`</span>
<span class="sgr90">; │┌ @ array.jl:665 within `_array_for`</span>
<span class="sgr90">; ││┌ @ abstractarray.jl:867 within `similar` @ abstractarray.jl:868</span>
<span class="sgr90">; │││┌ @ boot.jl:591 within `Array` @ boot.jl:578</span>
<span class="sgr90">; ││││┌ @ boot.jl:516 within `GenericMemory`</span>
       %&quot;Memory{Int64}[]&quot; = <span class="sgr96"><span class="sgr1">call</span></span> <span class="sgr95">ptr</span> <span class="sgr93">@jl_alloc_genericmemory</span><span class="sgr33">(</span><span class="sgr95">ptr</span> <span class="sgr95">nonnull</span> <span class="sgr93">@&quot;+Core.GenericMemory#36780.jit&quot;</span>, <span class="sgr36">i64</span> <span class="sgr33">10)</span>
<span class="sgr90">; ││││└</span>
<span class="sgr90">; ││││ @ boot.jl:591 within `Array` @ boot.jl:579</span>
<span class="sgr90">; ││││┌ @ boot.jl:522 within `memoryref`</span>
       %.data_ptr = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr33">{</span> <span class="sgr36">i64</span>, <span class="sgr95">ptr</span> <span class="sgr33">}</span>, <span class="sgr95">ptr</span> %&quot;Memory<span class="sgr33">{</span>Int64<span class="sgr33">}[]</span>&quot;, <span class="sgr36">i64</span> <span class="sgr33">0</span>, <span class="sgr36">i32</span> <span class="sgr33">1</span>
       %0 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %.data_ptr, <span class="sgr95">align</span> <span class="sgr33">8</span>
       %gc_slot_addr_0 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %gcframe1, <span class="sgr36">i64</span> <span class="sgr33">2</span>
       <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr95">ptr</span> %&quot;Memory<span class="sgr33">{</span>Int64<span class="sgr33">}[]</span>&quot;, <span class="sgr95">ptr</span> %gc_slot_addr_0, <span class="sgr95">align</span> <span class="sgr33">16</span>
<span class="sgr90">; ││││└</span>
      %ptls_field = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %tls_pgcstack, <span class="sgr36">i64</span> <span class="sgr33">2</span>
      %ptls_load = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %ptls_field, <span class="sgr95">align</span> <span class="sgr33">8</span>
      <span class="sgr91">%&quot;new:</span>:Array&quot; = <span class="sgr95">call</span> <span class="sgr95">noalias</span> <span class="sgr95">nonnull</span> <span class="sgr95">align</span> <span class="sgr33">8</span> <span class="sgr95">dereferenceable</span><span class="sgr33">(32)</span> <span class="sgr95">ptr</span> <span class="sgr93">@ijl_gc_pool_alloc_instrumented</span><span class="sgr33">(</span><span class="sgr95">ptr</span> %ptls_load, <span class="sgr36">i32</span> <span class="sgr33">800</span>, <span class="sgr36">i32</span> <span class="sgr33">32</span>, <span class="sgr36">i64</span> <span class="sgr33">140690050421184)</span> #8
      <span class="sgr91">%&quot;new:</span>:Array.tag_addr&quot; = <span class="sgr95">getelementptr</span> <span class="sgr95">inbounds</span> <span class="sgr36">i64</span>, <span class="sgr95">ptr</span> %&quot;new::Array&quot;, <span class="sgr36">i64</span> <span class="sgr33">-1</span>
      <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr95">atomic</span> <span class="sgr36">i64</span> <span class="sgr33">140690050421184</span>, <span class="sgr95">ptr</span> %&quot;new::Array.tag_addr&quot; <span class="sgr95">unordered</span>, <span class="sgr95">align</span> <span class="sgr33">8</span>
      %1 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %&quot;new::Array&quot;, <span class="sgr36">i64</span> <span class="sgr33">1</span>
      <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr95">ptr</span> %0, <span class="sgr95">ptr</span> %&quot;new::Array&quot;, <span class="sgr95">align</span> <span class="sgr33">8</span>
      <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr95">ptr</span> %&quot;Memory<span class="sgr33">{</span>Int64<span class="sgr33">}[]</span>&quot;, <span class="sgr95">ptr</span> %1, <span class="sgr95">align</span> <span class="sgr33">8</span>
      <span class="sgr91">%&quot;new:</span>:Array.size_ptr&quot; = <span class="sgr95">getelementptr</span> <span class="sgr95">inbounds</span> <span class="sgr36">i8</span>, <span class="sgr95">ptr</span> %&quot;new::Array&quot;, <span class="sgr36">i64</span> <span class="sgr33">16</span>
      <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr36">i64</span> <span class="sgr33">10</span>, <span class="sgr95">ptr</span> %&quot;new::Array.size_ptr&quot;, <span class="sgr95">align</span> <span class="sgr33">8</span>
<span class="sgr90">; │└└└</span>
<span class="sgr90">; │ @ array.jl:790 within `collect`</span>
<span class="sgr90">; │┌ @ array.jl:815 within `collect_to_with_first!`</span>
<span class="sgr90">; ││┌ @ array.jl:976 within `setindex!`</span>
     <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr33">&lt;4</span> x <span class="sgr36">i64</span><span class="sgr33">&gt;</span> <span class="sgr33">&lt;</span><span class="sgr36">i64</span> <span class="sgr33">1</span>, <span class="sgr36">i64</span> <span class="sgr33">2</span>, <span class="sgr36">i64</span> <span class="sgr33">3</span>, <span class="sgr36">i64</span> <span class="sgr33">4&gt;</span>, <span class="sgr95">ptr</span> %0, <span class="sgr95">align</span> <span class="sgr33">8</span>
<span class="sgr90">; ││└</span>
<span class="sgr90">; ││ @ array.jl:816 within `collect_to_with_first!`</span>
<span class="sgr90">; ││┌ @ array.jl:842 within `collect_to!`</span>
<span class="sgr90">; │││┌ @ array.jl:976 within `setindex!`</span>
      %2 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">i64</span>, <span class="sgr95">ptr</span> %0, <span class="sgr36">i64</span> <span class="sgr33">4</span>
      <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr33">&lt;4</span> x <span class="sgr36">i64</span><span class="sgr33">&gt;</span> <span class="sgr33">&lt;</span><span class="sgr36">i64</span> <span class="sgr33">5</span>, <span class="sgr36">i64</span> <span class="sgr33">6</span>, <span class="sgr36">i64</span> <span class="sgr33">7</span>, <span class="sgr36">i64</span> <span class="sgr33">8&gt;</span>, <span class="sgr95">ptr</span> %2, <span class="sgr95">align</span> <span class="sgr33">8</span>
      %3 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">i64</span>, <span class="sgr95">ptr</span> %0, <span class="sgr36">i64</span> <span class="sgr33">8</span>
      <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr36">i64</span> <span class="sgr33">9</span>, <span class="sgr95">ptr</span> %3, <span class="sgr95">align</span> <span class="sgr33">8</span>
      %4 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">i64</span>, <span class="sgr95">ptr</span> %0, <span class="sgr36">i64</span> <span class="sgr33">9</span>
      <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr36">i64</span> <span class="sgr33">10</span>, <span class="sgr95">ptr</span> %4, <span class="sgr95">align</span> <span class="sgr33">8</span>
      %frame.prev37 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %frame.prev, <span class="sgr95">align</span> <span class="sgr33">8</span>
      <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr95">ptr</span> %frame.prev37, <span class="sgr95">ptr</span> %tls_pgcstack, <span class="sgr95">align</span> <span class="sgr33">8</span>
<span class="sgr90">; ││└└</span>
    <span class="sgr96"><span class="sgr1">ret</span></span> <span class="sgr95">ptr</span> %&quot;new::Array&quot;
<span class="sgr90">; └└</span>
<span class="sgr33">}</span></code></pre><ul><li>native code generation</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_native f()</code><code class="nohighlight hljs ansi" style="display:block;">	.text
	.file	&quot;f&quot;
	.section	.rodata.cst32,&quot;aM&quot;,@progbits,<span class="sgr33">32</span>
	.p2align	<span class="sgr33">5</span>, <span class="sgr33">0x0</span>                          <span class="sgr90"># -- Begin function julia_f_36961</span>
<span class="sgr91">.LCPI0_0:</span>
	.quad	<span class="sgr33">1</span>                               <span class="sgr90"># 0x1</span>
	.quad	<span class="sgr33">2</span>                               <span class="sgr90"># 0x2</span>
	.quad	<span class="sgr33">3</span>                               <span class="sgr90"># 0x3</span>
	.quad	<span class="sgr33">4</span>                               <span class="sgr90"># 0x4</span>
<span class="sgr91">.LCPI0_1:</span>
	.quad	<span class="sgr33">5</span>                               <span class="sgr90"># 0x5</span>
	.quad	<span class="sgr33">6</span>                               <span class="sgr90"># 0x6</span>
	.quad	<span class="sgr33">7</span>                               <span class="sgr90"># 0x7</span>
	.quad	<span class="sgr33">8</span>                               <span class="sgr90"># 0x8</span>
	.text
	.globl	julia_f_36961
	.p2align	<span class="sgr33">4</span>, <span class="sgr33">0x90</span>
	.type	julia_f_36961,@function
<span class="sgr91">julia_f_36961:</span>                          <span class="sgr90"># @julia_f_36961</span>
<span class="sgr90">; Function Signature: f()</span>
<span class="sgr90">; ┌ @ REPL[1]:1 within `f`</span>
<span class="sgr90"># %bb.0:                                # %L18</span>
	<span class="sgr96"><span class="sgr1">push</span></span>	rbp
	<span class="sgr96"><span class="sgr1">mov</span></span>	rbp, rsp
	<span class="sgr96"><span class="sgr1">push</span></span>	r15
	<span class="sgr96"><span class="sgr1">push</span></span>	r14
	<span class="sgr96"><span class="sgr1">push</span></span>	r12
	<span class="sgr96"><span class="sgr1">push</span></span>	rbx
	<span class="sgr96"><span class="sgr1">sub</span></span>	rsp, <span class="sgr33">32</span>
	<span class="sgr96"><span class="sgr1">vxorps</span></span>	xmm0, xmm0, xmm0
	<span class="sgr96"><span class="sgr1">vmovaps</span></span>	<span class="sgr95">xmmword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rbp - <span class="sgr33">64]</span>, xmm0
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rbp - <span class="sgr33">48]</span>, <span class="sgr33">0</span>
	#APP
	<span class="sgr96"><span class="sgr1">mov</span></span>	rax, <span class="sgr95">qword</span> <span class="sgr95">ptr</span> fs:<span class="sgr33">[0]</span>
	#NO_APP
	<span class="sgr96"><span class="sgr1">lea</span></span>	rcx, <span class="sgr33">[</span>rbp - <span class="sgr33">64]</span>
<span class="sgr90">; │┌ @ array.jl:785 within `collect`</span>
<span class="sgr90">; ││┌ @ array.jl:665 within `_array_for`</span>
<span class="sgr90">; │││┌ @ abstractarray.jl:867 within `similar` @ abstractarray.jl:868</span>
<span class="sgr90">; ││││┌ @ boot.jl:591 within `Array` @ boot.jl:578</span>
<span class="sgr90">; │││││┌ @ boot.jl:516 within `GenericMemory`</span>
	<span class="sgr96"><span class="sgr1">movabs</span></span>	rdi, <span class="sgr95">offset</span> <span class="sgr93">&quot;.L+Core.GenericMemory#36963.jit&quot;</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	esi, <span class="sgr33">10</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	r15, <span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rax - <span class="sgr33">8]</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rbp - <span class="sgr33">64]</span>, <span class="sgr33">4</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	rax, <span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>r15<span class="sgr33">]</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rbp - <span class="sgr33">56]</span>, rax
	<span class="sgr96"><span class="sgr1">movabs</span></span>	rax, <span class="sgr95">offset</span> <span class="sgr93">jl_alloc_genericmemory</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>r15<span class="sgr33">]</span>, rcx
	<span class="sgr96"><span class="sgr1">call</span></span>	rax
<span class="sgr90">; │││││└</span>
<span class="sgr90">; │││││ @ boot.jl:591 within `Array` @ boot.jl:579</span>
<span class="sgr90">; │││││┌ @ boot.jl:522 within `memoryref`</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	r12, <span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rax + <span class="sgr33">8]</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rbp - <span class="sgr33">48]</span>, rax
<span class="sgr90">; │││││└</span>
<span class="sgr90">; │││││ @ boot.jl:591 within `Array` @ boot.jl:578</span>
<span class="sgr90">; │││││┌ @ boot.jl:516 within `GenericMemory`</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	rbx, rax
	<span class="sgr96"><span class="sgr1">movabs</span></span>	r14, <span class="sgr33">140690050421184</span>
<span class="sgr90">; │││││└</span>
<span class="sgr90">; │││││ @ boot.jl:591 within `Array` @ boot.jl:579</span>
	<span class="sgr96"><span class="sgr1">movabs</span></span>	rax, <span class="sgr95">offset</span> <span class="sgr93">ijl_gc_pool_alloc_instrumented</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	esi, <span class="sgr33">800</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	edx, <span class="sgr33">32</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	rdi, <span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>r15 + <span class="sgr33">16]</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	rcx, r14
	<span class="sgr96"><span class="sgr1">call</span></span>	rax
	<span class="sgr96"><span class="sgr1">movabs</span></span>	rcx, <span class="sgr95">offset</span> .LCPI0_0
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rax - <span class="sgr33">8]</span>, r14
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rax<span class="sgr33">]</span>, r12
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rax + <span class="sgr33">8]</span>, rbx
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rax + <span class="sgr33">16]</span>, <span class="sgr33">10</span>
<span class="sgr90">; ││└└└</span>
<span class="sgr90">; ││ @ array.jl:790 within `collect`</span>
<span class="sgr90">; ││┌ @ array.jl:815 within `collect_to_with_first!`</span>
<span class="sgr90">; │││┌ @ array.jl:976 within `setindex!`</span>
	<span class="sgr96"><span class="sgr1">vmovaps</span></span>	ymm0, <span class="sgr95">ymmword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rcx<span class="sgr33">]</span>
	<span class="sgr96"><span class="sgr1">movabs</span></span>	rcx, <span class="sgr95">offset</span> .LCPI0_1
<span class="sgr90">; │││└</span>
<span class="sgr90">; │││ @ array.jl:816 within `collect_to_with_first!`</span>
<span class="sgr90">; │││┌ @ array.jl:842 within `collect_to!`</span>
<span class="sgr90">; ││││┌ @ array.jl:976 within `setindex!`</span>
	<span class="sgr96"><span class="sgr1">vmovaps</span></span>	ymm1, <span class="sgr95">ymmword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rcx<span class="sgr33">]</span>
<span class="sgr90">; │││└└</span>
<span class="sgr90">; │││ @ array.jl:815 within `collect_to_with_first!`</span>
<span class="sgr90">; │││┌ @ array.jl:976 within `setindex!`</span>
	<span class="sgr96"><span class="sgr1">vmovups</span></span>	<span class="sgr95">ymmword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>r12<span class="sgr33">]</span>, ymm0
<span class="sgr90">; │││└</span>
<span class="sgr90">; │││ @ array.jl:816 within `collect_to_with_first!`</span>
<span class="sgr90">; │││┌ @ array.jl:842 within `collect_to!`</span>
<span class="sgr90">; ││││┌ @ array.jl:976 within `setindex!`</span>
	<span class="sgr96"><span class="sgr1">vmovups</span></span>	<span class="sgr95">ymmword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>r12 + <span class="sgr33">32]</span>, ymm1
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>r12 + <span class="sgr33">64]</span>, <span class="sgr33">9</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>r12 + <span class="sgr33">72]</span>, <span class="sgr33">10</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	rcx, <span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>rbp - <span class="sgr33">56]</span>
	<span class="sgr96"><span class="sgr1">mov</span></span>	<span class="sgr95">qword</span> <span class="sgr95">ptr</span> <span class="sgr33">[</span>r15<span class="sgr33">]</span>, rcx
<span class="sgr90">; │││└└</span>
	<span class="sgr96"><span class="sgr1">add</span></span>	rsp, <span class="sgr33">32</span>
	<span class="sgr96"><span class="sgr1">pop</span></span>	rbx
	<span class="sgr96"><span class="sgr1">pop</span></span>	r12
	<span class="sgr96"><span class="sgr1">pop</span></span>	r14
	<span class="sgr96"><span class="sgr1">pop</span></span>	r15
	<span class="sgr96"><span class="sgr1">pop</span></span>	rbp
	<span class="sgr96"><span class="sgr1">vzeroupper</span></span>
	<span class="sgr96"><span class="sgr1">ret</span></span>
<span class="sgr91">.Lfunc_end0:</span>
	.size	julia_f_36961, .Lfunc_end0-julia_f_36961
<span class="sgr90">; └└└</span>
                                        <span class="sgr90"># -- End function</span>
	.type	&quot;.L_j_const#2&quot;,@object          <span class="sgr90"># @&quot;_j_const#2&quot;</span>
	.section	.rodata.cst8,&quot;aM&quot;,@progbits,<span class="sgr33">8</span>
	.p2align	<span class="sgr33">3</span>, <span class="sgr33">0x0</span>
<span class="sgr91">&quot;.L_j_const#2&quot;:</span>
	.quad	<span class="sgr33">1</span>                               <span class="sgr90"># 0x1</span>
	.size	&quot;.L_j_const#2&quot;, <span class="sgr33">8</span>

.set &quot;.L+Core.Array#36965.jit&quot;, <span class="sgr33">140690050421184</span>
	.size	&quot;.L+Core.Array#36965.jit&quot;, <span class="sgr33">8</span>
.set &quot;.L+Core.GenericMemory#36963.jit&quot;, <span class="sgr33">140690092581264</span>
	.size	&quot;.L+Core.GenericMemory#36963.jit&quot;, <span class="sgr33">8</span>
	.section	&quot;.note.GNU-stack&quot;,&quot;&quot;,@progbits</code></pre><p>Let&#39;s see how these tools can help us understand some of Julia&#39;s internals on examples from previous labs and lectures.</p><h3 id="Understanding-runtime-dispatch-and-type-instabilities"><a class="docs-heading-anchor" href="#Understanding-runtime-dispatch-and-type-instabilities">Understanding runtime dispatch and type instabilities</a><a id="Understanding-runtime-dispatch-and-type-instabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-runtime-dispatch-and-type-instabilities" title="Permalink"></a></h3><p>We will start with a question: Can we spot internally some difference between type stable/unstable code?</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Inspect the following two functions using <code>@code_lowered</code>, <code>@code_typed</code>, <code>@code_llvm</code> and <code>@code_native</code>.</p><pre><code class="language-julia hljs">x = rand(10^5)
function explicit_len(x)
    length(x)
end

function implicit_len()
    length(x)
end</code></pre><p>For now do not try to understand the details, but focus on the overall differences such as length of the code.</p><div class="admonition is-info"><header class="admonition-header">Redirecting `stdout`</header><div class="admonition-body"><p>If the output of the method introspection tools is too long you can use a general way of redirecting standard output <code>stdout</code> to a file</p><pre><code class="language-julia hljs">open(&quot;./llvm_fun.ll&quot;, &quot;w&quot;) do file
    original_stdout = stdout
    redirect_stdout(file)
    @code_llvm fun()
    redirect_stdout(original_stdout)
end</code></pre><p>In case of <code>@code_llvm</code> and <code>@code_native</code> there are special options, that allow this out of the box, see help <code>?</code> for underlying <code>code_llvm</code> and <code>code_native</code>. If you don&#39;t mind adding dependencies there is also the <code>@capture_out</code> from <a href="https://github.com/JuliaIO/Suppressor.jl"><code>Suppressor.jl</code></a></p></div></div></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">@code_warntype explicit_sum(x)
@code_warntype implicit_sum()

@code_typed explicit_sum(x)
@code_typed implicit_sum()

@code_llvm explicit_sum(x)
@code_llvm implicit_sum()

@code_native explicit_sum(x)
@code_native implicit_sum()</code></pre><p>In this case we see that the generated code for such a simple operation is much longer in the type unstable case resulting in longer run times. However in the next example we will see that having longer code is not always a bad thing.</p></p></details><h3 id="Loop-unrolling"><a class="docs-heading-anchor" href="#Loop-unrolling">Loop unrolling</a><a id="Loop-unrolling-1"></a><a class="docs-heading-anchor-permalink" href="#Loop-unrolling" title="Permalink"></a></h3><p>In some cases the compiler uses loop unrolling<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> optimization to speed up loops at the expense of binary size. The result of such optimization is removal of the loop control instructions and rewriting the loop into a repeated sequence of independent statements.</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Inspect under what conditions does the compiler unroll the for loop in the <code>polynomial</code> function from the last <a href="../../lecture_05/lab/#horner">lab</a>.</p><pre><code class="language-julia hljs">function polynomial(a, x)
    accumulator = a[end] * one(x)
    for i in length(a)-1:-1:1
        accumulator = accumulator * x + a[i]
    end
    accumulator
end</code></pre><p>Compare the speed of execution with and without loop unrolling.</p><p><strong>HINTS</strong>:</p><ul><li>these kind of optimization are lower level than intermediate language</li><li>loop unrolling is possible when compiler knows the length of the input</li></ul></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">using BenchmarkTools
a = Tuple(ones(20)) # tuple has known size
ac = collect(a)
x = 2.0

@code_lowered polynomial(a,x)       # cannot be seen here as optimizations are not applied
@code_typed polynomial(a,x)         # loop unrolling is not part of type inference optimization</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_llvm polynomial(a,x)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr90">; Function Signature: polynomial(NTuple{20, Float64}, Float64)</span>
<span class="sgr90">;  @ lab.md:113 within `polynomial`</span>
<span class="sgr95">define</span> <span class="sgr36">double</span> <span class="sgr93">@julia_polynomial_37341</span><span class="sgr33">(</span><span class="sgr95">ptr</span> <span class="sgr95">nocapture</span> <span class="sgr95">noundef</span> <span class="sgr95">nonnull</span> <span class="sgr95">readonly</span> <span class="sgr95">align</span> <span class="sgr33">8</span> <span class="sgr95">dereferenceable</span><span class="sgr33">(160)</span> %&quot;a::Tuple&quot;, <span class="sgr36">double</span> %&quot;x::Float64&quot;<span class="sgr33">)</span> #0 <span class="sgr33">{</span>
<span class="sgr91">pass.18:</span>
<span class="sgr90">;  @ lab.md:114 within `polynomial`</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   <span class="sgr91">%&quot;a:</span>:Tuple<span class="sgr33">[20]</span>_ptr&quot; = <span class="sgr95">getelementptr</span> <span class="sgr95">inbounds</span> <span class="sgr33">[20</span> x <span class="sgr36">double</span><span class="sgr33">]</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">0</span>, <span class="sgr36">i64</span> <span class="sgr33">19</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   <span class="sgr91">%&quot;a:</span>:Tuple<span class="sgr33">[20]</span>_ptr.unbox&quot; = <span class="sgr95">load</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple<span class="sgr33">[20]</span>_ptr&quot;, <span class="sgr95">align</span> <span class="sgr33">8</span>
<span class="sgr90">; └</span>
<span class="sgr90">;  @ lab.md:116 within `polynomial`</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %0 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %&quot;a::Tuple<span class="sgr33">[20]</span>_ptr.unbox&quot;, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %1 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">18</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %1, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %2 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %0, %.unbox
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %3 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %2, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %4 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">17</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.1 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %4, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %5 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %3, %.unbox.1
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %6 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %5, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %7 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">16</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.2 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %7, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %8 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %6, %.unbox.2
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %9 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %8, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %10 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">15</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.3 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %10, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %11 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %9, %.unbox.3
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %12 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %11, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %13 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">14</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.4 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %13, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %14 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %12, %.unbox.4
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %15 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %14, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %16 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">13</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.5 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %16, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %17 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %15, %.unbox.5
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %18 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %17, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %19 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">12</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.6 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %19, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %20 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %18, %.unbox.6
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %21 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %20, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %22 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">11</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.7 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %22, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %23 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %21, %.unbox.7
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %24 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %23, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %25 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">10</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.8 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %25, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %26 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %24, %.unbox.8
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %27 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %26, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %28 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">9</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.9 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %28, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %29 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %27, %.unbox.9
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %30 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %29, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %31 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">8</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.10 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %31, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %32 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %30, %.unbox.10
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %33 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %32, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %34 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">7</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.11 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %34, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %35 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %33, %.unbox.11
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %36 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %35, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %37 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">6</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.12 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %37, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %38 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %36, %.unbox.12
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %39 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %38, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %40 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">5</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.13 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %40, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %41 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %39, %.unbox.13
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %42 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %41, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %43 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">4</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.14 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %43, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %44 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %42, %.unbox.14
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %45 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %44, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %46 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">3</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.15 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %46, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %47 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %45, %.unbox.15
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %48 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %47, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %49 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">2</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.16 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %49, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %50 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %48, %.unbox.16
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %51 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %50, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ tuple.jl:31 within `getindex`</span>
   %52 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr36">i64</span> <span class="sgr33">1</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.17 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %52, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %53 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %51, %.unbox.17
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %54 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %53, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %.unbox.18 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %&quot;a::Tuple&quot;, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %55 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %54, %.unbox.18
<span class="sgr90">; └</span>
<span class="sgr90">;  @ lab.md:117 within `polynomial`</span>
  <span class="sgr96"><span class="sgr1">ret</span></span> <span class="sgr36">double</span> %55
<span class="sgr33">}</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_llvm polynomial(ac,x)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr90">; Function Signature: polynomial(Array{Float64, 1}, Float64)</span>
<span class="sgr90">;  @ lab.md:113 within `polynomial`</span>
<span class="sgr95">define</span> <span class="sgr36">double</span> <span class="sgr93">@julia_polynomial_37351</span><span class="sgr33">(</span><span class="sgr95">ptr</span> <span class="sgr95">noundef</span> <span class="sgr95">nonnull</span> <span class="sgr95">align</span> <span class="sgr33">8</span> <span class="sgr95">dereferenceable</span><span class="sgr33">(24)</span> %&quot;a::Array&quot;, <span class="sgr36">double</span> %&quot;x::Float64&quot;<span class="sgr33">)</span> #0 <span class="sgr33">{</span>
<span class="sgr91">top:</span>
  <span class="sgr91">%&quot;new:</span>:Tuple&quot; = <span class="sgr95">alloca</span> <span class="sgr33">[1</span> x <span class="sgr36">i64</span><span class="sgr33">]</span>, <span class="sgr95">align</span> <span class="sgr33">8</span>
  <span class="sgr91">%&quot;new:</span>:Tuple60&quot; = <span class="sgr95">alloca</span> <span class="sgr33">[1</span> x <span class="sgr36">i64</span><span class="sgr33">]</span>, <span class="sgr95">align</span> <span class="sgr33">8</span>
<span class="sgr90">;  @ lab.md:114 within `polynomial`</span>
<span class="sgr90">; ┌ @ abstractarray.jl:426 within `lastindex`</span>
<span class="sgr90">; │┌ @ abstractarray.jl:389 within `eachindex`</span>
<span class="sgr90">; ││┌ @ abstractarray.jl:137 within `axes1`</span>
<span class="sgr90">; │││┌ @ abstractarray.jl:98 within `axes`</span>
<span class="sgr90">; ││││┌ @ array.jl:194 within `size`</span>
       %0 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">i8</span>, <span class="sgr95">ptr</span> %&quot;a::Array&quot;, <span class="sgr36">i64</span> <span class="sgr33">16</span>
       %.size.sroa.0.0.copyload = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">i64</span>, <span class="sgr95">ptr</span> %0, <span class="sgr95">align</span> <span class="sgr33">8</span>
<span class="sgr90">; └└└└└</span>
<span class="sgr90">; ┌ @ essentials.jl:915 within `getindex`</span>
   %1 = <span class="sgr96"><span class="sgr1">add</span></span> <span class="sgr36">i64</span> %.size.sroa.0.0.copyload, <span class="sgr33">-1</span>
   %.not.not = <span class="sgr96"><span class="sgr1">icmp</span></span> <span class="sgr96"><span class="sgr1">eq</span></span> <span class="sgr36">i64</span> %.size.sroa.0.0.copyload, <span class="sgr33">0</span>
   <span class="sgr96"><span class="sgr1">br</span></span> <span class="sgr36">i1</span> %.not.not, <span class="sgr36">label</span> <span class="sgr91">%L15</span>, <span class="sgr36">label</span> <span class="sgr91">%L18</span>

<span class="sgr91">L15:</span>                                              <span class="sgr90">; preds = %top</span>
   <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr36">i64</span> <span class="sgr33">0</span>, <span class="sgr95">ptr</span> %&quot;new::Tuple60&quot;, <span class="sgr95">align</span> <span class="sgr33">8</span>
   <span class="sgr96"><span class="sgr1">call</span></span> <span class="sgr36">void</span> <span class="sgr93">@j_throw_boundserror_37370</span><span class="sgr33">(</span><span class="sgr95">ptr</span> <span class="sgr95">nonnull</span> %&quot;a::Array&quot;, <span class="sgr95">ptr</span> <span class="sgr95">nocapture</span> <span class="sgr95">nonnull</span> <span class="sgr95">readonly</span> %&quot;new::Tuple60&quot;<span class="sgr33">)</span> #11
   <span class="sgr96"><span class="sgr1">unreachable</span></span>

<span class="sgr91">L18:</span>                                              <span class="sgr90">; preds = %top</span>
<span class="sgr90">; │ @ essentials.jl:916 within `getindex`</span>
   %2 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr95">ptr</span>, <span class="sgr95">ptr</span> %&quot;a::Array&quot;, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %3 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %2, <span class="sgr36">i64</span> %1
   %4 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %3, <span class="sgr95">align</span> <span class="sgr33">8</span>
   %5 = <span class="sgr96"><span class="sgr1">icmp</span></span> <span class="sgr96"><span class="sgr1">sgt</span></span> <span class="sgr36">i64</span> %1, <span class="sgr33">0</span>
<span class="sgr90">; └</span>
<span class="sgr90">;  @ lab.md:115 within `polynomial`</span>
<span class="sgr90">; ┌ @ range.jl:22 within `Colon`</span>
<span class="sgr90">; │┌ @ range.jl:24 within `_colon`</span>
<span class="sgr90">; ││┌ @ range.jl:384 within `StepRange` @ range.jl:329</span>
<span class="sgr90">; │││┌ @ range.jl:344 within `steprange_last`</span>
      <span class="sgr96"><span class="sgr1">br</span></span> <span class="sgr36">i1</span> %5, <span class="sgr36">label</span> <span class="sgr91">%L78.preheader</span>, <span class="sgr36">label</span> <span class="sgr91">%L64</span>

<span class="sgr91">L64:</span>                                              <span class="sgr90">; preds = %L18</span>
<span class="sgr90">; └└└└</span>
<span class="sgr90">; ┌ @ range.jl:904 within `iterate`</span>
<span class="sgr90">; │┌ @ range.jl:678 within `isempty`</span>
<span class="sgr90">; ││┌ @ operators.jl:379 within `&gt;`</span>
<span class="sgr90">; │││┌ @ int.jl:83 within `&lt;`</span>
      %.not74.not.not.not = <span class="sgr96"><span class="sgr1">icmp</span></span> <span class="sgr96"><span class="sgr1">eq</span></span> <span class="sgr36">i64</span> %.size.sroa.0.0.copyload, <span class="sgr33">-9223372036854775808</span>
<span class="sgr90">; └└└└</span>
  <span class="sgr96"><span class="sgr1">br</span></span> <span class="sgr36">i1</span> %.not74.not.not.not, <span class="sgr36">label</span> <span class="sgr91">%L78.preheader</span>, <span class="sgr36">label</span> <span class="sgr91">%L112</span>

<span class="sgr91">L78.preheader:</span>                                    <span class="sgr90">; preds = %L64, %L18</span>
  %value_phi81 = <span class="sgr96"><span class="sgr1">phi</span></span> <span class="sgr36">i64</span> <span class="sgr33">[</span> <span class="sgr33">-9223372036854775808</span>, <span class="sgr91">%L64</span> <span class="sgr33">]</span>, <span class="sgr33">[</span> <span class="sgr33">1</span>, <span class="sgr91">%L18</span> <span class="sgr33">]</span>
<span class="sgr90">;  @ lab.md:116 within `polynomial`</span>
<span class="sgr90">; ┌ @ essentials.jl:915 within `getindex`</span>
   <span class="sgr96"><span class="sgr1">br</span></span> <span class="sgr36">label</span> <span class="sgr91">%L78</span>

<span class="sgr91">L78:</span>                                              <span class="sgr90">; preds = %L96, %L78.preheader</span>
   %value_phi20 = <span class="sgr96"><span class="sgr1">phi</span></span> <span class="sgr36">i64</span> <span class="sgr33">[</span> %6, <span class="sgr91">%L96</span> <span class="sgr33">]</span>, <span class="sgr33">[</span> %1, <span class="sgr91">%L78.preheader</span> <span class="sgr33">]</span>
   %value_phi22 = <span class="sgr96"><span class="sgr1">phi</span></span> <span class="sgr36">double</span> <span class="sgr33">[</span> %10, <span class="sgr91">%L96</span> <span class="sgr33">]</span>, <span class="sgr33">[</span> %4, <span class="sgr91">%L78.preheader</span> <span class="sgr33">]</span>
   %6 = <span class="sgr96"><span class="sgr1">add</span></span> <span class="sgr36">i64</span> %value_phi20, <span class="sgr33">-1</span>
   %.not75 = <span class="sgr96"><span class="sgr1">icmp</span></span> <span class="sgr96"><span class="sgr1">ult</span></span> <span class="sgr36">i64</span> %6, %.size.sroa.0.0.copyload
   <span class="sgr96"><span class="sgr1">br</span></span> <span class="sgr36">i1</span> %.not75, <span class="sgr36">label</span> <span class="sgr91">%L96</span>, <span class="sgr36">label</span> <span class="sgr91">%L93</span>

<span class="sgr91">L93:</span>                                              <span class="sgr90">; preds = %L78</span>
   <span class="sgr96"><span class="sgr1">store</span></span> <span class="sgr36">i64</span> %value_phi20, <span class="sgr95">ptr</span> %&quot;new::Tuple&quot;, <span class="sgr95">align</span> <span class="sgr33">8</span>
   <span class="sgr96"><span class="sgr1">call</span></span> <span class="sgr36">void</span> <span class="sgr93">@j_throw_boundserror_37370</span><span class="sgr33">(</span><span class="sgr95">ptr</span> <span class="sgr95">nonnull</span> %&quot;a::Array&quot;, <span class="sgr95">ptr</span> <span class="sgr95">nocapture</span> <span class="sgr95">nonnull</span> <span class="sgr95">readonly</span> %&quot;new::Tuple&quot;<span class="sgr33">)</span> #11
   <span class="sgr96"><span class="sgr1">unreachable</span></span>

<span class="sgr91">L96:</span>                                              <span class="sgr90">; preds = %L78</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:493 within `*`</span>
   %7 = <span class="sgr96"><span class="sgr1">fmul</span></span> <span class="sgr36">double</span> %value_phi22, %&quot;x::Float64&quot;
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ essentials.jl:916 within `getindex`</span>
   %8 = <span class="sgr96"><span class="sgr1">getelementptr</span></span> <span class="sgr95">inbounds</span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %2, <span class="sgr36">i64</span> %6
   %9 = <span class="sgr96"><span class="sgr1">load</span></span> <span class="sgr36">double</span>, <span class="sgr95">ptr</span> %8, <span class="sgr95">align</span> <span class="sgr33">8</span>
<span class="sgr90">; └</span>
<span class="sgr90">; ┌ @ float.jl:491 within `+`</span>
   %10 = <span class="sgr96"><span class="sgr1">fadd</span></span> <span class="sgr36">double</span> %7, %9
<span class="sgr90">; └</span>
<span class="sgr90">;  @ lab.md:117 within `polynomial`</span>
<span class="sgr90">; ┌ @ range.jl:908 within `iterate`</span>
<span class="sgr90">; │┌ @ promotion.jl:639 within `==`</span>
    %.not76.not = <span class="sgr96"><span class="sgr1">icmp</span></span> <span class="sgr96"><span class="sgr1">eq</span></span> <span class="sgr36">i64</span> %value_phi20, %value_phi81
<span class="sgr90">; └└</span>
  <span class="sgr96"><span class="sgr1">br</span></span> <span class="sgr36">i1</span> %.not76.not, <span class="sgr36">label</span> <span class="sgr91">%L112</span>, <span class="sgr36">label</span> <span class="sgr91">%L78</span>

<span class="sgr91">L112:</span>                                             <span class="sgr90">; preds = %L96, %L64</span>
  %value_phi43 = <span class="sgr96"><span class="sgr1">phi</span></span> <span class="sgr36">double</span> <span class="sgr33">[</span> %4, <span class="sgr91">%L64</span> <span class="sgr33">]</span>, <span class="sgr33">[</span> %10, <span class="sgr91">%L96</span> <span class="sgr33">]</span>
<span class="sgr90">;  @ lab.md:118 within `polynomial`</span>
  <span class="sgr96"><span class="sgr1">ret</span></span> <span class="sgr36">double</span> %value_phi43
<span class="sgr33">}</span></code></pre><p>More than 2x speedup</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime polynomial($a,$x)</code><code class="nohighlight hljs ansi" style="display:block;">  8.905 ns (0 allocations: 0 bytes)
1.048575e6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime polynomial($ac,$x)</code><code class="nohighlight hljs ansi" style="display:block;">  16.975 ns (0 allocations: 0 bytes)
1.048575e6</code></pre></p></details><h3 id="Recursion-inlining-depth"><a class="docs-heading-anchor" href="#Recursion-inlining-depth">Recursion inlining depth</a><a id="Recursion-inlining-depth-1"></a><a class="docs-heading-anchor-permalink" href="#Recursion-inlining-depth" title="Permalink"></a></h3><p>Inlining<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> is another compiler optimization that allows us to speed up the code by avoiding function calls. Where applicable compiler can replace <code>f(args)</code> directly with the function body of <code>f</code>, thus removing the need to modify stack to transfer the control flow to a different place. This is yet another optimization that may improve speed at the expense of binary size.</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Rewrite the <code>polynomial</code> function from the last <a href="../../lecture_05/lab/#horner">lab</a> using recursion and find the length of the coefficients, at which inlining of the recursive calls stops occurring.</p><pre><code class="language-julia hljs">function polynomial(a, x)
    accumulator = a[end] * one(x)
    for i in length(a)-1:-1:1
        accumulator = accumulator * x + a[i]
    end
    accumulator  
end</code></pre><div class="admonition is-info"><header class="admonition-header">Splatting/slurping operator `...`</header><div class="admonition-body"><p>The operator <code>...</code> serves two purposes inside function calls <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup><sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>:</p><ul><li>combines multiple arguments into one</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function printargs(args...)
           println(typeof(args))
           for (i, arg) in enumerate(args)
               println(&quot;Arg #$i = $arg&quot;)
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">printargs (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; printargs(1, 2, 3)</code><code class="nohighlight hljs ansi" style="display:block;">Tuple{Int64, Int64, Int64}
Arg #1 = 1
Arg #2 = 2
Arg #3 = 3</code></pre><ul><li>splits one argument into many different arguments</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function threeargs(a, b, c)
           println(&quot;a = $a::$(typeof(a))&quot;)
           println(&quot;b = $b::$(typeof(b))&quot;)
           println(&quot;c = $c::$(typeof(c))&quot;)
       end</code><code class="nohighlight hljs ansi" style="display:block;">threeargs (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; threeargs([1,2,3]...) # or with a variable threeargs(x...)</code><code class="nohighlight hljs ansi" style="display:block;">a = 1::Int64
b = 2::Int64
c = 3::Int64</code></pre></div></div><p><strong>HINTS</strong>:</p><ul><li>define two methods <code>_polynomial!(ac, x, a...)</code> and <code>_polynomial!(ac, x, a)</code> for the case of ≥2 coefficients and the last coefficient</li><li>use splatting together with range indexing <code>a[1:end-1]...</code></li><li>the correctness can be checked using the built-in <code>evalpoly</code></li><li>recall that these kind of optimization are possible just around the type inference stage</li><li>use container of known length to store the coefficients</li></ul></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">_polynomial!(ac, x, a...) = _polynomial!(x * ac + a[end], x, a[1:end-1]...)
_polynomial!(ac, x, a) = x * ac + a
polynomial(a, x) = _polynomial!(a[end] * one(x), x, a[1:end-1]...)

# the coefficients have to be a tuple
a = Tuple(ones(Int, 21)) # everything less than 22 gets inlined
x = 2
polynomial(a,x) == evalpoly(x,a) # compare with built-in function

# @code_llvm polynomial(a,x)    # seen here too, but code_typed is a better option
@code_lowered polynomial(a,x) # cannot be seen here as optimizations are not applied</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @code_typed polynomial(a,x)</code><code class="nohighlight hljs ansi" style="display:block;">CodeInfo(
<span class="sgr90">1 ─</span> %1  = $(Expr(:boundscheck, true))<span class="sgr36">::Bool</span>
<span class="sgr90">│  </span> %2  = Base.getfield(a, 21, %1)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %3  = Base.mul_int(%2, 1)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %4  = Core.getfield(a, 1)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %5  = Core.getfield(a, 2)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %6  = Core.getfield(a, 3)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %7  = Core.getfield(a, 4)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %8  = Core.getfield(a, 5)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %9  = Core.getfield(a, 6)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %10 = Core.getfield(a, 7)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %11 = Core.getfield(a, 8)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %12 = Core.getfield(a, 9)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %13 = Core.getfield(a, 10)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %14 = Core.getfield(a, 11)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %15 = Core.getfield(a, 12)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %16 = Core.getfield(a, 13)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %17 = Core.getfield(a, 14)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %18 = Core.getfield(a, 15)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %19 = Core.getfield(a, 16)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %20 = Core.getfield(a, 17)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %21 = Core.getfield(a, 18)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %22 = Core.getfield(a, 19)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %23 = Core.getfield(a, 20)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %24 = Base.mul_int(x, %3)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %25 = Base.add_int(%24, %23)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %26 = Base.mul_int(x, %25)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %27 = Base.add_int(%26, %22)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %28 = Base.mul_int(x, %27)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %29 = Base.add_int(%28, %21)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %30 = Base.mul_int(x, %29)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %31 = Base.add_int(%30, %20)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %32 = Base.mul_int(x, %31)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %33 = Base.add_int(%32, %19)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %34 = Base.mul_int(x, %33)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %35 = Base.add_int(%34, %18)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %36 = Base.mul_int(x, %35)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %37 = Base.add_int(%36, %17)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %38 = Base.mul_int(x, %37)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %39 = Base.add_int(%38, %16)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %40 = Base.mul_int(x, %39)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %41 = Base.add_int(%40, %15)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %42 = Base.mul_int(x, %41)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %43 = Base.add_int(%42, %14)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %44 = Base.mul_int(x, %43)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %45 = Base.add_int(%44, %13)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %46 = Base.mul_int(x, %45)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %47 = Base.add_int(%46, %12)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %48 = Base.mul_int(x, %47)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %49 = Base.add_int(%48, %11)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %50 = Base.mul_int(x, %49)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %51 = Base.add_int(%50, %10)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %52 = Base.mul_int(x, %51)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %53 = Base.add_int(%52, %9)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %54 = Base.mul_int(x, %53)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %55 = Base.add_int(%54, %8)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %56 = Base.mul_int(x, %55)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %57 = Base.add_int(%56, %7)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %58 = Base.mul_int(x, %57)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %59 = Base.add_int(%58, %6)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %60 = Base.mul_int(x, %59)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %61 = Base.add_int(%60, %5)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %62 = Base.mul_int(x, %61)<span class="sgr36">::Int64</span>
<span class="sgr90">│  </span> %63 = Base.add_int(%62, %4)<span class="sgr36">::Int64</span>
<span class="sgr90">└──</span>       return %63
) =&gt; Int64</code></pre></p></details><h2 id="AST-manipulation:-The-first-steps-to-metaprogramming"><a class="docs-heading-anchor" href="#AST-manipulation:-The-first-steps-to-metaprogramming">AST manipulation: The first steps to metaprogramming</a><a id="AST-manipulation:-The-first-steps-to-metaprogramming-1"></a><a class="docs-heading-anchor-permalink" href="#AST-manipulation:-The-first-steps-to-metaprogramming" title="Permalink"></a></h2><p>Julia is so called homoiconic language, as it allows the language to reason about its code. This capability is inspired by years of development in other languages such as Lisp, Clojure or Prolog.</p><p>There are two easy ways to extract/construct the code structure <sup class="footnote-reference"><a id="citeref-5" href="#footnote-5">[5]</a></sup></p><ul><li>parsing code stored in string with internal <code>Meta.parse</code></li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_parse = Meta.parse(&quot;x = 2&quot;)    # for single line expressions (additional spaces are ignored)</code><code class="nohighlight hljs ansi" style="display:block;">:(x = 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_parse_block = Meta.parse(&quot;&quot;&quot;
       begin
           x = 2
           y = 3
           x + y
       end
       &quot;&quot;&quot;) # for multiline expressions</code><code class="nohighlight hljs ansi" style="display:block;">quote
    <span class="sgr90">#= none:2 =#</span>
    x = 2
    <span class="sgr90">#= none:3 =#</span>
    y = 3
    <span class="sgr90">#= none:4 =#</span>
    x + y
end</code></pre><ul><li>constructing an expression using <code>quote ... end</code> or simple <code>:()</code> syntax</li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_expr = :(x = 2)    # for single line expressions (additional spaces are ignored)</code><code class="nohighlight hljs ansi" style="display:block;">:(x = 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; code_expr_block = quote
           x = 2
           y = 3
           x + y
       end # for multiline expressions</code><code class="nohighlight hljs ansi" style="display:block;">quote
    <span class="sgr90">#= REPL[2]:2 =#</span>
    x = 2
    <span class="sgr90">#= REPL[2]:3 =#</span>
    y = 3
    <span class="sgr90">#= REPL[2]:4 =#</span>
    x + y
end</code></pre><p>Results can be stored into some variables, which we can inspect further.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(code_parse)</code><code class="nohighlight hljs ansi" style="display:block;">Expr</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dump(code_parse)</code><code class="nohighlight hljs ansi" style="display:block;">Expr
  head: Symbol =
  args: Array{Any}((2,))
    1: Symbol x
    2: Int64 2</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(code_parse_block)</code><code class="nohighlight hljs ansi" style="display:block;">Expr</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dump(code_parse_block)</code><code class="nohighlight hljs ansi" style="display:block;">Expr
  head: Symbol block
  args: Array{Any}((6,))
    1: LineNumberNode
      line: Int64 2
      file: Symbol none
    2: Expr
      head: Symbol =
      args: Array{Any}((2,))
        1: Symbol x
        2: Int64 2
    3: LineNumberNode
      line: Int64 3
      file: Symbol none
    4: Expr
      head: Symbol =
      args: Array{Any}((2,))
        1: Symbol y
        2: Int64 3
    5: LineNumberNode
      line: Int64 4
      file: Symbol none
    6: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Symbol x
        3: Symbol y</code></pre><p>The type of both multiline and single line expression is <code>Expr</code> with fields <code>head</code> and <code>args</code>. Notice that <code>Expr</code> type is recursive in the <code>args</code>, which can store other expressions resulting in a tree structure - abstract syntax tree (AST) - that can be visualized for example with the combination of <code>GraphRecipes</code> and <code>Plots</code> packages. </p><pre><code class="language-julia hljs">plot(code_expr_block, fontsize=12, shorten=0.01, axis_buffer=0.15, nodeshape=:rect)</code></pre><img src="53c148b5.svg" alt="Example block output"/><p>This recursive structure has some major performance drawbacks, because the <code>args</code> field is of type <code>Any</code> and therefore modifications of this expression level AST won&#39;t be type stable. Building blocks of expressions are <code>Symbol</code>s and literal values (numbers).</p><p>A possible nuisance of working with multiline expressions is the presence of <code>LineNumber</code> nodes, which can be removed with <code>Base.remove_linenums!</code> function.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.remove_linenums!(code_parse_block)</code><code class="nohighlight hljs ansi" style="display:block;">quote
    x = 2
    y = 3
    x + y
end</code></pre><p>Parsed expressions can be evaluate using <code>eval</code> function. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(code_parse)    # evaluation of :(x = 2)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x                   # should be defined</code><code class="nohighlight hljs ansi" style="display:block;">2</code></pre><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Before doing anything more fancy let&#39;s start with some simple manipulation of ASTs.</p><ul><li>Define a variable <code>code</code> to be as the result of parsing the string <code>&quot;j = i^2&quot;</code>. </li><li>Copy code into a variable <code>code2</code>. Modify this to replace the power <code>2</code> with a power <code>3</code>. Make sure that the original code variable is not also modified. </li><li>Copy <code>code2</code> to a variable <code>code3</code>. Replace <code>i</code> with <code>i + 1</code> in <code>code3</code>.</li><li>Define a variable <code>i</code> with the value <code>4</code>. Evaluate the different code expressions using the <code>eval</code> function and check the value of the variable <code>j</code>.</li></ul></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; code = Meta.parse(&quot;j = i^2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">:(j = i ^ 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; code2 = copy(code)</code><code class="nohighlight hljs ansi" style="display:block;">:(j = i ^ 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; code2.args[2].args[3] = 3</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; code3 = copy(code2)</code><code class="nohighlight hljs ansi" style="display:block;">:(j = i ^ 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; code3.args[2].args[2] = :(i + 1)</code><code class="nohighlight hljs ansi" style="display:block;">:(i + 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; i = 4</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(code), eval(code2), eval(code3)</code><code class="nohighlight hljs ansi" style="display:block;">(16, 64, 125)</code></pre></p></details><p>Following up on the more general substitution of variables in an expression from the lecture, let&#39;s see how the situation becomes more complicated, when we are dealing with strings instead of a parsed AST.</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><pre><code class="language-julia hljs">replace_i(s::Symbol) = s == :i ? :k : s
replace_i(e::Expr) = Expr(e.head, map(replace_i, e.args)...)
replace_i(u) = u</code></pre><p>Given a function <code>replace_i</code>, which replaces variables <code>i</code> for <code>k</code> in an expression like the following</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ex = :(i + i*i + y*i - sin(z))</code><code class="nohighlight hljs ansi" style="display:block;">:((i + i * i + y * i) - sin(z))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test replace_i(ex) == :(k + k*k + y*k - sin(z))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>write a different function <code>sreplace_i(s)</code>, which does the same thing but instead of a parsed expression (AST) it manipulates a string, such as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = string(ex)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;(i + i * i + y * i) - sin(z)&quot;</code></pre><p><strong>HINTS</strong>:</p><ul><li>Use <code>Meta.parse</code> in combination with <code>replace_i</code> <strong>ONLY</strong> for checking of correctness.</li><li>You can use the <code>replace</code> function in combination with regular expressions.</li><li>Think of some corner cases, that the method may not handle properly.</li></ul></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The naive solution</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sreplace_i(s) = replace(s, &#39;i&#39; =&gt; &#39;k&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">sreplace_i (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test Meta.parse(sreplace_i(s)) == replace_i(Meta.parse(s))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:1</span>
  Expression: Meta.parse(sreplace_i(s)) == replace_i(Meta.parse(s))
   Evaluated: (k + k * k + y * k) - skn(z) == (k + k * k + y * k) - sin(z)

ERROR: <span class="sgr91">There was an error during testing</span></code></pre><p>does not work in this simple case, because it will replace &quot;i&quot; inside the <code>sin(z)</code> expression. We can play with regular expressions to obtain something, that is more robust</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sreplace_i(s) = replace(s, r&quot;([^\w]|\b)i(?=[^\w]|\z)&quot; =&gt; s&quot;\1k&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">sreplace_i (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test Meta.parse(sreplace_i(s)) == replace_i(Meta.parse(s))</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>however the code may now be harder to read. Thus it is preferable to use the parsed AST when manipulating Julia&#39;s code.</p></p></details><p>If the exercises so far did not feel very useful let&#39;s focus on one, that is similar to a part of the <a href="https://github.com/JuliaIntervals/IntervalArithmetic.jl"><code>IntervalArithmetics.jl</code></a> pkg.</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Write function <code>wrap!(ex::Expr)</code> which wraps literal values (numbers) with a call to <code>f()</code>. You can test it on the following example</p><pre><code class="language-julia hljs">f = x -&gt; convert(Float64, x)
ex = :(x*x + 2*y*x + y*y)     # original expression
rex = :(x*x + f(2)*y*x + y*y) # result expression</code></pre><p><strong>HINTS</strong>:</p><ul><li>use recursion and multiple dispatch</li><li>dispatch on <code>::Number</code> to detect numbers in an expression</li><li>for testing purposes, create a copy of <code>ex</code> before mutating</li></ul></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function wrap!(ex::Expr)
           args = ex.args
       
           for i in 1:length(args)
               args[i] = wrap!(args[i])
           end
       
           return ex
       end</code><code class="nohighlight hljs ansi" style="display:block;">wrap! (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; wrap!(ex::Number) = Expr(:call, :f, ex)</code><code class="nohighlight hljs ansi" style="display:block;">wrap! (generic function with 2 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; wrap!(ex) = ex</code><code class="nohighlight hljs ansi" style="display:block;">wrap! (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ext, x, y = copy(ex), 2, 3</code><code class="nohighlight hljs ansi" style="display:block;">(:(x * x + 2 * y * x + y * y), 2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test wrap!(ex) == :(x*x + f(2)*y*x + y*y)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(ext)</code><code class="nohighlight hljs ansi" style="display:block;">25</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; eval(ex)</code><code class="nohighlight hljs ansi" style="display:block;">25.0</code></pre></p></details><p>This kind of manipulation is at the core of some pkgs, such as aforementioned <a href="https://github.com/JuliaIntervals/IntervalArithmetic.jl"><code>IntervalArithmetics.jl</code></a> where every number is replaced with a narrow interval in order to find some bounds on the result of a computation.</p><hr/><h2 id="Resources"><a class="docs-heading-anchor" href="#Resources">Resources</a><a id="Resources-1"></a><a class="docs-heading-anchor-permalink" href="#Resources" title="Permalink"></a></h2><ul><li>Julia&#39;s manual on <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">metaprogramming</a></li><li>David P. Sanders&#39; <a href="https://www.youtube.com/watch?v=2QLhw6LVaq0">workshop @ JuliaCon 2021</a> </li><li>Steven Johnson&#39;s <a href="https://www.youtube.com/watch?v=mSgXWpvQEHE">keynote talk @ JuliaCon 2019</a></li><li>Andy Ferris&#39;s <a href="https://www.youtube.com/watch?v=SeqAQHKLNj4">workshop @ JuliaCon 2018</a></li><li><a href="https://github.com/johnmyleswhite/julia_tutorials">From Macros to DSL</a> by John Myles White </li><li>Notes on <a href="https://hackmd.io/bVhb97Q4QTWeBQw8Rq4IFw?both#Julia-Compiler-Plugin-Project">JuliaCompilerPlugin</a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://en.wikipedia.org/wiki/Loop\\_unrolling">https://en.wikipedia.org/wiki/Loop_unrolling</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://en.wikipedia.org/wiki/Inline\\_expansion">https://en.wikipedia.org/wiki/Inline_expansion</a></li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a><a href="https://docs.julialang.org/en/v1/manual/faq/#What-does-the-...-operator-do?">https://docs.julialang.org/en/v1/manual/faq/#What-does-the-...-operator-do?</a></li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a><a href="https://docs.julialang.org/en/v1/manual/functions/#Varargs-Functions">https://docs.julialang.org/en/v1/manual/functions/#Varargs-Functions</a></li><li class="footnote" id="footnote-5"><a class="tag is-link" href="#citeref-5">5</a>Once you understand the recursive structure of expressions, the AST can be constructed manually like any other type.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lecture/">« Lecture</a><a class="docs-footer-nextpage" href="../hw/">Homework »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 10 October 2024 15:45">Thursday 10 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
